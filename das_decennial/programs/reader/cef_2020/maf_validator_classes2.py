#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This file was automatically generated by ../etl_2020/census_etl/spec_scanner.py on Fri Oct 30 14:06:06 2020
# Command line: ../etl_2020/census_etl/spec_scanner.py ../etl_2020/maf/AICD MAF-TIGER Products 2020.docx --output_parser maf_validator_classes.py --tablenames E I G GRFC20 L O P

# Automatically generated on Fri Oct 30 14:06:06 2020 by /mnt/users/user007/new-das-vm/das-vm-config/das_decennial/das_framework/ctools/schema/table.py

def leftpad(x,width):
    return ' '*(width-len(str(x)))+str(x)

def between(a,b,c,width):
    if len(b) > width:
        return False
    if '.' in a or '.' in b or '.' in c:
        try:
            return float(a) <= float(b) <= float(c)
        except ValueError:
            pass  # tries to return a float but might have weird input like 1.1.0 which will be compared traditionally instead
    b = b.replace(' ', '0')
    return leftpad(a,width) <= leftpad(b,width) <= leftpad(c,width)


def safe_int(i):
    try:
        return int(i)
    except (TypeError, ValueError):
        return None

def safe_float(i):
    try:
        return float(i)
    except (TypeError, ValueError):
        return None

def safe_str(i):
    try:
        return str(i)
    except (TypeError, ValueError):
        return None


class E_validator:
    @classmethod
    def is_valid_ABRAF(self,x):
        """Active Block Resolution Address Filter Flag"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_ACOCE(self,x):
        """Area Census Office"""
        if x is None or x == "None":
            return False
        return (between('2501',x,'2599',4)) or (leftpad(x,4)==leftpad('4030',4)) or (leftpad(x,4)==leftpad('3600',4)) or (leftpad(x,4)==leftpad('4000',4)) or (leftpad(x,4)==leftpad('3400',4)) or (leftpad(x,4)==leftpad('4020',4)) or (leftpad(x,4)==leftpad('3500',4)) or (leftpad(x,4)==leftpad('4010',4)) or (leftpad(x,4)==leftpad('4040',4)) or (between('3201',x,'3299',4)) or (between('2301',x,'2399',4)) or (between('2901',x,'2999',4)) or (between('3101',x,'3199',4)) or (between('2201',x,'2299',4))
    @classmethod
    def is_valid_BCUCOUNTYFP(self,x):
        """FIPS County Code"""
        if x is None or x == "None":
            return False
        return (between('001',x,'840',3))
    @classmethod
    def is_valid_BCUID(self,x):
        """Basic Collection Unit Identification Code"""
        if x is None or x == "None":
            return False
        return (between('00000100',x,'99999999',8))
    @classmethod
    def is_valid_BCUSTATEFP(self,x):
        """FIPS State Code"""
        if x is None or x == "None":
            return False
        return (leftpad(x,2)==leftpad('02',2)) or (leftpad(x,2)==leftpad('66',2)) or (leftpad(x,2)==leftpad('60',2)) or (between('44',x,'51',2)) or (leftpad(x,2)==leftpad('72',2)) or (leftpad(x,2)==leftpad('74',2)) or (leftpad(x,2)==leftpad('78',2)) or (leftpad(x,2)==leftpad('69',2)) or (between('08',x,'13',2)) or (leftpad(x,2)==leftpad('01',2)) or (between('15',x,'42',2)) or (between('04',x,'06',2)) or (between('53',x,'56',2))
    @classmethod
    def is_valid_BCUTRACTCE(self,x):
        """Census Tract Code"""
        if x is None or x == "None":
            return False
        return (between('000100',x,'998999',6))
    @classmethod
    def is_valid_CARRETERA(self,x):
        """Carretera"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_CENSTAT2010(self,x):
        """Official Census 2010 enumeration status of this MAFID, as obtained from the Census 2010 Decennial Master Address File (DMAF)"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,1)==leftpad('4',1)) or (leftpad(x,1)==leftpad('3',1)) or (leftpad(x,1)==leftpad('1',1)) or (leftpad(x,1)==leftpad('5',1)) or (leftpad(x,1)==leftpad('8',1)) or (leftpad(x,1)==leftpad('6',1)) or (leftpad(x,1)==leftpad('7',1)) or (leftpad(x,1)==leftpad('2',1)) or (leftpad(x,1)==leftpad('0',1))
    @classmethod
    def is_valid_CENSTAT2020(self,x):
        """Official Census 2020 enumeration status"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_CENSURV(self,x):
        """Survivor of a Census Address Flag"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,1)==leftpad('2',1)) or (leftpad(x,1)==leftpad('1',1)) or (leftpad(x,1)==leftpad('0',1))
    @classmethod
    def is_valid_CENSUS2010(self,x):
        """Census 2010 Unit Flag"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,1)==leftpad('Y',1)) or (leftpad(x,1)==leftpad('N',1))
    @classmethod
    def is_valid_CENSUS2020(self,x):
        """Census 2020 Unit Flag"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,1)==leftpad('Y',1)) or (leftpad(x,1)==leftpad('N',1))
    @classmethod
    def is_valid_CENSUSAF(self,x):
        """Decennial Listing Filter Flag"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,1)==leftpad('1',1)) or (leftpad(x,1)==leftpad('0',1))
    @classmethod
    def is_valid_CFUFVAF(self,x):
        """2010 Coverage Followup/Field Verification Address Filter Flag"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_COLLAF(self,x):
        """2010 Final Collection Address Filter Flag"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_COLLUNV(self,x):
        """Final Collection Universe Flag"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,1)==leftpad('Y',1)) or (leftpad(x,1)==leftpad('N',1))
    @classmethod
    def is_valid_COMPLETELOCNAME(self,x):
        """The Complete Location Display Name"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_COMPLETEMAILNAME(self,x):
        """The Complete Mailing Display Name"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_CONTITLE(self,x):
        """Title of Contact Person"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_COORDTYP(self,x):
        """Coordinate Collection Type"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,1)==leftpad('D',1)) or (leftpad(x,1)==leftpad('I',1)) or (leftpad(x,1)==leftpad('L',1)) or (leftpad(x,1)==leftpad('G',1)) or (leftpad(x,1)==leftpad('O',1)) or (leftpad(x,1)==leftpad('P',1)) or (leftpad(x,1)==leftpad('R',1)) or (leftpad(x,1)==leftpad('S',1)) or (leftpad(x,1)==leftpad('M',1)) or (leftpad(x,1)==leftpad('W',1)) or (leftpad(x,1)==leftpad('E',1)) or (leftpad(x,1)==leftpad('Q',1))
    @classmethod
    def is_valid_CURBLK(self,x):
        """Current Block – Census Block Number"""
        if x is None or x == "None":
            return False
        return True
    @classmethod
    def is_valid_CURBLKCOU(self,x):
        """Current Block – FIPS County Code"""
        if x is None or x == "None":
            return False
        return (between('001',x,'840',3))
    @classmethod
    def is_valid_CURBLKST(self,x):
        """Current Block – FIPS State Code"""
        if x is None or x == "None":
            return False
        return (leftpad(x,2)==leftpad('02',2)) or (leftpad(x,2)==leftpad('66',2)) or (leftpad(x,2)==leftpad('60',2)) or (between('44',x,'51',2)) or (leftpad(x,2)==leftpad('72',2)) or (leftpad(x,2)==leftpad('74',2)) or (leftpad(x,2)==leftpad('78',2)) or (leftpad(x,2)==leftpad('69',2)) or (between('08',x,'13',2)) or (leftpad(x,2)==leftpad('01',2)) or (between('15',x,'42',2)) or (between('04',x,'06',2)) or (between('53',x,'56',2))
    @classmethod
    def is_valid_CURBLKSUFX1(self,x):
        """Current Block – Block Suffix 1"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (between('A',x,'Z',1))
    @classmethod
    def is_valid_CURBLKSUFX2(self,x):
        """Current Block – Block Suffix 2"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (between('A',x,'Z',1))
    @classmethod
    def is_valid_CURBLKTRACT(self,x):
        """Current Block – Census Tract Code"""
        if x is None or x == "None":
            return False
        return (between('000100',x,'998999',6))
    @classmethod
    def is_valid_CURCOUNTY(self,x):
        """Current FIPS County Code"""
        if x is None or x == "None":
            return False
        return (between('001',x,'840',3))
    @classmethod
    def is_valid_CURSTATE(self,x):
        """Current FIPS State Code"""
        if x is None or x == "None":
            return False
        return (leftpad(x,2)==leftpad('02',2)) or (leftpad(x,2)==leftpad('66',2)) or (leftpad(x,2)==leftpad('60',2)) or (between('44',x,'51',2)) or (leftpad(x,2)==leftpad('72',2)) or (leftpad(x,2)==leftpad('74',2)) or (leftpad(x,2)==leftpad('78',2)) or (leftpad(x,2)==leftpad('69',2)) or (between('08',x,'13',2)) or (leftpad(x,2)==leftpad('01',2)) or (between('15',x,'42',2)) or (between('04',x,'06',2)) or (between('53',x,'56',2))
    @classmethod
    def is_valid_DELPTTYPE(self,x):
        """DSF Delivery Point Type"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,1)==leftpad('D',1)) or (leftpad(x,1)==leftpad('4',1)) or (leftpad(x,1)==leftpad('8',1)) or (leftpad(x,1)==leftpad('K',1)) or (leftpad(x,1)==leftpad('B',1)) or (leftpad(x,1)==leftpad('H',1)) or (leftpad(x,1)==leftpad('N',1)) or (leftpad(x,1)==leftpad('O',1)) or (leftpad(x,1)==leftpad('V',1)) or (leftpad(x,1)==leftpad('Z',1)) or (leftpad(x,1)==leftpad('F',1)) or (leftpad(x,1)==leftpad('I',1)) or (leftpad(x,1)==leftpad('J',1)) or (leftpad(x,1)==leftpad('L',1)) or (leftpad(x,1)==leftpad('R',1)) or (leftpad(x,1)==leftpad('7',1)) or (leftpad(x,1)==leftpad('C',1)) or (leftpad(x,1)==leftpad('2',1)) or (leftpad(x,1)==leftpad('T',1)) or (leftpad(x,1)==leftpad('6',1)) or (leftpad(x,1)==leftpad('W',1)) or (leftpad(x,1)==leftpad('1',1)) or (leftpad(x,1)==leftpad('A',1)) or (leftpad(x,1)==leftpad('5',1)) or (leftpad(x,1)==leftpad('3',1)) or (leftpad(x,1)==leftpad('G',1)) or (leftpad(x,1)==leftpad('P',1)) or (leftpad(x,1)==leftpad('U',1)) or (leftpad(x,1)==leftpad('Y',1)) or (leftpad(x,1)==leftpad('S',1)) or (leftpad(x,1)==leftpad('M',1)) or (leftpad(x,1)==leftpad('E',1)) or (leftpad(x,1)==leftpad('X',1))
    @classmethod
    def is_valid_DSAF(self,x):
        """Delivery Specific Address Flag"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,1)==leftpad('2',1)) or (leftpad(x,1)==leftpad('4',1)) or (leftpad(x,1)==leftpad('3',1)) or (leftpad(x,1)==leftpad('1',1))
    @classmethod
    def is_valid_DSFBASEALT(self,x):
        """Alternate/Base Flag"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,1)==leftpad('B',1)) or (leftpad(x,1)==leftpad('A',1))
    @classmethod
    def is_valid_DSFFALLAST(self,x):
        """Most Recent Fall DSF Value"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_DSFRT(self,x):
        """DSF Record Type"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,1)==leftpad('G',1)) or (leftpad(x,1)==leftpad('F',1)) or (leftpad(x,1)==leftpad('P',1)) or (leftpad(x,1)==leftpad('R',1)) or (leftpad(x,1)==leftpad('H',1)) or (leftpad(x,1)==leftpad('S',1))
    @classmethod
    def is_valid_DSFSPRLAST(self,x):
        """Most Recent Spring DSF Value"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_ENUMAF(self,x):
        """Current Enumeration Universe Address Filter Flag"""
        if x is None or x == "None":
            return False
        return (leftpad(x,1)==leftpad('1',1)) or (leftpad(x,1)==leftpad('0',1))
    @classmethod
    def is_valid_ENUMAF2010(self,x):
        """2010 Enumeration Universe Address Filter Flag"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_ENUMUNV(self,x):
        """Enumeration Universe Flag"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,1)==leftpad('G',1)) or (leftpad(x,1)==leftpad('N',1)) or (leftpad(x,1)==leftpad('T',1)) or (leftpad(x,1)==leftpad('H',1))
    @classmethod
    def is_valid_FACTLNAME(self,x):
        """Facility Name for Group Quarters/Transitory Location Name"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_GQAREACODE(self,x):
        """GQ Area Code"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_GQCONTACT(self,x):
        """GQ Contact"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_GQCURRMAXPOP(self,x):
        """Maximum number of persons at the GQ"""
        if x is None or x == "None" or len(x) == 0:
            return True
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return True
    @classmethod
    def is_valid_GQCURRSIZE(self,x):
        """A count at the GQ from the last ACS or Current Surveys visit"""
        if x is None or x == "None" or len(x) == 0:
            return True
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return True
    @classmethod
    def is_valid_GQEXT(self,x):
        """GQ Phone Number Extension"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_GQHUFLAG(self,x):
        """Group Quarters/HU Flag"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,1)==leftpad('5',1)) or (leftpad(x,1)==leftpad('4',1)) or (leftpad(x,1)==leftpad('3',1)) or (leftpad(x,1)==leftpad('2',1)) or (leftpad(x,1)==leftpad('0',1))
    @classmethod
    def is_valid_GQID(self,x):
        """Group Quarters ID"""
        if x is None or x == "None" or len(x) == 0:
            return True
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return (1 <= x <= 9999)
    @classmethod
    def is_valid_GQNAME(self,x):
        """Group Quarters Name"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_GQPHONE(self,x):
        """GQ Phone Number"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_GQTYPCUR(self,x):
        """Current Group Quarters Type code"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,3)==leftpad('602',3)) or (leftpad(x,3)==leftpad('703',3)) or (leftpad(x,3)==leftpad('103',3)) or (leftpad(x,3)==leftpad('301',3)) or (leftpad(x,3)==leftpad('802',3)) or (leftpad(x,3)==leftpad('902',3)) or (leftpad(x,3)==leftpad('105',3)) or (leftpad(x,3)==leftpad('104',3)) or (leftpad(x,3)==leftpad('706',3)) or (leftpad(x,3)==leftpad('900',3)) or (leftpad(x,3)==leftpad('601',3)) or (leftpad(x,3)==leftpad('0',3)) or (leftpad(x,3)==leftpad('502',3)) or (leftpad(x,3)==leftpad('101',3)) or (leftpad(x,3)==leftpad('999',3)) or (leftpad(x,3)==leftpad('404',3)) or (leftpad(x,3)==leftpad('201',3)) or (leftpad(x,3)==leftpad('106',3)) or (leftpad(x,3)==leftpad('702',3)) or (leftpad(x,3)==leftpad('202',3)) or (leftpad(x,3)==leftpad('501',3)) or (leftpad(x,3)==leftpad('704',3)) or (leftpad(x,3)==leftpad('801',3)) or (leftpad(x,3)==leftpad('901',3)) or (leftpad(x,3)==leftpad('903',3)) or (leftpad(x,3)==leftpad('102',3)) or (leftpad(x,3)==leftpad('701',3)) or (leftpad(x,3)==leftpad('401',3)) or (leftpad(x,3)==leftpad('402',3)) or (leftpad(x,3)==leftpad('403',3)) or (leftpad(x,3)==leftpad('405',3)) or (leftpad(x,3)==leftpad('203',3))
    @classmethod
    def is_valid_HUTYP(self,x):
        """Housing unit type"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,1)==leftpad('M',1)) or (leftpad(x,1)==leftpad('T',1)) or (leftpad(x,1)==leftpad('S',1)) or (leftpad(x,1)==leftpad('O',1))
    @classmethod
    def is_valid_INITUCMAF(self,x):
        """Initial UC & M Universe Address Filter Flag"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,1)==leftpad('4',1)) or (leftpad(x,1)==leftpad('3',1)) or (leftpad(x,1)==leftpad('1',1)) or (leftpad(x,1)==leftpad('5',1)) or (leftpad(x,1)==leftpad('6',1)) or (leftpad(x,1)==leftpad('2',1)) or (leftpad(x,1)==leftpad('0',1))
    @classmethod
    def is_valid_INSITE(self,x):
        """Test Site Flag"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,1)==leftpad('Y',1)) or (leftpad(x,1)==leftpad('N',1)) or (leftpad(x,1)==leftpad('1',1)) or (leftpad(x,1)==leftpad('0',1))
    @classmethod
    def is_valid_IOACIRAF(self,x):
        """In-Office Canvassing Interactive Review Address Filter Flag"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_IS2020DLV(self,x):
        """2020 Census Deliverable Flag"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,1)==leftpad('Y',1)) or (leftpad(x,1)==leftpad('N',1))
    @classmethod
    def is_valid_ISOLQ(self,x):
        """Military Address Flag"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,1)==leftpad('1',1))
    @classmethod
    def is_valid_ISUCMDLV(self,x):
        """2010 UC&M Deliverable Flag"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,1)==leftpad('Y',1)) or (leftpad(x,1)==leftpad('N',1))
    @classmethod
    def is_valid_KMHM(self,x):
        """Kilometer/Hectometer Marker"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_LEGACYMAFID(self,x):
        """Field that stores the Legacy Within-County MAFID"""
        if x is None or x == "None":
            return False
        return True
    @classmethod
    def is_valid_LIMADEL(self,x):
        """LIMA Delivery Flag"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_LOCAPTCOMPLEX(self,x):
        """Location Address – Name of an apartment Complex, subdivision, named development, or mobile park"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_LOCAREANM1(self,x):
        """Location Area Name Part 1 (Puerto Rico-only)"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_LOCAREANM2(self,x):
        """Location Area Name Part 2 (Puerto Rico-only)"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_LOCBLDGDESC(self,x):
        """Location Address Building Descriptor"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_LOCBLDGID(self,x):
        """Location Address Building Identifier"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_LOCDESC(self,x):
        """Location Description"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_LOCHN1(self,x):
        """Location Address First Part of House Number"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_LOCHN2(self,x):
        """Location address Second Part of House Number"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_LOCHNPR(self,x):
        """Location Address – House Number (Puerto Rico)"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_LOCHNPRE(self,x):
        """Location Address House Number Prefix"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_LOCHNSEP(self,x):
        """Location Address House Number Separator"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_LOCHNSUF(self,x):
        """Location Address House Number Suffix"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_LOCHNTYPE(self,x):
        """Location Address – House Number/Building Number Type"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,1)==leftpad('B',1)) or (leftpad(x,1)==leftpad('H',1))
    @classmethod
    def is_valid_LOCISMAIL(self,x):
        """Location Address is also a Current DSF Address"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,1)==leftpad('Y',1)) or (leftpad(x,1)==leftpad('N',1))
    @classmethod
    def is_valid_LOCNAME(self,x):
        """Location Address – Base Street Name"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_LOCPLUS4(self,x):
        """Location Address ZIP+4 Code"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_LOCPREDIR(self,x):
        """Location Address – Street Name Prefix Direction"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,2)==leftpad('NO',2)) or (leftpad(x,2)==leftpad('N',2)) or (leftpad(x,2)==leftpad('O',2)) or (leftpad(x,2)==leftpad('NE',2)) or (leftpad(x,2)==leftpad('NW',2)) or (leftpad(x,2)==leftpad('S',2)) or (leftpad(x,2)==leftpad('SE',2)) or (leftpad(x,2)==leftpad('SO',2)) or (leftpad(x,2)==leftpad('SW',2)) or (leftpad(x,2)==leftpad('W',2)) or (leftpad(x,2)==leftpad('E',2))
    @classmethod
    def is_valid_LOCPREQUAL(self,x):
        """Location Address – Street Name Prefix Qualifier"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,3)==leftpad('PVT',3)) or (leftpad(x,3)==leftpad('SPR',3)) or (leftpad(x,3)==leftpad('BYP',3)) or (leftpad(x,3)==leftpad('HST',3)) or (leftpad(x,3)==leftpad('OLD',3)) or (leftpad(x,3)==leftpad('PUB',3)) or (leftpad(x,3)==leftpad('EXD',3)) or (leftpad(x,3)==leftpad('LP',3)) or (leftpad(x,3)==leftpad('BUS',3)) or (leftpad(x,3)==leftpad('ALT',3))
    @classmethod
    def is_valid_LOCPRETYP(self,x):
        """Location Address – Street Name Prefix Type"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_LOCSTBLDIND(self,x):
        """Location Address – Street/Building Indicator"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,1)==leftpad('1',1)) or (leftpad(x,1)==leftpad('0',1))
    @classmethod
    def is_valid_LOCSTNMSRC(self,x):
        """Location Address – Street Name Source"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,1)==leftpad('1',1)) or (leftpad(x,1)==leftpad('0',1))
    @classmethod
    def is_valid_LOCSUFDIR(self,x):
        """Location Address – Street Name Suffix Direction"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,2)==leftpad('NO',2)) or (leftpad(x,2)==leftpad('N',2)) or (leftpad(x,2)==leftpad('O',2)) or (leftpad(x,2)==leftpad('NW',2)) or (leftpad(x,2)==leftpad('NE',2)) or (leftpad(x,2)==leftpad('S',2)) or (leftpad(x,2)==leftpad('SE',2)) or (leftpad(x,2)==leftpad('SO',2)) or (leftpad(x,2)==leftpad('E',2)) or (leftpad(x,2)==leftpad('W',2)) or (leftpad(x,2)==leftpad('SW',2))
    @classmethod
    def is_valid_LOCSUFQUAL(self,x):
        """Location Address – Street Name Suffix Qualifier"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,3)==leftpad('PVT',3)) or (leftpad(x,3)==leftpad('SPR',3)) or (leftpad(x,3)==leftpad('BYP',3)) or (leftpad(x,3)==leftpad('OVP',3)) or (leftpad(x,3)==leftpad('ALT',3)) or (leftpad(x,3)==leftpad('PUB',3)) or (leftpad(x,3)==leftpad('ACC',3)) or (leftpad(x,3)==leftpad('EXD',3)) or (leftpad(x,3)==leftpad('BUS',3)) or (leftpad(x,3)==leftpad('EXN',3)) or (leftpad(x,3)==leftpad('LP',3)) or (leftpad(x,3)==leftpad('UNP',3)) or (leftpad(x,3)==leftpad('SCN',3)) or (leftpad(x,3)==leftpad('RMP',3)) or (leftpad(x,3)==leftpad('CON',3))
    @classmethod
    def is_valid_LOCSUFTYP(self,x):
        """Location Address – Street Name Suffix Type"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_LOCURB(self,x):
        """Location Address Urbanization (Puerto Rico)"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_LOCWSDESC1(self,x):
        """Location Address Within Structure Descriptor 1"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,12)==leftpad('PARTE',12)) or (leftpad(x,12)==leftpad('BAY',12)) or (leftpad(x,12)==leftpad('PISO',12)) or (leftpad(x,12)==leftpad('STORE',12)) or (leftpad(x,12)==leftpad('UNIT',12)) or (leftpad(x,12)==leftpad('STES',12)) or (leftpad(x,12)==leftpad('ALTOS',12)) or (leftpad(x,12)==leftpad('IZQ',12)) or (leftpad(x,12)==leftpad('SLIP',12)) or (leftpad(x,12)==leftpad('BAJOS',12)) or (leftpad(x,12)==leftpad('EXT',12)) or (leftpad(x,12)==leftpad('HANGAR',12)) or (leftpad(x,12)==leftpad('APT',12)) or (leftpad(x,12)==leftpad('STE',12)) or (leftpad(x,12)==leftpad('DEPT',12)) or (leftpad(x,12)==leftpad('STUDIO',12)) or (leftpad(x,12)==leftpad('PH',12)) or (leftpad(x,12)==leftpad('ROOM',12)) or (leftpad(x,12)==leftpad('ATRAS',12)) or (leftpad(x,12)==leftpad('LOT',12)) or (leftpad(x,12)==leftpad('DER',12)) or (leftpad(x,12)==leftpad('MH',12)) or (leftpad(x,12)==leftpad('SOTANO',12)) or (leftpad(x,12)==leftpad('STALL',12)) or (leftpad(x,12)==leftpad('STOP',12)) or (leftpad(x,12)==leftpad('SPACE',12)) or (leftpad(x,12)==leftpad('TRLR',12)) or (leftpad(x,12)==leftpad('ALD',12)) or (leftpad(x,12)==leftpad('INT',12)) or (leftpad(x,12)==leftpad('PIER',12))
    @classmethod
    def is_valid_LOCWSID1(self,x):
        """Location Address Within Structure ID 1"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_LOCZIP(self,x):
        """Location Address 5-digit ZIP Code"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_LOCZIPCLASS(self,x):
        """Location Address – ZIP Code Classification Code"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,1)==leftpad('U',1)) or (leftpad(x,1)==leftpad('M',1)) or (leftpad(x,1)==leftpad('P',1))
    @classmethod
    def is_valid_LUCAAF2020(self,x):
        """LUCA Address Filter Flag for 2020"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_MAFCSFAIL(self,x):
        """MAF Coverage Study Fail Flag"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_MAFID(self,x):
        """Permanent MAFUNIT ID"""
        if x is None or x == "None":
            return False
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return True
    @classmethod
    def is_valid_MAFSRC(self,x):
        """Original MAF Source Code"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_MAILAPTCOMPLEX(self,x):
        """Mailing Address – Name of an apartment complex, subdivision , named development, or mobile park"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_MAILAREANM1(self,x):
        """“Barrio”, “Barriada”,”Sector”, “Parcela”, “Communidad” (Puerto Rico)"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_MAILAREANM2(self,x):
        """“Barrio”, “Barriada”,”Sector”, “Parcela”, “Communidad” (Puerto Rico)"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_MAILBLDGDESC(self,x):
        """Mailing Address – Building Descriptor"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_MAILBLDGID(self,x):
        """Mailing Address – Building Identifier"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_MAILHN1(self,x):
        """Mailing Address First Part of House Number"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_MAILHN2(self,x):
        """Mailing Address Second Part of House Number"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_MAILHNPR(self,x):
        """Mailing Address – House Number (Puerto Rico)"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_MAILHNPRE(self,x):
        """Mailing Address House Number Prefix"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_MAILHNSEP(self,x):
        """Mailing Address House Number Separator"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_MAILHNSUF(self,x):
        """Mailing Address House Number Suffix"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_MAILHNTYPE(self,x):
        """Mailing Address House Number Type"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,1)==leftpad('B',1)) or (leftpad(x,1)==leftpad('H',1))
    @classmethod
    def is_valid_MAILNAME(self,x):
        """Mailing Address – Base Street Name"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_MAILPLUS4(self,x):
        """Mailing Address ZIP+4 Code"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_MAILPOBOXID(self,x):
        """Mailing Address – Post Office Box ID"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_MAILPREDIR(self,x):
        """Mailing Address – Street Name Prefix Direction"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,2)==leftpad('NO',2)) or (leftpad(x,2)==leftpad('N',2)) or (leftpad(x,2)==leftpad('O',2)) or (leftpad(x,2)==leftpad('NW',2)) or (leftpad(x,2)==leftpad('NE',2)) or (leftpad(x,2)==leftpad('S',2)) or (leftpad(x,2)==leftpad('SE',2)) or (leftpad(x,2)==leftpad('SO',2)) or (leftpad(x,2)==leftpad('E',2)) or (leftpad(x,2)==leftpad('W',2)) or (leftpad(x,2)==leftpad('SW',2))
    @classmethod
    def is_valid_MAILPREQUAL(self,x):
        """Mailing Address – Street Name Prefix Qualifier"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,3)==leftpad('PVT',3)) or (leftpad(x,3)==leftpad('SPR',3)) or (leftpad(x,3)==leftpad('BYP',3)) or (leftpad(x,3)==leftpad('HST',3)) or (leftpad(x,3)==leftpad('OLD',3)) or (leftpad(x,3)==leftpad('PUB',3)) or (leftpad(x,3)==leftpad('EXD',3)) or (leftpad(x,3)==leftpad('LP',3)) or (leftpad(x,3)==leftpad('BUS',3)) or (leftpad(x,3)==leftpad('ALT',3))
    @classmethod
    def is_valid_MAILPRETYP(self,x):
        """Mailing Address – Street Name Prefix Type"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_MAILRRBOXID(self,x):
        """Mailing Address – Rural Route Box ID"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_MAILRRDESC(self,x):
        """Mailing Address – Rural Route Descriptor"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,25)==leftpad('RR',25)) or (leftpad(x,25)==leftpad('PSC',25)) or (leftpad(x,25)==leftpad('HC',25))
    @classmethod
    def is_valid_MAILRRID(self,x):
        """Mailing Address – Rural Route ID"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_MAILSTBLDIND(self,x):
        """Mailing Address – Street/Building Indicator"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,1)==leftpad('1',1)) or (leftpad(x,1)==leftpad('0',1))
    @classmethod
    def is_valid_MAILSTNMSRC(self,x):
        """Mailing Address – Street Name Source"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,1)==leftpad('1',1)) or (leftpad(x,1)==leftpad('0',1))
    @classmethod
    def is_valid_MAILSUFDIR(self,x):
        """Mailing Address – Street Name Suffix Direction"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,2)==leftpad('NO',2)) or (leftpad(x,2)==leftpad('N',2)) or (leftpad(x,2)==leftpad('O',2)) or (leftpad(x,2)==leftpad('NW',2)) or (leftpad(x,2)==leftpad('NE',2)) or (leftpad(x,2)==leftpad('S',2)) or (leftpad(x,2)==leftpad('SE',2)) or (leftpad(x,2)==leftpad('SO',2)) or (leftpad(x,2)==leftpad('E',2)) or (leftpad(x,2)==leftpad('W',2)) or (leftpad(x,2)==leftpad('SW',2))
    @classmethod
    def is_valid_MAILSUFQUAL(self,x):
        """Mailing Address – Street Name Suffix Qualifier"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,3)==leftpad('PVT',3)) or (leftpad(x,3)==leftpad('SPR',3)) or (leftpad(x,3)==leftpad('BYP',3)) or (leftpad(x,3)==leftpad('OVP',3)) or (leftpad(x,3)==leftpad('ALT',3)) or (leftpad(x,3)==leftpad('PUB',3)) or (leftpad(x,3)==leftpad('ACC',3)) or (leftpad(x,3)==leftpad('EXD',3)) or (leftpad(x,3)==leftpad('BUS',3)) or (leftpad(x,3)==leftpad('EXN',3)) or (leftpad(x,3)==leftpad('LP',3)) or (leftpad(x,3)==leftpad('UNP',3)) or (leftpad(x,3)==leftpad('SCN',3)) or (leftpad(x,3)==leftpad('RMP',3)) or (leftpad(x,3)==leftpad('CON',3))
    @classmethod
    def is_valid_MAILSUFTYP(self,x):
        """Mailing Address – Street Name Suffix Type"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_MAILURB(self,x):
        """Mailing Address – Urbanization (Puerto Rico)"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_MAILWSDESC1(self,x):
        """Mailing Address – Within Structure Descriptor"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,12)==leftpad('PARTE',12)) or (leftpad(x,12)==leftpad('BAY',12)) or (leftpad(x,12)==leftpad('PISO',12)) or (leftpad(x,12)==leftpad('STORE',12)) or (leftpad(x,12)==leftpad('UNIT',12)) or (leftpad(x,12)==leftpad('STES',12)) or (leftpad(x,12)==leftpad('ALTOS',12)) or (leftpad(x,12)==leftpad('IZQ',12)) or (leftpad(x,12)==leftpad('SLIP',12)) or (leftpad(x,12)==leftpad('BAJOS',12)) or (leftpad(x,12)==leftpad('EXT',12)) or (leftpad(x,12)==leftpad('HANGAR',12)) or (leftpad(x,12)==leftpad('APT',12)) or (leftpad(x,12)==leftpad('STE',12)) or (leftpad(x,12)==leftpad('DEPT',12)) or (leftpad(x,12)==leftpad('STUDIO',12)) or (leftpad(x,12)==leftpad('PH',12)) or (leftpad(x,12)==leftpad('ROOM',12)) or (leftpad(x,12)==leftpad('ATRAS',12)) or (leftpad(x,12)==leftpad('LOT',12)) or (leftpad(x,12)==leftpad('DER',12)) or (leftpad(x,12)==leftpad('MH',12)) or (leftpad(x,12)==leftpad('SOTANO',12)) or (leftpad(x,12)==leftpad('STALL',12)) or (leftpad(x,12)==leftpad('STOP',12)) or (leftpad(x,12)==leftpad('SPACE',12)) or (leftpad(x,12)==leftpad('TRLR',12)) or (leftpad(x,12)==leftpad('ALD',12)) or (leftpad(x,12)==leftpad('INT',12)) or (leftpad(x,12)==leftpad('PIER',12))
    @classmethod
    def is_valid_MAILWSID1(self,x):
        """Mailing Address – Within Structure ID 1"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_MAILZIP(self,x):
        """Mailing Address 5-digit ZIP Code"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_MAILZIPCLASS(self,x):
        """Mailing Address – ZIP Code Classification Code"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,1)==leftpad('U',1)) or (leftpad(x,1)==leftpad('M',1)) or (leftpad(x,1)==leftpad('P',1))
    @classmethod
    def is_valid_MSPID(self,x):
        """Map Spot Identification Code"""
        if x is None or x == "None" or len(x) == 0:
            return True
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return (1 <= x <= 99) or (x==999)
    @classmethod
    def is_valid_MTFCC(self,x):
        """MAF TIGER Feature Class Code"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,5)==leftpad('U3000',5)) or (leftpad(x,5)==leftpad('U2200',5)) or (leftpad(x,5)==leftpad('U1000',5)) or (leftpad(x,5)==leftpad('U1200',5)) or (leftpad(x,5)==leftpad('U2100',5)) or (leftpad(x,5)==leftpad('U2000',5))
    @classmethod
    def is_valid_NRFUAF(self,x):
        """Nonresponse Followup Address Filter Flag"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,1)==leftpad('2',1)) or (leftpad(x,1)==leftpad('1',1)) or (leftpad(x,1)==leftpad('0',1))
    @classmethod
    def is_valid_NRFUUNV(self,x):
        """Nonresponse Followup Universe Flag"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,1)==leftpad('Y',1)) or (leftpad(x,1)==leftpad('N',1))
    @classmethod
    def is_valid_NUMUNITS(self,x):
        """Number of units at this BSA"""
        if x is None or x == "None" or len(x) == 0:
            return True
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return True
    @classmethod
    def is_valid_OFLAT(self,x):
        """Official Coordinates – Latitude"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_OFLON(self,x):
        """Official Coordinates – Longitude"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_OID(self,x):
        """MAF Unit Object Identification Code"""
        if x is None or x == "None":
            return False
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return True
    @classmethod
    def is_valid_OIDBCU(self,x):
        """Basic Collection Unit Object Identification Code"""
        if x is None or x == "None" or len(x) == 0:
            return True
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return True
    @classmethod
    def is_valid_OIDTB(self,x):
        """PD Tabulation Block OID"""
        if x is None or x == "None" or len(x) == 0:
            return True
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return True
    @classmethod
    def is_valid_PDCONVNEW(self,x):
        """LACS Conversion Flag (New Unit)"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,1)==leftpad('4',1)) or (leftpad(x,1)==leftpad('3',1)) or (leftpad(x,1)==leftpad('1',1)) or (leftpad(x,1)==leftpad('8',1)) or (leftpad(x,1)==leftpad('7',1)) or (leftpad(x,1)==leftpad('6',1))
    @classmethod
    def is_valid_PDCONVOLD(self,x):
        """LACS Conversion Flag (Old Unit)"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,1)==leftpad('4',1)) or (leftpad(x,1)==leftpad('3',1)) or (leftpad(x,1)==leftpad('1',1)) or (leftpad(x,1)==leftpad('8',1)) or (leftpad(x,1)==leftpad('7',1)) or (leftpad(x,1)==leftpad('6',1))
    @classmethod
    def is_valid_POPDEC(self,x):
        """Census 2000 Population"""
        if x is None or x == "None" or len(x) == 0:
            return True
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return (0 <= x <= 350) or (x==000)
    @classmethod
    def is_valid_POPDEC2010(self,x):
        """Census 2010 Population"""
        if x is None or x == "None" or len(x) == 0:
            return True
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return True
    @classmethod
    def is_valid_POPDEC2020(self,x):
        """Census 2020 Population"""
        if x is None or x == "None" or len(x) == 0:
            return True
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return True
    @classmethod
    def is_valid_POSTPLUS4(self,x):
        """USPS – ZIP+4 Code"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_POSTZIP(self,x):
        """USPS – 5-digit ZIP Code"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_POSTZIPCLASS(self,x):
        """USPS – ZIP Code Classification Code"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,1)==leftpad('U',1)) or (leftpad(x,1)==leftpad('M',1)) or (leftpad(x,1)==leftpad('P',1))
    @classmethod
    def is_valid_RAMAL(self,x):
        """Ramal"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_RESSTAT(self,x):
        """Residential Status Flag"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,1)==leftpad('2',1)) or (leftpad(x,1)==leftpad('1',1))
    @classmethod
    def is_valid_SECCION(self,x):
        """Seccion"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_SIDE(self,x):
        """Side Indicator Flag"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,1)==leftpad('R',1)) or (leftpad(x,1)==leftpad('L',1))
    @classmethod
    def is_valid_SUPNRFUAF(self,x):
        """2010 Supplemental Nonresponse Followup Address Filter Flag"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,1)==leftpad('4',1)) or (leftpad(x,1)==leftpad('3',1)) or (leftpad(x,1)==leftpad('1',1)) or (leftpad(x,1)==leftpad('5',1)) or (leftpad(x,1)==leftpad('6',1)) or (leftpad(x,1)==leftpad('7',1)) or (leftpad(x,1)==leftpad('2',1)) or (leftpad(x,1)==leftpad('0',1))
    @classmethod
    def is_valid_SUPNRFUUNV(self,x):
        """Supplemental NRFU Universe Flag"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,1)==leftpad('N',1)) or (leftpad(x,1)==leftpad('H',1))
    @classmethod
    def is_valid_SURVMAFID(self,x):
        """Surviving MAFID"""
        if x is None or x == "None" or len(x) == 0:
            return True
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return True
    @classmethod
    def is_valid_TAB2010BLK(self,x):
        """2010 TAB Block – Census Block Number"""
        if x is None or x == "None":
            return False
        return True
    @classmethod
    def is_valid_TAB2010BLKCOU(self,x):
        """2010 TAB Block – FIPS County Code"""
        if x is None or x == "None":
            return False
        return (between('001',x,'840',3))
    @classmethod
    def is_valid_TAB2010BLKST(self,x):
        """2010 TAB Block – FIPS State Code"""
        if x is None or x == "None":
            return False
        return (leftpad(x,2)==leftpad('02',2)) or (leftpad(x,2)==leftpad('66',2)) or (leftpad(x,2)==leftpad('60',2)) or (between('44',x,'51',2)) or (leftpad(x,2)==leftpad('72',2)) or (leftpad(x,2)==leftpad('74',2)) or (leftpad(x,2)==leftpad('78',2)) or (leftpad(x,2)==leftpad('69',2)) or (between('08',x,'13',2)) or (leftpad(x,2)==leftpad('01',2)) or (between('15',x,'42',2)) or (between('04',x,'06',2)) or (between('53',x,'56',2))
    @classmethod
    def is_valid_TAB2010BLKSUFX1(self,x):
        """2010 TAB Block – Block Suffix 1"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (between('A',x,'Z',1))
    @classmethod
    def is_valid_TAB2010BLKSUFX2(self,x):
        """2010 TAB Block – Block Suffix 2"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (between('A',x,'Z',1))
    @classmethod
    def is_valid_TAB2010BLKTRACT(self,x):
        """2010 TAB Block – Census Tract Code"""
        if x is None or x == "None":
            return False
        return (between('000100',x,'998999',6))
    @classmethod
    def is_valid_TAB2020BLK(self,x):
        """2020 TAB Block – Census Block Number"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_TAB2020BLKCOU(self,x):
        """2020 TAB Block – FIPS County Code"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (between('001',x,'840',3))
    @classmethod
    def is_valid_TAB2020BLKST(self,x):
        """2020 TAB Block – FIPS State Code"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,2)==leftpad('02',2)) or (leftpad(x,2)==leftpad('66',2)) or (leftpad(x,2)==leftpad('60',2)) or (between('44',x,'51',2)) or (leftpad(x,2)==leftpad('72',2)) or (leftpad(x,2)==leftpad('74',2)) or (leftpad(x,2)==leftpad('78',2)) or (leftpad(x,2)==leftpad('69',2)) or (between('08',x,'13',2)) or (leftpad(x,2)==leftpad('01',2)) or (between('15',x,'42',2)) or (between('04',x,'06',2)) or (between('53',x,'56',2))
    @classmethod
    def is_valid_TAB2020BLKSUFX1(self,x):
        """2020 TAB Block – Block Suffix 1"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (between('A',x,'Z',1))
    @classmethod
    def is_valid_TAB2020BLKSUFX2(self,x):
        """2020 TAB Block – Block Suffix 2"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (between('A',x,'Z',1))
    @classmethod
    def is_valid_TAB2020BLKTRACT(self,x):
        """2020 TAB Block – Census Tract Code"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (between('000100',x,'998999',6))
    @classmethod
    def is_valid_TABAF(self,x):
        """2010 Final Tabulation Address Filter Flag"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,1)==leftpad('1',1)) or (leftpad(x,1)==leftpad('0',1))
    @classmethod
    def is_valid_TABMS(self,x):
        """2010 Current Block Map Spot ID"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_TEA(self,x):
        """Type of Enumeration Area"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,1)==leftpad('5',1)) or (leftpad(x,1)==leftpad('4',1)) or (leftpad(x,1)==leftpad('3',1)) or (leftpad(x,1)==leftpad('1',1)) or (leftpad(x,1)==leftpad('2',1)) or (leftpad(x,1)==leftpad('6',1))
    @classmethod
    def is_valid_TLID(self,x):
        """Permanent Edge ID where this unit geocodes"""
        if x is None or x == "None" or len(x) == 0:
            return True
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return True
    @classmethod
    def is_valid_UNITSTAT(self,x):
        """Unit Status Code"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,2)==leftpad('01',2))
    @classmethod
    def is_valid_WSDESC2PR(self,x):
        """Puerto Rico Within Structure Descriptor 2"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,12)==leftpad('STE',12)) or (leftpad(x,12)==leftpad('PARC',12)) or (leftpad(x,12)==leftpad('PISO',12)) or (leftpad(x,12)==leftpad('PDA',12))
    @classmethod
    def is_valid_WSID2PR(self,x):
        """Within Structure ID 2"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_XTYP(self,x):
        """ACS x-type flag"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,1)==leftpad('9',1)) or (leftpad(x,1)==leftpad('4',1)) or (leftpad(x,1)==leftpad('3',1)) or (leftpad(x,1)==leftpad('1',1)) or (leftpad(x,1)==leftpad('5',1)) or (leftpad(x,1)==leftpad('2',1)) or (leftpad(x,1)==leftpad('0',1))

    @classmethod
    def validate_pipe_delimited(self,x):
        fields = x.split('|')
        if len(fields)!=167: return False
        if self.is_valid_ABRAF(fields[0]) == False: return False
        if self.is_valid_ACOCE(fields[1]) == False: return False
        if self.is_valid_BCUCOUNTYFP(fields[2]) == False: return False
        if self.is_valid_BCUID(fields[3]) == False: return False
        if self.is_valid_BCUSTATEFP(fields[4]) == False: return False
        if self.is_valid_BCUTRACTCE(fields[5]) == False: return False
        if self.is_valid_CARRETERA(fields[6]) == False: return False
        if self.is_valid_CENSTAT2010(fields[7]) == False: return False
        if self.is_valid_CENSTAT2020(fields[8]) == False: return False
        if self.is_valid_CENSURV(fields[9]) == False: return False
        if self.is_valid_CENSUS2010(fields[10]) == False: return False
        if self.is_valid_CENSUS2020(fields[11]) == False: return False
        if self.is_valid_CENSUSAF(fields[12]) == False: return False
        if self.is_valid_CFUFVAF(fields[13]) == False: return False
        if self.is_valid_COLLAF(fields[14]) == False: return False
        if self.is_valid_COLLUNV(fields[15]) == False: return False
        if self.is_valid_COMPLETELOCNAME(fields[16]) == False: return False
        if self.is_valid_COMPLETEMAILNAME(fields[17]) == False: return False
        if self.is_valid_CONTITLE(fields[18]) == False: return False
        if self.is_valid_COORDTYP(fields[19]) == False: return False
        if self.is_valid_CURBLK(fields[20]) == False: return False
        if self.is_valid_CURBLKCOU(fields[21]) == False: return False
        if self.is_valid_CURBLKST(fields[22]) == False: return False
        if self.is_valid_CURBLKSUFX1(fields[23]) == False: return False
        if self.is_valid_CURBLKSUFX2(fields[24]) == False: return False
        if self.is_valid_CURBLKTRACT(fields[25]) == False: return False
        if self.is_valid_CURCOUNTY(fields[26]) == False: return False
        if self.is_valid_CURSTATE(fields[27]) == False: return False
        if self.is_valid_DELPTTYPE(fields[28]) == False: return False
        if self.is_valid_DSAF(fields[29]) == False: return False
        if self.is_valid_DSFBASEALT(fields[30]) == False: return False
        if self.is_valid_DSFFALLAST(fields[31]) == False: return False
        if self.is_valid_DSFRT(fields[32]) == False: return False
        if self.is_valid_DSFSPRLAST(fields[33]) == False: return False
        if self.is_valid_ENUMAF(fields[34]) == False: return False
        if self.is_valid_ENUMAF2010(fields[35]) == False: return False
        if self.is_valid_ENUMUNV(fields[36]) == False: return False
        if self.is_valid_FACTLNAME(fields[37]) == False: return False
        if self.is_valid_GQAREACODE(fields[38]) == False: return False
        if self.is_valid_GQCONTACT(fields[39]) == False: return False
        if self.is_valid_GQCURRMAXPOP(fields[40]) == False: return False
        if self.is_valid_GQCURRSIZE(fields[41]) == False: return False
        if self.is_valid_GQEXT(fields[42]) == False: return False
        if self.is_valid_GQHUFLAG(fields[43]) == False: return False
        if self.is_valid_GQID(fields[44]) == False: return False
        if self.is_valid_GQNAME(fields[45]) == False: return False
        if self.is_valid_GQPHONE(fields[46]) == False: return False
        if self.is_valid_GQTYPCUR(fields[47]) == False: return False
        if self.is_valid_HUTYP(fields[48]) == False: return False
        if self.is_valid_INITUCMAF(fields[49]) == False: return False
        if self.is_valid_INSITE(fields[50]) == False: return False
        if self.is_valid_IOACIRAF(fields[51]) == False: return False
        if self.is_valid_IS2020DLV(fields[52]) == False: return False
        if self.is_valid_ISOLQ(fields[53]) == False: return False
        if self.is_valid_ISUCMDLV(fields[54]) == False: return False
        if self.is_valid_KMHM(fields[55]) == False: return False
        if self.is_valid_LEGACYMAFID(fields[56]) == False: return False
        if self.is_valid_LIMADEL(fields[57]) == False: return False
        if self.is_valid_LOCAPTCOMPLEX(fields[58]) == False: return False
        if self.is_valid_LOCAREANM1(fields[59]) == False: return False
        if self.is_valid_LOCAREANM2(fields[60]) == False: return False
        if self.is_valid_LOCBLDGDESC(fields[61]) == False: return False
        if self.is_valid_LOCBLDGID(fields[62]) == False: return False
        if self.is_valid_LOCDESC(fields[63]) == False: return False
        if self.is_valid_LOCHN1(fields[64]) == False: return False
        if self.is_valid_LOCHN2(fields[65]) == False: return False
        if self.is_valid_LOCHNPR(fields[66]) == False: return False
        if self.is_valid_LOCHNPRE(fields[67]) == False: return False
        if self.is_valid_LOCHNSEP(fields[68]) == False: return False
        if self.is_valid_LOCHNSUF(fields[69]) == False: return False
        if self.is_valid_LOCHNTYPE(fields[70]) == False: return False
        if self.is_valid_LOCISMAIL(fields[71]) == False: return False
        if self.is_valid_LOCNAME(fields[72]) == False: return False
        if self.is_valid_LOCPLUS4(fields[73]) == False: return False
        if self.is_valid_LOCPREDIR(fields[74]) == False: return False
        if self.is_valid_LOCPREQUAL(fields[75]) == False: return False
        if self.is_valid_LOCPRETYP(fields[76]) == False: return False
        if self.is_valid_LOCSTBLDIND(fields[77]) == False: return False
        if self.is_valid_LOCSTNMSRC(fields[78]) == False: return False
        if self.is_valid_LOCSUFDIR(fields[79]) == False: return False
        if self.is_valid_LOCSUFQUAL(fields[80]) == False: return False
        if self.is_valid_LOCSUFTYP(fields[81]) == False: return False
        if self.is_valid_LOCURB(fields[82]) == False: return False
        if self.is_valid_LOCWSDESC1(fields[83]) == False: return False
        if self.is_valid_LOCWSID1(fields[84]) == False: return False
        if self.is_valid_LOCZIP(fields[85]) == False: return False
        if self.is_valid_LOCZIPCLASS(fields[86]) == False: return False
        if self.is_valid_LUCAAF2020(fields[87]) == False: return False
        if self.is_valid_MAFCSFAIL(fields[88]) == False: return False
        if self.is_valid_MAFID(fields[89]) == False: return False
        if self.is_valid_MAFSRC(fields[90]) == False: return False
        if self.is_valid_MAILAPTCOMPLEX(fields[91]) == False: return False
        if self.is_valid_MAILAREANM1(fields[92]) == False: return False
        if self.is_valid_MAILAREANM2(fields[93]) == False: return False
        if self.is_valid_MAILBLDGDESC(fields[94]) == False: return False
        if self.is_valid_MAILBLDGID(fields[95]) == False: return False
        if self.is_valid_MAILHN1(fields[96]) == False: return False
        if self.is_valid_MAILHN2(fields[97]) == False: return False
        if self.is_valid_MAILHNPR(fields[98]) == False: return False
        if self.is_valid_MAILHNPRE(fields[99]) == False: return False
        if self.is_valid_MAILHNSEP(fields[100]) == False: return False
        if self.is_valid_MAILHNSUF(fields[101]) == False: return False
        if self.is_valid_MAILHNTYPE(fields[102]) == False: return False
        if self.is_valid_MAILNAME(fields[103]) == False: return False
        if self.is_valid_MAILPLUS4(fields[104]) == False: return False
        if self.is_valid_MAILPOBOXID(fields[105]) == False: return False
        if self.is_valid_MAILPREDIR(fields[106]) == False: return False
        if self.is_valid_MAILPREQUAL(fields[107]) == False: return False
        if self.is_valid_MAILPRETYP(fields[108]) == False: return False
        if self.is_valid_MAILRRBOXID(fields[109]) == False: return False
        if self.is_valid_MAILRRDESC(fields[110]) == False: return False
        if self.is_valid_MAILRRID(fields[111]) == False: return False
        if self.is_valid_MAILSTBLDIND(fields[112]) == False: return False
        if self.is_valid_MAILSTNMSRC(fields[113]) == False: return False
        if self.is_valid_MAILSUFDIR(fields[114]) == False: return False
        if self.is_valid_MAILSUFQUAL(fields[115]) == False: return False
        if self.is_valid_MAILSUFTYP(fields[116]) == False: return False
        if self.is_valid_MAILURB(fields[117]) == False: return False
        if self.is_valid_MAILWSDESC1(fields[118]) == False: return False
        if self.is_valid_MAILWSID1(fields[119]) == False: return False
        if self.is_valid_MAILZIP(fields[120]) == False: return False
        if self.is_valid_MAILZIPCLASS(fields[121]) == False: return False
        if self.is_valid_MSPID(fields[122]) == False: return False
        if self.is_valid_MTFCC(fields[123]) == False: return False
        if self.is_valid_NRFUAF(fields[124]) == False: return False
        if self.is_valid_NRFUUNV(fields[125]) == False: return False
        if self.is_valid_NUMUNITS(fields[126]) == False: return False
        if self.is_valid_OFLAT(fields[127]) == False: return False
        if self.is_valid_OFLON(fields[128]) == False: return False
        if self.is_valid_OID(fields[129]) == False: return False
        if self.is_valid_OIDBCU(fields[130]) == False: return False
        if self.is_valid_OIDTB(fields[131]) == False: return False
        if self.is_valid_PDCONVNEW(fields[132]) == False: return False
        if self.is_valid_PDCONVOLD(fields[133]) == False: return False
        if self.is_valid_POPDEC(fields[134]) == False: return False
        if self.is_valid_POPDEC2010(fields[135]) == False: return False
        if self.is_valid_POPDEC2020(fields[136]) == False: return False
        if self.is_valid_POSTPLUS4(fields[137]) == False: return False
        if self.is_valid_POSTZIP(fields[138]) == False: return False
        if self.is_valid_POSTZIPCLASS(fields[139]) == False: return False
        if self.is_valid_RAMAL(fields[140]) == False: return False
        if self.is_valid_RESSTAT(fields[141]) == False: return False
        if self.is_valid_SECCION(fields[142]) == False: return False
        if self.is_valid_SIDE(fields[143]) == False: return False
        if self.is_valid_SUPNRFUAF(fields[144]) == False: return False
        if self.is_valid_SUPNRFUUNV(fields[145]) == False: return False
        if self.is_valid_SURVMAFID(fields[146]) == False: return False
        if self.is_valid_TAB2010BLK(fields[147]) == False: return False
        if self.is_valid_TAB2010BLKCOU(fields[148]) == False: return False
        if self.is_valid_TAB2010BLKST(fields[149]) == False: return False
        if self.is_valid_TAB2010BLKSUFX1(fields[150]) == False: return False
        if self.is_valid_TAB2010BLKSUFX2(fields[151]) == False: return False
        if self.is_valid_TAB2010BLKTRACT(fields[152]) == False: return False
        if self.is_valid_TAB2020BLK(fields[153]) == False: return False
        if self.is_valid_TAB2020BLKCOU(fields[154]) == False: return False
        if self.is_valid_TAB2020BLKST(fields[155]) == False: return False
        if self.is_valid_TAB2020BLKSUFX1(fields[156]) == False: return False
        if self.is_valid_TAB2020BLKSUFX2(fields[157]) == False: return False
        if self.is_valid_TAB2020BLKTRACT(fields[158]) == False: return False
        if self.is_valid_TABAF(fields[159]) == False: return False
        if self.is_valid_TABMS(fields[160]) == False: return False
        if self.is_valid_TEA(fields[161]) == False: return False
        if self.is_valid_TLID(fields[162]) == False: return False
        if self.is_valid_UNITSTAT(fields[163]) == False: return False
        if self.is_valid_WSDESC2PR(fields[164]) == False: return False
        if self.is_valid_WSID2PR(fields[165]) == False: return False
        if self.is_valid_XTYP(fields[166]) == False: return False
        return True

class E:
    __slots__ = ['ABRAF', 'ACOCE', 'BCUCOUNTYFP', 'BCUID', 'BCUSTATEFP', 'BCUTRACTCE', 'CARRETERA', 'CENSTAT2010', 'CENSTAT2020', 'CENSURV', 'CENSUS2010', 'CENSUS2020', 'CENSUSAF', 'CFUFVAF', 'COLLAF', 'COLLUNV', 'COMPLETELOCNAME', 'COMPLETEMAILNAME', 'CONTITLE', 'COORDTYP', 'CURBLK', 'CURBLKCOU', 'CURBLKST', 'CURBLKSUFX1', 'CURBLKSUFX2', 'CURBLKTRACT', 'CURCOUNTY', 'CURSTATE', 'DELPTTYPE', 'DSAF', 'DSFBASEALT', 'DSFFALLAST', 'DSFRT', 'DSFSPRLAST', 'ENUMAF', 'ENUMAF2010', 'ENUMUNV', 'FACTLNAME', 'GQAREACODE', 'GQCONTACT', 'GQCURRMAXPOP', 'GQCURRSIZE', 'GQEXT', 'GQHUFLAG', 'GQID', 'GQNAME', 'GQPHONE', 'GQTYPCUR', 'HUTYP', 'INITUCMAF', 'INSITE', 'IOACIRAF', 'IS2020DLV', 'ISOLQ', 'ISUCMDLV', 'KMHM', 'LEGACYMAFID', 'LIMADEL', 'LOCAPTCOMPLEX', 'LOCAREANM1', 'LOCAREANM2', 'LOCBLDGDESC', 'LOCBLDGID', 'LOCDESC', 'LOCHN1', 'LOCHN2', 'LOCHNPR', 'LOCHNPRE', 'LOCHNSEP', 'LOCHNSUF', 'LOCHNTYPE', 'LOCISMAIL', 'LOCNAME', 'LOCPLUS4', 'LOCPREDIR', 'LOCPREQUAL', 'LOCPRETYP', 'LOCSTBLDIND', 'LOCSTNMSRC', 'LOCSUFDIR', 'LOCSUFQUAL', 'LOCSUFTYP', 'LOCURB', 'LOCWSDESC1', 'LOCWSID1', 'LOCZIP', 'LOCZIPCLASS', 'LUCAAF2020', 'MAFCSFAIL', 'MAFID', 'MAFSRC', 'MAILAPTCOMPLEX', 'MAILAREANM1', 'MAILAREANM2', 'MAILBLDGDESC', 'MAILBLDGID', 'MAILHN1', 'MAILHN2', 'MAILHNPR', 'MAILHNPRE', 'MAILHNSEP', 'MAILHNSUF', 'MAILHNTYPE', 'MAILNAME', 'MAILPLUS4', 'MAILPOBOXID', 'MAILPREDIR', 'MAILPREQUAL', 'MAILPRETYP', 'MAILRRBOXID', 'MAILRRDESC', 'MAILRRID', 'MAILSTBLDIND', 'MAILSTNMSRC', 'MAILSUFDIR', 'MAILSUFQUAL', 'MAILSUFTYP', 'MAILURB', 'MAILWSDESC1', 'MAILWSID1', 'MAILZIP', 'MAILZIPCLASS', 'MSPID', 'MTFCC', 'NRFUAF', 'NRFUUNV', 'NUMUNITS', 'OFLAT', 'OFLON', 'OID', 'OIDBCU', 'OIDTB', 'PDCONVNEW', 'PDCONVOLD', 'POPDEC', 'POPDEC2010', 'POPDEC2020', 'POSTPLUS4', 'POSTZIP', 'POSTZIPCLASS', 'RAMAL', 'RESSTAT', 'SECCION', 'SIDE', 'SUPNRFUAF', 'SUPNRFUUNV', 'SURVMAFID', 'TAB2010BLK', 'TAB2010BLKCOU', 'TAB2010BLKST', 'TAB2010BLKSUFX1', 'TAB2010BLKSUFX2', 'TAB2010BLKTRACT', 'TAB2020BLK', 'TAB2020BLKCOU', 'TAB2020BLKST', 'TAB2020BLKSUFX1', 'TAB2020BLKSUFX2', 'TAB2020BLKTRACT', 'TABAF', 'TABMS', 'TEA', 'TLID', 'UNITSTAT', 'WSDESC2PR', 'WSID2PR', 'XTYP']
    def __repr__(self):
        return 'E<ABRAF:{},ACOCE:{},BCUCOUNTYFP:{},BCUID:{},BCUSTATEFP:{},BCUTRACTCE:{},CARRETERA:{},CENSTAT2010:{},CENSTAT2020:{},CENSURV:{},CENSUS2010:{},CENSUS2020:{},CENSUSAF:{},CFUFVAF:{},COLLAF:{},COLLUNV:{},COMPLETELOCNAME:{},COMPLETEMAILNAME:{},CONTITLE:{},COORDTYP:{},CURBLK:{},CURBLKCOU:{},CURBLKST:{},CURBLKSUFX1:{},CURBLKSUFX2:{},CURBLKTRACT:{},CURCOUNTY:{},CURSTATE:{},DELPTTYPE:{},DSAF:{},DSFBASEALT:{},DSFFALLAST:{},DSFRT:{},DSFSPRLAST:{},ENUMAF:{},ENUMAF2010:{},ENUMUNV:{},FACTLNAME:{},GQAREACODE:{},GQCONTACT:{},GQCURRMAXPOP:{},GQCURRSIZE:{},GQEXT:{},GQHUFLAG:{},GQID:{},GQNAME:{},GQPHONE:{},GQTYPCUR:{},HUTYP:{},INITUCMAF:{},INSITE:{},IOACIRAF:{},IS2020DLV:{},ISOLQ:{},ISUCMDLV:{},KMHM:{},LEGACYMAFID:{},LIMADEL:{},LOCAPTCOMPLEX:{},LOCAREANM1:{},LOCAREANM2:{},LOCBLDGDESC:{},LOCBLDGID:{},LOCDESC:{},LOCHN1:{},LOCHN2:{},LOCHNPR:{},LOCHNPRE:{},LOCHNSEP:{},LOCHNSUF:{},LOCHNTYPE:{},LOCISMAIL:{},LOCNAME:{},LOCPLUS4:{},LOCPREDIR:{},LOCPREQUAL:{},LOCPRETYP:{},LOCSTBLDIND:{},LOCSTNMSRC:{},LOCSUFDIR:{},LOCSUFQUAL:{},LOCSUFTYP:{},LOCURB:{},LOCWSDESC1:{},LOCWSID1:{},LOCZIP:{},LOCZIPCLASS:{},LUCAAF2020:{},MAFCSFAIL:{},MAFID:{},MAFSRC:{},MAILAPTCOMPLEX:{},MAILAREANM1:{},MAILAREANM2:{},MAILBLDGDESC:{},MAILBLDGID:{},MAILHN1:{},MAILHN2:{},MAILHNPR:{},MAILHNPRE:{},MAILHNSEP:{},MAILHNSUF:{},MAILHNTYPE:{},MAILNAME:{},MAILPLUS4:{},MAILPOBOXID:{},MAILPREDIR:{},MAILPREQUAL:{},MAILPRETYP:{},MAILRRBOXID:{},MAILRRDESC:{},MAILRRID:{},MAILSTBLDIND:{},MAILSTNMSRC:{},MAILSUFDIR:{},MAILSUFQUAL:{},MAILSUFTYP:{},MAILURB:{},MAILWSDESC1:{},MAILWSID1:{},MAILZIP:{},MAILZIPCLASS:{},MSPID:{},MTFCC:{},NRFUAF:{},NRFUUNV:{},NUMUNITS:{},OFLAT:{},OFLON:{},OID:{},OIDBCU:{},OIDTB:{},PDCONVNEW:{},PDCONVOLD:{},POPDEC:{},POPDEC2010:{},POPDEC2020:{},POSTPLUS4:{},POSTZIP:{},POSTZIPCLASS:{},RAMAL:{},RESSTAT:{},SECCION:{},SIDE:{},SUPNRFUAF:{},SUPNRFUUNV:{},SURVMAFID:{},TAB2010BLK:{},TAB2010BLKCOU:{},TAB2010BLKST:{},TAB2010BLKSUFX1:{},TAB2010BLKSUFX2:{},TAB2010BLKTRACT:{},TAB2020BLK:{},TAB2020BLKCOU:{},TAB2020BLKST:{},TAB2020BLKSUFX1:{},TAB2020BLKSUFX2:{},TAB2020BLKTRACT:{},TABAF:{},TABMS:{},TEA:{},TLID:{},UNITSTAT:{},WSDESC2PR:{},WSID2PR:{},XTYP:{}>'.format(self.ABRAF,self.ACOCE,self.BCUCOUNTYFP,self.BCUID,self.BCUSTATEFP,self.BCUTRACTCE,self.CARRETERA,self.CENSTAT2010,self.CENSTAT2020,self.CENSURV,self.CENSUS2010,self.CENSUS2020,self.CENSUSAF,self.CFUFVAF,self.COLLAF,self.COLLUNV,self.COMPLETELOCNAME,self.COMPLETEMAILNAME,self.CONTITLE,self.COORDTYP,self.CURBLK,self.CURBLKCOU,self.CURBLKST,self.CURBLKSUFX1,self.CURBLKSUFX2,self.CURBLKTRACT,self.CURCOUNTY,self.CURSTATE,self.DELPTTYPE,self.DSAF,self.DSFBASEALT,self.DSFFALLAST,self.DSFRT,self.DSFSPRLAST,self.ENUMAF,self.ENUMAF2010,self.ENUMUNV,self.FACTLNAME,self.GQAREACODE,self.GQCONTACT,self.GQCURRMAXPOP,self.GQCURRSIZE,self.GQEXT,self.GQHUFLAG,self.GQID,self.GQNAME,self.GQPHONE,self.GQTYPCUR,self.HUTYP,self.INITUCMAF,self.INSITE,self.IOACIRAF,self.IS2020DLV,self.ISOLQ,self.ISUCMDLV,self.KMHM,self.LEGACYMAFID,self.LIMADEL,self.LOCAPTCOMPLEX,self.LOCAREANM1,self.LOCAREANM2,self.LOCBLDGDESC,self.LOCBLDGID,self.LOCDESC,self.LOCHN1,self.LOCHN2,self.LOCHNPR,self.LOCHNPRE,self.LOCHNSEP,self.LOCHNSUF,self.LOCHNTYPE,self.LOCISMAIL,self.LOCNAME,self.LOCPLUS4,self.LOCPREDIR,self.LOCPREQUAL,self.LOCPRETYP,self.LOCSTBLDIND,self.LOCSTNMSRC,self.LOCSUFDIR,self.LOCSUFQUAL,self.LOCSUFTYP,self.LOCURB,self.LOCWSDESC1,self.LOCWSID1,self.LOCZIP,self.LOCZIPCLASS,self.LUCAAF2020,self.MAFCSFAIL,self.MAFID,self.MAFSRC,self.MAILAPTCOMPLEX,self.MAILAREANM1,self.MAILAREANM2,self.MAILBLDGDESC,self.MAILBLDGID,self.MAILHN1,self.MAILHN2,self.MAILHNPR,self.MAILHNPRE,self.MAILHNSEP,self.MAILHNSUF,self.MAILHNTYPE,self.MAILNAME,self.MAILPLUS4,self.MAILPOBOXID,self.MAILPREDIR,self.MAILPREQUAL,self.MAILPRETYP,self.MAILRRBOXID,self.MAILRRDESC,self.MAILRRID,self.MAILSTBLDIND,self.MAILSTNMSRC,self.MAILSUFDIR,self.MAILSUFQUAL,self.MAILSUFTYP,self.MAILURB,self.MAILWSDESC1,self.MAILWSID1,self.MAILZIP,self.MAILZIPCLASS,self.MSPID,self.MTFCC,self.NRFUAF,self.NRFUUNV,self.NUMUNITS,self.OFLAT,self.OFLON,self.OID,self.OIDBCU,self.OIDTB,self.PDCONVNEW,self.PDCONVOLD,self.POPDEC,self.POPDEC2010,self.POPDEC2020,self.POSTPLUS4,self.POSTZIP,self.POSTZIPCLASS,self.RAMAL,self.RESSTAT,self.SECCION,self.SIDE,self.SUPNRFUAF,self.SUPNRFUUNV,self.SURVMAFID,self.TAB2010BLK,self.TAB2010BLKCOU,self.TAB2010BLKST,self.TAB2010BLKSUFX1,self.TAB2010BLKSUFX2,self.TAB2010BLKTRACT,self.TAB2020BLK,self.TAB2020BLKCOU,self.TAB2020BLKST,self.TAB2020BLKSUFX1,self.TAB2020BLKSUFX2,self.TAB2020BLKTRACT,self.TABAF,self.TABMS,self.TEA,self.TLID,self.UNITSTAT,self.WSDESC2PR,self.WSID2PR,self.XTYP)
    def __init__(self,line=None):
        if line:
            if '|' in line:
                self.parse_pipe_delimited(line)
            else:
                self.parse_column_specified(line)
    @classmethod
    def name(self):
        return 'E'

    def parse_pipe_delimited(self,line):
        fields = line.split('|')
        if len(fields)!=167:
            raise ValueError(f'expected 167 fields, found {len(fields)}')
        self.ABRAF           = fields[0]  # Active Block Resolution Address Filter Flag
        self.ACOCE           = fields[1]  # Area Census Office
        self.BCUCOUNTYFP     = fields[2]  # FIPS County Code
        self.BCUID           = fields[3]  # Basic Collection Unit Identification Code
        self.BCUSTATEFP      = fields[4]  # FIPS State Code
        self.BCUTRACTCE      = fields[5]  # Census Tract Code
        self.CARRETERA       = fields[6]  # Carretera
        self.CENSTAT2010     = fields[7]  # Official Census 2010 enumeration status of this MAFID, as obtained from the Census 2010 Decennial Master Address File (DMAF)
        self.CENSTAT2020     = fields[8]  # Official Census 2020 enumeration status
        self.CENSURV         = fields[9]  # Survivor of a Census Address Flag
        self.CENSUS2010      = fields[10]  # Census 2010 Unit Flag
        self.CENSUS2020      = fields[11]  # Census 2020 Unit Flag
        self.CENSUSAF        = fields[12]  # Decennial Listing Filter Flag
        self.CFUFVAF         = fields[13]  # 2010 Coverage Followup/Field Verification Address Filter Flag
        self.COLLAF          = fields[14]  # 2010 Final Collection Address Filter Flag
        self.COLLUNV         = fields[15]  # Final Collection Universe Flag
        self.COMPLETELOCNAME = fields[16]  # The Complete Location Display Name
        self.COMPLETEMAILNAME = fields[17]  # The Complete Mailing Display Name
        self.CONTITLE        = fields[18]  # Title of Contact Person
        self.COORDTYP        = fields[19]  # Coordinate Collection Type
        self.CURBLK          = fields[20]  # Current Block – Census Block Number
        self.CURBLKCOU       = fields[21]  # Current Block – FIPS County Code
        self.CURBLKST        = fields[22]  # Current Block – FIPS State Code
        self.CURBLKSUFX1     = fields[23]  # Current Block – Block Suffix 1
        self.CURBLKSUFX2     = fields[24]  # Current Block – Block Suffix 2
        self.CURBLKTRACT     = fields[25]  # Current Block – Census Tract Code
        self.CURCOUNTY       = fields[26]  # Current FIPS County Code
        self.CURSTATE        = fields[27]  # Current FIPS State Code
        self.DELPTTYPE       = fields[28]  # DSF Delivery Point Type
        self.DSAF            = fields[29]  # Delivery Specific Address Flag
        self.DSFBASEALT      = fields[30]  # Alternate/Base Flag
        self.DSFFALLAST      = fields[31]  # Most Recent Fall DSF Value
        self.DSFRT           = fields[32]  # DSF Record Type
        self.DSFSPRLAST      = fields[33]  # Most Recent Spring DSF Value
        self.ENUMAF          = fields[34]  # Current Enumeration Universe Address Filter Flag
        self.ENUMAF2010      = fields[35]  # 2010 Enumeration Universe Address Filter Flag
        self.ENUMUNV         = fields[36]  # Enumeration Universe Flag
        self.FACTLNAME       = fields[37]  # Facility Name for Group Quarters/Transitory Location Name
        self.GQAREACODE      = fields[38]  # GQ Area Code
        self.GQCONTACT       = fields[39]  # GQ Contact
        self.GQCURRMAXPOP    = fields[40]  # Maximum number of persons at the GQ
        self.GQCURRSIZE      = fields[41]  # A count at the GQ from the last ACS or Current Surveys visit
        self.GQEXT           = fields[42]  # GQ Phone Number Extension
        self.GQHUFLAG        = fields[43]  # Group Quarters/HU Flag
        self.GQID            = fields[44]  # Group Quarters ID
        self.GQNAME          = fields[45]  # Group Quarters Name
        self.GQPHONE         = fields[46]  # GQ Phone Number
        self.GQTYPCUR        = fields[47]  # Current Group Quarters Type code
        self.HUTYP           = fields[48]  # Housing unit type
        self.INITUCMAF       = fields[49]  # Initial UC & M Universe Address Filter Flag
        self.INSITE          = fields[50]  # Test Site Flag
        self.IOACIRAF        = fields[51]  # In-Office Canvassing Interactive Review Address Filter Flag
        self.IS2020DLV       = fields[52]  # 2020 Census Deliverable Flag
        self.ISOLQ           = fields[53]  # Military Address Flag
        self.ISUCMDLV        = fields[54]  # 2010 UC&M Deliverable Flag
        self.KMHM            = fields[55]  # Kilometer/Hectometer Marker
        self.LEGACYMAFID     = fields[56]  # Field that stores the Legacy Within-County MAFID
        self.LIMADEL         = fields[57]  # LIMA Delivery Flag
        self.LOCAPTCOMPLEX   = fields[58]  # Location Address – Name of an apartment Complex, subdivision, named development, or mobile park
        self.LOCAREANM1      = fields[59]  # Location Area Name Part 1 (Puerto Rico-only)
        self.LOCAREANM2      = fields[60]  # Location Area Name Part 2 (Puerto Rico-only)
        self.LOCBLDGDESC     = fields[61]  # Location Address Building Descriptor
        self.LOCBLDGID       = fields[62]  # Location Address Building Identifier
        self.LOCDESC         = fields[63]  # Location Description
        self.LOCHN1          = fields[64]  # Location Address First Part of House Number
        self.LOCHN2          = fields[65]  # Location address Second Part of House Number
        self.LOCHNPR         = fields[66]  # Location Address – House Number (Puerto Rico)
        self.LOCHNPRE        = fields[67]  # Location Address House Number Prefix
        self.LOCHNSEP        = fields[68]  # Location Address House Number Separator
        self.LOCHNSUF        = fields[69]  # Location Address House Number Suffix
        self.LOCHNTYPE       = fields[70]  # Location Address – House Number/Building Number Type
        self.LOCISMAIL       = fields[71]  # Location Address is also a Current DSF Address
        self.LOCNAME         = fields[72]  # Location Address – Base Street Name
        self.LOCPLUS4        = fields[73]  # Location Address ZIP+4 Code
        self.LOCPREDIR       = fields[74]  # Location Address – Street Name Prefix Direction
        self.LOCPREQUAL      = fields[75]  # Location Address – Street Name Prefix Qualifier
        self.LOCPRETYP       = fields[76]  # Location Address – Street Name Prefix Type
        self.LOCSTBLDIND     = fields[77]  # Location Address – Street/Building Indicator
        self.LOCSTNMSRC      = fields[78]  # Location Address – Street Name Source
        self.LOCSUFDIR       = fields[79]  # Location Address – Street Name Suffix Direction
        self.LOCSUFQUAL      = fields[80]  # Location Address – Street Name Suffix Qualifier
        self.LOCSUFTYP       = fields[81]  # Location Address – Street Name Suffix Type
        self.LOCURB          = fields[82]  # Location Address Urbanization (Puerto Rico)
        self.LOCWSDESC1      = fields[83]  # Location Address Within Structure Descriptor 1
        self.LOCWSID1        = fields[84]  # Location Address Within Structure ID 1
        self.LOCZIP          = fields[85]  # Location Address 5-digit ZIP Code
        self.LOCZIPCLASS     = fields[86]  # Location Address – ZIP Code Classification Code
        self.LUCAAF2020      = fields[87]  # LUCA Address Filter Flag for 2020
        self.MAFCSFAIL       = fields[88]  # MAF Coverage Study Fail Flag
        self.MAFID           = fields[89]  # Permanent MAFUNIT ID
        self.MAFSRC          = fields[90]  # Original MAF Source Code
        self.MAILAPTCOMPLEX  = fields[91]  # Mailing Address – Name of an apartment complex, subdivision , named development, or mobile park
        self.MAILAREANM1     = fields[92]  # “Barrio”, “Barriada”,”Sector”, “Parcela”, “Communidad” (Puerto Rico)
        self.MAILAREANM2     = fields[93]  # “Barrio”, “Barriada”,”Sector”, “Parcela”, “Communidad” (Puerto Rico)
        self.MAILBLDGDESC    = fields[94]  # Mailing Address – Building Descriptor
        self.MAILBLDGID      = fields[95]  # Mailing Address – Building Identifier
        self.MAILHN1         = fields[96]  # Mailing Address First Part of House Number
        self.MAILHN2         = fields[97]  # Mailing Address Second Part of House Number
        self.MAILHNPR        = fields[98]  # Mailing Address – House Number (Puerto Rico)
        self.MAILHNPRE       = fields[99]  # Mailing Address House Number Prefix
        self.MAILHNSEP       = fields[100]  # Mailing Address House Number Separator
        self.MAILHNSUF       = fields[101]  # Mailing Address House Number Suffix
        self.MAILHNTYPE      = fields[102]  # Mailing Address House Number Type
        self.MAILNAME        = fields[103]  # Mailing Address – Base Street Name
        self.MAILPLUS4       = fields[104]  # Mailing Address ZIP+4 Code
        self.MAILPOBOXID     = fields[105]  # Mailing Address – Post Office Box ID
        self.MAILPREDIR      = fields[106]  # Mailing Address – Street Name Prefix Direction
        self.MAILPREQUAL     = fields[107]  # Mailing Address – Street Name Prefix Qualifier
        self.MAILPRETYP      = fields[108]  # Mailing Address – Street Name Prefix Type
        self.MAILRRBOXID     = fields[109]  # Mailing Address – Rural Route Box ID
        self.MAILRRDESC      = fields[110]  # Mailing Address – Rural Route Descriptor
        self.MAILRRID        = fields[111]  # Mailing Address – Rural Route ID
        self.MAILSTBLDIND    = fields[112]  # Mailing Address – Street/Building Indicator
        self.MAILSTNMSRC     = fields[113]  # Mailing Address – Street Name Source
        self.MAILSUFDIR      = fields[114]  # Mailing Address – Street Name Suffix Direction
        self.MAILSUFQUAL     = fields[115]  # Mailing Address – Street Name Suffix Qualifier
        self.MAILSUFTYP      = fields[116]  # Mailing Address – Street Name Suffix Type
        self.MAILURB         = fields[117]  # Mailing Address – Urbanization (Puerto Rico)
        self.MAILWSDESC1     = fields[118]  # Mailing Address – Within Structure Descriptor
        self.MAILWSID1       = fields[119]  # Mailing Address – Within Structure ID 1
        self.MAILZIP         = fields[120]  # Mailing Address 5-digit ZIP Code
        self.MAILZIPCLASS    = fields[121]  # Mailing Address – ZIP Code Classification Code
        self.MSPID           = fields[122]  # Map Spot Identification Code
        self.MTFCC           = fields[123]  # MAF TIGER Feature Class Code
        self.NRFUAF          = fields[124]  # Nonresponse Followup Address Filter Flag
        self.NRFUUNV         = fields[125]  # Nonresponse Followup Universe Flag
        self.NUMUNITS        = fields[126]  # Number of units at this BSA
        self.OFLAT           = fields[127]  # Official Coordinates – Latitude
        self.OFLON           = fields[128]  # Official Coordinates – Longitude
        self.OID             = fields[129]  # MAF Unit Object Identification Code
        self.OIDBCU          = fields[130]  # Basic Collection Unit Object Identification Code
        self.OIDTB           = fields[131]  # PD Tabulation Block OID
        self.PDCONVNEW       = fields[132]  # LACS Conversion Flag (New Unit)
        self.PDCONVOLD       = fields[133]  # LACS Conversion Flag (Old Unit)
        self.POPDEC          = fields[134]  # Census 2000 Population
        self.POPDEC2010      = fields[135]  # Census 2010 Population
        self.POPDEC2020      = fields[136]  # Census 2020 Population
        self.POSTPLUS4       = fields[137]  # USPS – ZIP+4 Code
        self.POSTZIP         = fields[138]  # USPS – 5-digit ZIP Code
        self.POSTZIPCLASS    = fields[139]  # USPS – ZIP Code Classification Code
        self.RAMAL           = fields[140]  # Ramal
        self.RESSTAT         = fields[141]  # Residential Status Flag
        self.SECCION         = fields[142]  # Seccion
        self.SIDE            = fields[143]  # Side Indicator Flag
        self.SUPNRFUAF       = fields[144]  # 2010 Supplemental Nonresponse Followup Address Filter Flag
        self.SUPNRFUUNV      = fields[145]  # Supplemental NRFU Universe Flag
        self.SURVMAFID       = fields[146]  # Surviving MAFID
        self.TAB2010BLK      = fields[147]  # 2010 TAB Block – Census Block Number
        self.TAB2010BLKCOU   = fields[148]  # 2010 TAB Block – FIPS County Code
        self.TAB2010BLKST    = fields[149]  # 2010 TAB Block – FIPS State Code
        self.TAB2010BLKSUFX1 = fields[150]  # 2010 TAB Block – Block Suffix 1
        self.TAB2010BLKSUFX2 = fields[151]  # 2010 TAB Block – Block Suffix 2
        self.TAB2010BLKTRACT = fields[152]  # 2010 TAB Block – Census Tract Code
        self.TAB2020BLK      = fields[153]  # 2020 TAB Block – Census Block Number
        self.TAB2020BLKCOU   = fields[154]  # 2020 TAB Block – FIPS County Code
        self.TAB2020BLKST    = fields[155]  # 2020 TAB Block – FIPS State Code
        self.TAB2020BLKSUFX1 = fields[156]  # 2020 TAB Block – Block Suffix 1
        self.TAB2020BLKSUFX2 = fields[157]  # 2020 TAB Block – Block Suffix 2
        self.TAB2020BLKTRACT = fields[158]  # 2020 TAB Block – Census Tract Code
        self.TABAF           = fields[159]  # 2010 Final Tabulation Address Filter Flag
        self.TABMS           = fields[160]  # 2010 Current Block Map Spot ID
        self.TEA             = fields[161]  # Type of Enumeration Area
        self.TLID            = fields[162]  # Permanent Edge ID where this unit geocodes
        self.UNITSTAT        = fields[163]  # Unit Status Code
        self.WSDESC2PR       = fields[164]  # Puerto Rico Within Structure Descriptor 2
        self.WSID2PR         = fields[165]  # Within Structure ID 2
        self.XTYP            = fields[166]  # ACS x-type flag

    def parse_column_specified(self,line):
        self.ABRAF           = line[0:1] # Active Block Resolution Address Filter Flag
        self.ACOCE           = line[1:5] # Area Census Office
        self.BCUCOUNTYFP     = line[2:5] # FIPS County Code
        self.BCUID           = line[3:11] # Basic Collection Unit Identification Code
        self.BCUSTATEFP      = line[4:6] # FIPS State Code
        self.BCUTRACTCE      = line[5:11] # Census Tract Code
        self.CARRETERA       = line[6:26] # Carretera
        self.CENSTAT2010     = line[7:8] # Official Census 2010 enumeration status of this MAFID, as obtained from the Census 2010 Decennial Master Address File (DMAF)
        self.CENSTAT2020     = line[8:10] # Official Census 2020 enumeration status
        self.CENSURV         = line[9:10] # Survivor of a Census Address Flag
        self.CENSUS2010      = line[10:11] # Census 2010 Unit Flag
        self.CENSUS2020      = line[11:12] # Census 2020 Unit Flag
        self.CENSUSAF        = line[12:13] # Decennial Listing Filter Flag
        self.CFUFVAF         = line[13:14] # 2010 Coverage Followup/Field Verification Address Filter Flag
        self.COLLAF          = line[14:15] # 2010 Final Collection Address Filter Flag
        self.COLLUNV         = line[15:16] # Final Collection Universe Flag
        self.COMPLETELOCNAME = line[16:116] # The Complete Location Display Name
        self.COMPLETEMAILNAME = line[17:117] # The Complete Mailing Display Name
        self.CONTITLE        = line[18:68] # Title of Contact Person
        self.COORDTYP        = line[19:20] # Coordinate Collection Type
        self.CURBLK          = line[20:24] # Current Block – Census Block Number
        self.CURBLKCOU       = line[21:24] # Current Block – FIPS County Code
        self.CURBLKST        = line[22:24] # Current Block – FIPS State Code
        self.CURBLKSUFX1     = line[23:24] # Current Block – Block Suffix 1
        self.CURBLKSUFX2     = line[24:25] # Current Block – Block Suffix 2
        self.CURBLKTRACT     = line[25:31] # Current Block – Census Tract Code
        self.CURCOUNTY       = line[26:29] # Current FIPS County Code
        self.CURSTATE        = line[27:29] # Current FIPS State Code
        self.DELPTTYPE       = line[28:29] # DSF Delivery Point Type
        self.DSAF            = line[29:30] # Delivery Specific Address Flag
        self.DSFBASEALT      = line[30:31] # Alternate/Base Flag
        self.DSFFALLAST      = line[31:32] # Most Recent Fall DSF Value
        self.DSFRT           = line[32:33] # DSF Record Type
        self.DSFSPRLAST      = line[33:34] # Most Recent Spring DSF Value
        self.ENUMAF          = line[34:35] # Current Enumeration Universe Address Filter Flag
        self.ENUMAF2010      = line[35:36] # 2010 Enumeration Universe Address Filter Flag
        self.ENUMUNV         = line[36:37] # Enumeration Universe Flag
        self.FACTLNAME       = line[37:137] # Facility Name for Group Quarters/Transitory Location Name
        self.GQAREACODE      = line[38:41] # GQ Area Code
        self.GQCONTACT       = line[39:74] # GQ Contact
        self.GQCURRMAXPOP    = line[40:45] # Maximum number of persons at the GQ
        self.GQCURRSIZE      = line[41:46] # A count at the GQ from the last ACS or Current Surveys visit
        self.GQEXT           = line[42:50] # GQ Phone Number Extension
        self.GQHUFLAG        = line[43:44] # Group Quarters/HU Flag
        self.GQID            = line[44:48] # Group Quarters ID
        self.GQNAME          = line[45:145] # Group Quarters Name
        self.GQPHONE         = line[46:54] # GQ Phone Number
        self.GQTYPCUR        = line[47:50] # Current Group Quarters Type code
        self.HUTYP           = line[48:49] # Housing unit type
        self.INITUCMAF       = line[49:50] # Initial UC & M Universe Address Filter Flag
        self.INSITE          = line[50:51] # Test Site Flag
        self.IOACIRAF        = line[51:52] # In-Office Canvassing Interactive Review Address Filter Flag
        self.IS2020DLV       = line[52:53] # 2020 Census Deliverable Flag
        self.ISOLQ           = line[53:54] # Military Address Flag
        self.ISUCMDLV        = line[54:55] # 2010 UC&M Deliverable Flag
        self.KMHM            = line[55:67] # Kilometer/Hectometer Marker
        self.LEGACYMAFID     = line[56:68] # Field that stores the Legacy Within-County MAFID
        self.LIMADEL         = line[57:58] # LIMA Delivery Flag
        self.LOCAPTCOMPLEX   = line[58:158] # Location Address – Name of an apartment Complex, subdivision, named development, or mobile park
        self.LOCAREANM1      = line[59:109] # Location Area Name Part 1 (Puerto Rico-only)
        self.LOCAREANM2      = line[60:110] # Location Area Name Part 2 (Puerto Rico-only)
        self.LOCBLDGDESC     = line[61:71] # Location Address Building Descriptor
        self.LOCBLDGID       = line[62:74] # Location Address Building Identifier
        self.LOCDESC         = line[63:163] # Location Description
        self.LOCHN1          = line[64:76] # Location Address First Part of House Number
        self.LOCHN2          = line[65:77] # Location address Second Part of House Number
        self.LOCHNPR         = line[66:86] # Location Address – House Number (Puerto Rico)
        self.LOCHNPRE        = line[67:69] # Location Address House Number Prefix
        self.LOCHNSEP        = line[68:70] # Location Address House Number Separator
        self.LOCHNSUF        = line[69:72] # Location Address House Number Suffix
        self.LOCHNTYPE       = line[70:71] # Location Address – House Number/Building Number Type
        self.LOCISMAIL       = line[71:72] # Location Address is also a Current DSF Address
        self.LOCNAME         = line[72:172] # Location Address – Base Street Name
        self.LOCPLUS4        = line[73:77] # Location Address ZIP+4 Code
        self.LOCPREDIR       = line[74:76] # Location Address – Street Name Prefix Direction
        self.LOCPREQUAL      = line[75:78] # Location Address – Street Name Prefix Qualifier
        self.LOCPRETYP       = line[76:90] # Location Address – Street Name Prefix Type
        self.LOCSTBLDIND     = line[77:78] # Location Address – Street/Building Indicator
        self.LOCSTNMSRC      = line[78:79] # Location Address – Street Name Source
        self.LOCSUFDIR       = line[79:81] # Location Address – Street Name Suffix Direction
        self.LOCSUFQUAL      = line[80:83] # Location Address – Street Name Suffix Qualifier
        self.LOCSUFTYP       = line[81:95] # Location Address – Street Name Suffix Type
        self.LOCURB          = line[82:132] # Location Address Urbanization (Puerto Rico)
        self.LOCWSDESC1      = line[83:95] # Location Address Within Structure Descriptor 1
        self.LOCWSID1        = line[84:124] # Location Address Within Structure ID 1
        self.LOCZIP          = line[85:90] # Location Address 5-digit ZIP Code
        self.LOCZIPCLASS     = line[86:87] # Location Address – ZIP Code Classification Code
        self.LUCAAF2020      = line[87:88] # LUCA Address Filter Flag for 2020
        self.MAFCSFAIL       = line[88:89] # MAF Coverage Study Fail Flag
        self.MAFID           = line[89:98] # Permanent MAFUNIT ID
        self.MAFSRC          = line[90:93] # Original MAF Source Code
        self.MAILAPTCOMPLEX  = line[91:191] # Mailing Address – Name of an apartment complex, subdivision , named development, or mobile park
        self.MAILAREANM1     = line[92:142] # “Barrio”, “Barriada”,”Sector”, “Parcela”, “Communidad” (Puerto Rico)
        self.MAILAREANM2     = line[93:143] # “Barrio”, “Barriada”,”Sector”, “Parcela”, “Communidad” (Puerto Rico)
        self.MAILBLDGDESC    = line[94:104] # Mailing Address – Building Descriptor
        self.MAILBLDGID      = line[95:107] # Mailing Address – Building Identifier
        self.MAILHN1         = line[96:108] # Mailing Address First Part of House Number
        self.MAILHN2         = line[97:109] # Mailing Address Second Part of House Number
        self.MAILHNPR        = line[98:118] # Mailing Address – House Number (Puerto Rico)
        self.MAILHNPRE       = line[99:101] # Mailing Address House Number Prefix
        self.MAILHNSEP       = line[100:102] # Mailing Address House Number Separator
        self.MAILHNSUF       = line[101:104] # Mailing Address House Number Suffix
        self.MAILHNTYPE      = line[102:103] # Mailing Address House Number Type
        self.MAILNAME        = line[103:203] # Mailing Address – Base Street Name
        self.MAILPLUS4       = line[104:108] # Mailing Address ZIP+4 Code
        self.MAILPOBOXID     = line[105:115] # Mailing Address – Post Office Box ID
        self.MAILPREDIR      = line[106:108] # Mailing Address – Street Name Prefix Direction
        self.MAILPREQUAL     = line[107:110] # Mailing Address – Street Name Prefix Qualifier
        self.MAILPRETYP      = line[108:122] # Mailing Address – Street Name Prefix Type
        self.MAILRRBOXID     = line[109:119] # Mailing Address – Rural Route Box ID
        self.MAILRRDESC      = line[110:135] # Mailing Address – Rural Route Descriptor
        self.MAILRRID        = line[111:115] # Mailing Address – Rural Route ID
        self.MAILSTBLDIND    = line[112:113] # Mailing Address – Street/Building Indicator
        self.MAILSTNMSRC     = line[113:114] # Mailing Address – Street Name Source
        self.MAILSUFDIR      = line[114:116] # Mailing Address – Street Name Suffix Direction
        self.MAILSUFQUAL     = line[115:118] # Mailing Address – Street Name Suffix Qualifier
        self.MAILSUFTYP      = line[116:130] # Mailing Address – Street Name Suffix Type
        self.MAILURB         = line[117:167] # Mailing Address – Urbanization (Puerto Rico)
        self.MAILWSDESC1     = line[118:130] # Mailing Address – Within Structure Descriptor
        self.MAILWSID1       = line[119:159] # Mailing Address – Within Structure ID 1
        self.MAILZIP         = line[120:125] # Mailing Address 5-digit ZIP Code
        self.MAILZIPCLASS    = line[121:122] # Mailing Address – ZIP Code Classification Code
        self.MSPID           = line[122:131] # Map Spot Identification Code
        self.MTFCC           = line[123:128] # MAF TIGER Feature Class Code
        self.NRFUAF          = line[124:125] # Nonresponse Followup Address Filter Flag
        self.NRFUUNV         = line[125:126] # Nonresponse Followup Universe Flag
        self.NUMUNITS        = line[126:130] # Number of units at this BSA
        self.OFLAT           = line[127:138] # Official Coordinates – Latitude
        self.OFLON           = line[128:140] # Official Coordinates – Longitude
        self.OID             = line[129:151] # MAF Unit Object Identification Code
        self.OIDBCU          = line[130:152] # Basic Collection Unit Object Identification Code
        self.OIDTB           = line[131:153] # PD Tabulation Block OID
        self.PDCONVNEW       = line[132:133] # LACS Conversion Flag (New Unit)
        self.PDCONVOLD       = line[133:134] # LACS Conversion Flag (Old Unit)
        self.POPDEC          = line[134:143] # Census 2000 Population
        self.POPDEC2010      = line[135:157] # Census 2010 Population
        self.POPDEC2020      = line[136:145] # Census 2020 Population
        self.POSTPLUS4       = line[137:141] # USPS – ZIP+4 Code
        self.POSTZIP         = line[138:143] # USPS – 5-digit ZIP Code
        self.POSTZIPCLASS    = line[139:140] # USPS – ZIP Code Classification Code
        self.RAMAL           = line[140:160] # Ramal
        self.RESSTAT         = line[141:142] # Residential Status Flag
        self.SECCION         = line[142:182] # Seccion
        self.SIDE            = line[143:144] # Side Indicator Flag
        self.SUPNRFUAF       = line[144:145] # 2010 Supplemental Nonresponse Followup Address Filter Flag
        self.SUPNRFUUNV      = line[145:146] # Supplemental NRFU Universe Flag
        self.SURVMAFID       = line[146:155] # Surviving MAFID
        self.TAB2010BLK      = line[147:151] # 2010 TAB Block – Census Block Number
        self.TAB2010BLKCOU   = line[148:151] # 2010 TAB Block – FIPS County Code
        self.TAB2010BLKST    = line[149:151] # 2010 TAB Block – FIPS State Code
        self.TAB2010BLKSUFX1 = line[150:151] # 2010 TAB Block – Block Suffix 1
        self.TAB2010BLKSUFX2 = line[151:152] # 2010 TAB Block – Block Suffix 2
        self.TAB2010BLKTRACT = line[152:158] # 2010 TAB Block – Census Tract Code
        self.TAB2020BLK      = line[153:157] # 2020 TAB Block – Census Block Number
        self.TAB2020BLKCOU   = line[154:157] # 2020 TAB Block – FIPS County Code
        self.TAB2020BLKST    = line[155:157] # 2020 TAB Block – FIPS State Code
        self.TAB2020BLKSUFX1 = line[156:157] # 2020 TAB Block – Block Suffix 1
        self.TAB2020BLKSUFX2 = line[157:158] # 2020 TAB Block – Block Suffix 2
        self.TAB2020BLKTRACT = line[158:164] # 2020 TAB Block – Census Tract Code
        self.TABAF           = line[159:160] # 2010 Final Tabulation Address Filter Flag
        self.TABMS           = line[160:181] # 2010 Current Block Map Spot ID
        self.TEA             = line[161:162] # Type of Enumeration Area
        self.TLID            = line[162:172] # Permanent Edge ID where this unit geocodes
        self.UNITSTAT        = line[163:165] # Unit Status Code
        self.WSDESC2PR       = line[164:176] # Puerto Rico Within Structure Descriptor 2
        self.WSID2PR         = line[165:205] # Within Structure ID 2
        self.XTYP            = line[166:167] # ACS x-type flag

    def validate(self):
        """Return True if the object data validates"""
        if not E_validator.is_valid_ABRAF(self.ABRAF): return False
        if not E_validator.is_valid_ACOCE(self.ACOCE): return False
        if not E_validator.is_valid_BCUCOUNTYFP(self.BCUCOUNTYFP): return False
        if not E_validator.is_valid_BCUID(self.BCUID): return False
        if not E_validator.is_valid_BCUSTATEFP(self.BCUSTATEFP): return False
        if not E_validator.is_valid_BCUTRACTCE(self.BCUTRACTCE): return False
        if not E_validator.is_valid_CARRETERA(self.CARRETERA): return False
        if not E_validator.is_valid_CENSTAT2010(self.CENSTAT2010): return False
        if not E_validator.is_valid_CENSTAT2020(self.CENSTAT2020): return False
        if not E_validator.is_valid_CENSURV(self.CENSURV): return False
        if not E_validator.is_valid_CENSUS2010(self.CENSUS2010): return False
        if not E_validator.is_valid_CENSUS2020(self.CENSUS2020): return False
        if not E_validator.is_valid_CENSUSAF(self.CENSUSAF): return False
        if not E_validator.is_valid_CFUFVAF(self.CFUFVAF): return False
        if not E_validator.is_valid_COLLAF(self.COLLAF): return False
        if not E_validator.is_valid_COLLUNV(self.COLLUNV): return False
        if not E_validator.is_valid_COMPLETELOCNAME(self.COMPLETELOCNAME): return False
        if not E_validator.is_valid_COMPLETEMAILNAME(self.COMPLETEMAILNAME): return False
        if not E_validator.is_valid_CONTITLE(self.CONTITLE): return False
        if not E_validator.is_valid_COORDTYP(self.COORDTYP): return False
        if not E_validator.is_valid_CURBLK(self.CURBLK): return False
        if not E_validator.is_valid_CURBLKCOU(self.CURBLKCOU): return False
        if not E_validator.is_valid_CURBLKST(self.CURBLKST): return False
        if not E_validator.is_valid_CURBLKSUFX1(self.CURBLKSUFX1): return False
        if not E_validator.is_valid_CURBLKSUFX2(self.CURBLKSUFX2): return False
        if not E_validator.is_valid_CURBLKTRACT(self.CURBLKTRACT): return False
        if not E_validator.is_valid_CURCOUNTY(self.CURCOUNTY): return False
        if not E_validator.is_valid_CURSTATE(self.CURSTATE): return False
        if not E_validator.is_valid_DELPTTYPE(self.DELPTTYPE): return False
        if not E_validator.is_valid_DSAF(self.DSAF): return False
        if not E_validator.is_valid_DSFBASEALT(self.DSFBASEALT): return False
        if not E_validator.is_valid_DSFFALLAST(self.DSFFALLAST): return False
        if not E_validator.is_valid_DSFRT(self.DSFRT): return False
        if not E_validator.is_valid_DSFSPRLAST(self.DSFSPRLAST): return False
        if not E_validator.is_valid_ENUMAF(self.ENUMAF): return False
        if not E_validator.is_valid_ENUMAF2010(self.ENUMAF2010): return False
        if not E_validator.is_valid_ENUMUNV(self.ENUMUNV): return False
        if not E_validator.is_valid_FACTLNAME(self.FACTLNAME): return False
        if not E_validator.is_valid_GQAREACODE(self.GQAREACODE): return False
        if not E_validator.is_valid_GQCONTACT(self.GQCONTACT): return False
        if not E_validator.is_valid_GQCURRMAXPOP(self.GQCURRMAXPOP): return False
        if not E_validator.is_valid_GQCURRSIZE(self.GQCURRSIZE): return False
        if not E_validator.is_valid_GQEXT(self.GQEXT): return False
        if not E_validator.is_valid_GQHUFLAG(self.GQHUFLAG): return False
        if not E_validator.is_valid_GQID(self.GQID): return False
        if not E_validator.is_valid_GQNAME(self.GQNAME): return False
        if not E_validator.is_valid_GQPHONE(self.GQPHONE): return False
        if not E_validator.is_valid_GQTYPCUR(self.GQTYPCUR): return False
        if not E_validator.is_valid_HUTYP(self.HUTYP): return False
        if not E_validator.is_valid_INITUCMAF(self.INITUCMAF): return False
        if not E_validator.is_valid_INSITE(self.INSITE): return False
        if not E_validator.is_valid_IOACIRAF(self.IOACIRAF): return False
        if not E_validator.is_valid_IS2020DLV(self.IS2020DLV): return False
        if not E_validator.is_valid_ISOLQ(self.ISOLQ): return False
        if not E_validator.is_valid_ISUCMDLV(self.ISUCMDLV): return False
        if not E_validator.is_valid_KMHM(self.KMHM): return False
        if not E_validator.is_valid_LEGACYMAFID(self.LEGACYMAFID): return False
        if not E_validator.is_valid_LIMADEL(self.LIMADEL): return False
        if not E_validator.is_valid_LOCAPTCOMPLEX(self.LOCAPTCOMPLEX): return False
        if not E_validator.is_valid_LOCAREANM1(self.LOCAREANM1): return False
        if not E_validator.is_valid_LOCAREANM2(self.LOCAREANM2): return False
        if not E_validator.is_valid_LOCBLDGDESC(self.LOCBLDGDESC): return False
        if not E_validator.is_valid_LOCBLDGID(self.LOCBLDGID): return False
        if not E_validator.is_valid_LOCDESC(self.LOCDESC): return False
        if not E_validator.is_valid_LOCHN1(self.LOCHN1): return False
        if not E_validator.is_valid_LOCHN2(self.LOCHN2): return False
        if not E_validator.is_valid_LOCHNPR(self.LOCHNPR): return False
        if not E_validator.is_valid_LOCHNPRE(self.LOCHNPRE): return False
        if not E_validator.is_valid_LOCHNSEP(self.LOCHNSEP): return False
        if not E_validator.is_valid_LOCHNSUF(self.LOCHNSUF): return False
        if not E_validator.is_valid_LOCHNTYPE(self.LOCHNTYPE): return False
        if not E_validator.is_valid_LOCISMAIL(self.LOCISMAIL): return False
        if not E_validator.is_valid_LOCNAME(self.LOCNAME): return False
        if not E_validator.is_valid_LOCPLUS4(self.LOCPLUS4): return False
        if not E_validator.is_valid_LOCPREDIR(self.LOCPREDIR): return False
        if not E_validator.is_valid_LOCPREQUAL(self.LOCPREQUAL): return False
        if not E_validator.is_valid_LOCPRETYP(self.LOCPRETYP): return False
        if not E_validator.is_valid_LOCSTBLDIND(self.LOCSTBLDIND): return False
        if not E_validator.is_valid_LOCSTNMSRC(self.LOCSTNMSRC): return False
        if not E_validator.is_valid_LOCSUFDIR(self.LOCSUFDIR): return False
        if not E_validator.is_valid_LOCSUFQUAL(self.LOCSUFQUAL): return False
        if not E_validator.is_valid_LOCSUFTYP(self.LOCSUFTYP): return False
        if not E_validator.is_valid_LOCURB(self.LOCURB): return False
        if not E_validator.is_valid_LOCWSDESC1(self.LOCWSDESC1): return False
        if not E_validator.is_valid_LOCWSID1(self.LOCWSID1): return False
        if not E_validator.is_valid_LOCZIP(self.LOCZIP): return False
        if not E_validator.is_valid_LOCZIPCLASS(self.LOCZIPCLASS): return False
        if not E_validator.is_valid_LUCAAF2020(self.LUCAAF2020): return False
        if not E_validator.is_valid_MAFCSFAIL(self.MAFCSFAIL): return False
        if not E_validator.is_valid_MAFID(self.MAFID): return False
        if not E_validator.is_valid_MAFSRC(self.MAFSRC): return False
        if not E_validator.is_valid_MAILAPTCOMPLEX(self.MAILAPTCOMPLEX): return False
        if not E_validator.is_valid_MAILAREANM1(self.MAILAREANM1): return False
        if not E_validator.is_valid_MAILAREANM2(self.MAILAREANM2): return False
        if not E_validator.is_valid_MAILBLDGDESC(self.MAILBLDGDESC): return False
        if not E_validator.is_valid_MAILBLDGID(self.MAILBLDGID): return False
        if not E_validator.is_valid_MAILHN1(self.MAILHN1): return False
        if not E_validator.is_valid_MAILHN2(self.MAILHN2): return False
        if not E_validator.is_valid_MAILHNPR(self.MAILHNPR): return False
        if not E_validator.is_valid_MAILHNPRE(self.MAILHNPRE): return False
        if not E_validator.is_valid_MAILHNSEP(self.MAILHNSEP): return False
        if not E_validator.is_valid_MAILHNSUF(self.MAILHNSUF): return False
        if not E_validator.is_valid_MAILHNTYPE(self.MAILHNTYPE): return False
        if not E_validator.is_valid_MAILNAME(self.MAILNAME): return False
        if not E_validator.is_valid_MAILPLUS4(self.MAILPLUS4): return False
        if not E_validator.is_valid_MAILPOBOXID(self.MAILPOBOXID): return False
        if not E_validator.is_valid_MAILPREDIR(self.MAILPREDIR): return False
        if not E_validator.is_valid_MAILPREQUAL(self.MAILPREQUAL): return False
        if not E_validator.is_valid_MAILPRETYP(self.MAILPRETYP): return False
        if not E_validator.is_valid_MAILRRBOXID(self.MAILRRBOXID): return False
        if not E_validator.is_valid_MAILRRDESC(self.MAILRRDESC): return False
        if not E_validator.is_valid_MAILRRID(self.MAILRRID): return False
        if not E_validator.is_valid_MAILSTBLDIND(self.MAILSTBLDIND): return False
        if not E_validator.is_valid_MAILSTNMSRC(self.MAILSTNMSRC): return False
        if not E_validator.is_valid_MAILSUFDIR(self.MAILSUFDIR): return False
        if not E_validator.is_valid_MAILSUFQUAL(self.MAILSUFQUAL): return False
        if not E_validator.is_valid_MAILSUFTYP(self.MAILSUFTYP): return False
        if not E_validator.is_valid_MAILURB(self.MAILURB): return False
        if not E_validator.is_valid_MAILWSDESC1(self.MAILWSDESC1): return False
        if not E_validator.is_valid_MAILWSID1(self.MAILWSID1): return False
        if not E_validator.is_valid_MAILZIP(self.MAILZIP): return False
        if not E_validator.is_valid_MAILZIPCLASS(self.MAILZIPCLASS): return False
        if not E_validator.is_valid_MSPID(self.MSPID): return False
        if not E_validator.is_valid_MTFCC(self.MTFCC): return False
        if not E_validator.is_valid_NRFUAF(self.NRFUAF): return False
        if not E_validator.is_valid_NRFUUNV(self.NRFUUNV): return False
        if not E_validator.is_valid_NUMUNITS(self.NUMUNITS): return False
        if not E_validator.is_valid_OFLAT(self.OFLAT): return False
        if not E_validator.is_valid_OFLON(self.OFLON): return False
        if not E_validator.is_valid_OID(self.OID): return False
        if not E_validator.is_valid_OIDBCU(self.OIDBCU): return False
        if not E_validator.is_valid_OIDTB(self.OIDTB): return False
        if not E_validator.is_valid_PDCONVNEW(self.PDCONVNEW): return False
        if not E_validator.is_valid_PDCONVOLD(self.PDCONVOLD): return False
        if not E_validator.is_valid_POPDEC(self.POPDEC): return False
        if not E_validator.is_valid_POPDEC2010(self.POPDEC2010): return False
        if not E_validator.is_valid_POPDEC2020(self.POPDEC2020): return False
        if not E_validator.is_valid_POSTPLUS4(self.POSTPLUS4): return False
        if not E_validator.is_valid_POSTZIP(self.POSTZIP): return False
        if not E_validator.is_valid_POSTZIPCLASS(self.POSTZIPCLASS): return False
        if not E_validator.is_valid_RAMAL(self.RAMAL): return False
        if not E_validator.is_valid_RESSTAT(self.RESSTAT): return False
        if not E_validator.is_valid_SECCION(self.SECCION): return False
        if not E_validator.is_valid_SIDE(self.SIDE): return False
        if not E_validator.is_valid_SUPNRFUAF(self.SUPNRFUAF): return False
        if not E_validator.is_valid_SUPNRFUUNV(self.SUPNRFUUNV): return False
        if not E_validator.is_valid_SURVMAFID(self.SURVMAFID): return False
        if not E_validator.is_valid_TAB2010BLK(self.TAB2010BLK): return False
        if not E_validator.is_valid_TAB2010BLKCOU(self.TAB2010BLKCOU): return False
        if not E_validator.is_valid_TAB2010BLKST(self.TAB2010BLKST): return False
        if not E_validator.is_valid_TAB2010BLKSUFX1(self.TAB2010BLKSUFX1): return False
        if not E_validator.is_valid_TAB2010BLKSUFX2(self.TAB2010BLKSUFX2): return False
        if not E_validator.is_valid_TAB2010BLKTRACT(self.TAB2010BLKTRACT): return False
        if not E_validator.is_valid_TAB2020BLK(self.TAB2020BLK): return False
        if not E_validator.is_valid_TAB2020BLKCOU(self.TAB2020BLKCOU): return False
        if not E_validator.is_valid_TAB2020BLKST(self.TAB2020BLKST): return False
        if not E_validator.is_valid_TAB2020BLKSUFX1(self.TAB2020BLKSUFX1): return False
        if not E_validator.is_valid_TAB2020BLKSUFX2(self.TAB2020BLKSUFX2): return False
        if not E_validator.is_valid_TAB2020BLKTRACT(self.TAB2020BLKTRACT): return False
        if not E_validator.is_valid_TABAF(self.TABAF): return False
        if not E_validator.is_valid_TABMS(self.TABMS): return False
        if not E_validator.is_valid_TEA(self.TEA): return False
        if not E_validator.is_valid_TLID(self.TLID): return False
        if not E_validator.is_valid_UNITSTAT(self.UNITSTAT): return False
        if not E_validator.is_valid_WSDESC2PR(self.WSDESC2PR): return False
        if not E_validator.is_valid_WSID2PR(self.WSID2PR): return False
        if not E_validator.is_valid_XTYP(self.XTYP): return False
        return True

    def validate_reason(self):
        reason=[]
        if not E_validator.is_valid_ABRAF(self.ABRAF): reason.append('ABRAF ('+str(self.ABRAF)+') out of range ()')
        if not E_validator.is_valid_ACOCE(self.ACOCE): reason.append('ACOCE ('+str(self.ACOCE)+') out of range (2501-2599, 4030-4030, 3600-3600, 4000-4000, 3400-3400, 4020-4020, 3500-3500, 4010-4010, 4040-4040, 3201-3299, 2301-2399, 2901-2999, 3101-3199, 2201-2299)')
        if not E_validator.is_valid_BCUCOUNTYFP(self.BCUCOUNTYFP): reason.append('BCUCOUNTYFP ('+str(self.BCUCOUNTYFP)+') out of range (001-840)')
        if not E_validator.is_valid_BCUID(self.BCUID): reason.append('BCUID ('+str(self.BCUID)+') out of range (00000100-99999999)')
        if not E_validator.is_valid_BCUSTATEFP(self.BCUSTATEFP): reason.append('BCUSTATEFP ('+str(self.BCUSTATEFP)+') out of range (02-02, 66-66, 60-60, 44-51, 72-72, 74-74, 78-78, 69-69, 08-13, 01-01, 15-42, 04-06, 53-56)')
        if not E_validator.is_valid_BCUTRACTCE(self.BCUTRACTCE): reason.append('BCUTRACTCE ('+str(self.BCUTRACTCE)+') out of range (000100-998999)')
        if not E_validator.is_valid_CARRETERA(self.CARRETERA): reason.append('CARRETERA ('+str(self.CARRETERA)+') out of range ()')
        if not E_validator.is_valid_CENSTAT2010(self.CENSTAT2010): reason.append('CENSTAT2010 ('+str(self.CENSTAT2010)+') out of range (4-4, 3-3, 1-1, 5-5, 8-8, 6-6, 7-7, 2-2, 0-0)')
        if not E_validator.is_valid_CENSTAT2020(self.CENSTAT2020): reason.append('CENSTAT2020 ('+str(self.CENSTAT2020)+') out of range ()')
        if not E_validator.is_valid_CENSURV(self.CENSURV): reason.append('CENSURV ('+str(self.CENSURV)+') out of range (2-2, 1-1, 0-0)')
        if not E_validator.is_valid_CENSUS2010(self.CENSUS2010): reason.append('CENSUS2010 ('+str(self.CENSUS2010)+') out of range (Y-Y, N-N)')
        if not E_validator.is_valid_CENSUS2020(self.CENSUS2020): reason.append('CENSUS2020 ('+str(self.CENSUS2020)+') out of range (Y-Y, N-N)')
        if not E_validator.is_valid_CENSUSAF(self.CENSUSAF): reason.append('CENSUSAF ('+str(self.CENSUSAF)+') out of range (1-1, 0-0)')
        if not E_validator.is_valid_CFUFVAF(self.CFUFVAF): reason.append('CFUFVAF ('+str(self.CFUFVAF)+') out of range ()')
        if not E_validator.is_valid_COLLAF(self.COLLAF): reason.append('COLLAF ('+str(self.COLLAF)+') out of range ()')
        if not E_validator.is_valid_COLLUNV(self.COLLUNV): reason.append('COLLUNV ('+str(self.COLLUNV)+') out of range (Y-Y, N-N)')
        if not E_validator.is_valid_COMPLETELOCNAME(self.COMPLETELOCNAME): reason.append('COMPLETELOCNAME ('+str(self.COMPLETELOCNAME)+') out of range ()')
        if not E_validator.is_valid_COMPLETEMAILNAME(self.COMPLETEMAILNAME): reason.append('COMPLETEMAILNAME ('+str(self.COMPLETEMAILNAME)+') out of range ()')
        if not E_validator.is_valid_CONTITLE(self.CONTITLE): reason.append('CONTITLE ('+str(self.CONTITLE)+') out of range ()')
        if not E_validator.is_valid_COORDTYP(self.COORDTYP): reason.append('COORDTYP ('+str(self.COORDTYP)+') out of range (D-D, I-I, L-L, G-G, O-O, P-P, R-R, S-S, M-M, W-W, E-E, Q-Q)')
        if not E_validator.is_valid_CURBLK(self.CURBLK): reason.append('CURBLK ('+str(self.CURBLK)+') out of range ()')
        if not E_validator.is_valid_CURBLKCOU(self.CURBLKCOU): reason.append('CURBLKCOU ('+str(self.CURBLKCOU)+') out of range (001-840)')
        if not E_validator.is_valid_CURBLKST(self.CURBLKST): reason.append('CURBLKST ('+str(self.CURBLKST)+') out of range (02-02, 66-66, 60-60, 44-51, 72-72, 74-74, 78-78, 69-69, 08-13, 01-01, 15-42, 04-06, 53-56)')
        if not E_validator.is_valid_CURBLKSUFX1(self.CURBLKSUFX1): reason.append('CURBLKSUFX1 ('+str(self.CURBLKSUFX1)+') out of range (A-Z)')
        if not E_validator.is_valid_CURBLKSUFX2(self.CURBLKSUFX2): reason.append('CURBLKSUFX2 ('+str(self.CURBLKSUFX2)+') out of range (A-Z)')
        if not E_validator.is_valid_CURBLKTRACT(self.CURBLKTRACT): reason.append('CURBLKTRACT ('+str(self.CURBLKTRACT)+') out of range (000100-998999)')
        if not E_validator.is_valid_CURCOUNTY(self.CURCOUNTY): reason.append('CURCOUNTY ('+str(self.CURCOUNTY)+') out of range (001-840)')
        if not E_validator.is_valid_CURSTATE(self.CURSTATE): reason.append('CURSTATE ('+str(self.CURSTATE)+') out of range (02-02, 66-66, 60-60, 44-51, 72-72, 74-74, 78-78, 69-69, 08-13, 01-01, 15-42, 04-06, 53-56)')
        if not E_validator.is_valid_DELPTTYPE(self.DELPTTYPE): reason.append('DELPTTYPE ('+str(self.DELPTTYPE)+') out of range (D-D, 4-4, 8-8, K-K, B-B, H-H, N-N, O-O, V-V, Z-Z, F-F, I-I, J-J, L-L, R-R, 7-7, C-C, 2-2, T-T, 6-6, W-W, 1-1, A-A, 5-5, 3-3, G-G, P-P, U-U, Y-Y, S-S, M-M, E-E, X-X)')
        if not E_validator.is_valid_DSAF(self.DSAF): reason.append('DSAF ('+str(self.DSAF)+') out of range (2-2, 4-4, 3-3, 1-1)')
        if not E_validator.is_valid_DSFBASEALT(self.DSFBASEALT): reason.append('DSFBASEALT ('+str(self.DSFBASEALT)+') out of range (B-B, A-A)')
        if not E_validator.is_valid_DSFFALLAST(self.DSFFALLAST): reason.append('DSFFALLAST ('+str(self.DSFFALLAST)+') out of range ()')
        if not E_validator.is_valid_DSFRT(self.DSFRT): reason.append('DSFRT ('+str(self.DSFRT)+') out of range (G-G, F-F, P-P, R-R, H-H, S-S)')
        if not E_validator.is_valid_DSFSPRLAST(self.DSFSPRLAST): reason.append('DSFSPRLAST ('+str(self.DSFSPRLAST)+') out of range ()')
        if not E_validator.is_valid_ENUMAF(self.ENUMAF): reason.append('ENUMAF ('+str(self.ENUMAF)+') out of range (1-1, 0-0)')
        if not E_validator.is_valid_ENUMAF2010(self.ENUMAF2010): reason.append('ENUMAF2010 ('+str(self.ENUMAF2010)+') out of range ()')
        if not E_validator.is_valid_ENUMUNV(self.ENUMUNV): reason.append('ENUMUNV ('+str(self.ENUMUNV)+') out of range (G-G, N-N, T-T, H-H)')
        if not E_validator.is_valid_FACTLNAME(self.FACTLNAME): reason.append('FACTLNAME ('+str(self.FACTLNAME)+') out of range ()')
        if not E_validator.is_valid_GQAREACODE(self.GQAREACODE): reason.append('GQAREACODE ('+str(self.GQAREACODE)+') out of range ()')
        if not E_validator.is_valid_GQCONTACT(self.GQCONTACT): reason.append('GQCONTACT ('+str(self.GQCONTACT)+') out of range ()')
        if not E_validator.is_valid_GQCURRMAXPOP(self.GQCURRMAXPOP): reason.append('GQCURRMAXPOP ('+str(self.GQCURRMAXPOP)+') out of range ()')
        if not E_validator.is_valid_GQCURRSIZE(self.GQCURRSIZE): reason.append('GQCURRSIZE ('+str(self.GQCURRSIZE)+') out of range ()')
        if not E_validator.is_valid_GQEXT(self.GQEXT): reason.append('GQEXT ('+str(self.GQEXT)+') out of range ()')
        if not E_validator.is_valid_GQHUFLAG(self.GQHUFLAG): reason.append('GQHUFLAG ('+str(self.GQHUFLAG)+') out of range (5-5, 4-4, 3-3, 2-2, 0-0)')
        if not E_validator.is_valid_GQID(self.GQID): reason.append('GQID ('+str(self.GQID)+') out of range (1-9999)')
        if not E_validator.is_valid_GQNAME(self.GQNAME): reason.append('GQNAME ('+str(self.GQNAME)+') out of range ()')
        if not E_validator.is_valid_GQPHONE(self.GQPHONE): reason.append('GQPHONE ('+str(self.GQPHONE)+') out of range ()')
        if not E_validator.is_valid_GQTYPCUR(self.GQTYPCUR): reason.append('GQTYPCUR ('+str(self.GQTYPCUR)+') out of range (602-602, 703-703, 103-103, 301-301, 802-802, 902-902, 105-105, 104-104, 706-706, 900-900, 601-601, 0-0, 502-502, 101-101, 999-999, 404-404, 201-201, 106-106, 702-702, 202-202, 501-501, 704-704, 801-801, 901-901, 903-903, 102-102, 701-701, 401-401, 402-402, 403-403, 405-405, 203-203)')
        if not E_validator.is_valid_HUTYP(self.HUTYP): reason.append('HUTYP ('+str(self.HUTYP)+') out of range (M-M, T-T, S-S, O-O)')
        if not E_validator.is_valid_INITUCMAF(self.INITUCMAF): reason.append('INITUCMAF ('+str(self.INITUCMAF)+') out of range (4-4, 3-3, 1-1, 5-5, 6-6, 2-2, 0-0)')
        if not E_validator.is_valid_INSITE(self.INSITE): reason.append('INSITE ('+str(self.INSITE)+') out of range (Y-Y, N-N, 1-1, 0-0)')
        if not E_validator.is_valid_IOACIRAF(self.IOACIRAF): reason.append('IOACIRAF ('+str(self.IOACIRAF)+') out of range ()')
        if not E_validator.is_valid_IS2020DLV(self.IS2020DLV): reason.append('IS2020DLV ('+str(self.IS2020DLV)+') out of range (Y-Y, N-N)')
        if not E_validator.is_valid_ISOLQ(self.ISOLQ): reason.append('ISOLQ ('+str(self.ISOLQ)+') out of range (1-1)')
        if not E_validator.is_valid_ISUCMDLV(self.ISUCMDLV): reason.append('ISUCMDLV ('+str(self.ISUCMDLV)+') out of range (Y-Y, N-N)')
        if not E_validator.is_valid_KMHM(self.KMHM): reason.append('KMHM ('+str(self.KMHM)+') out of range ()')
        if not E_validator.is_valid_LEGACYMAFID(self.LEGACYMAFID): reason.append('LEGACYMAFID ('+str(self.LEGACYMAFID)+') out of range ()')
        if not E_validator.is_valid_LIMADEL(self.LIMADEL): reason.append('LIMADEL ('+str(self.LIMADEL)+') out of range ()')
        if not E_validator.is_valid_LOCAPTCOMPLEX(self.LOCAPTCOMPLEX): reason.append('LOCAPTCOMPLEX ('+str(self.LOCAPTCOMPLEX)+') out of range ()')
        if not E_validator.is_valid_LOCAREANM1(self.LOCAREANM1): reason.append('LOCAREANM1 ('+str(self.LOCAREANM1)+') out of range ()')
        if not E_validator.is_valid_LOCAREANM2(self.LOCAREANM2): reason.append('LOCAREANM2 ('+str(self.LOCAREANM2)+') out of range ()')
        if not E_validator.is_valid_LOCBLDGDESC(self.LOCBLDGDESC): reason.append('LOCBLDGDESC ('+str(self.LOCBLDGDESC)+') out of range ()')
        if not E_validator.is_valid_LOCBLDGID(self.LOCBLDGID): reason.append('LOCBLDGID ('+str(self.LOCBLDGID)+') out of range ()')
        if not E_validator.is_valid_LOCDESC(self.LOCDESC): reason.append('LOCDESC ('+str(self.LOCDESC)+') out of range ()')
        if not E_validator.is_valid_LOCHN1(self.LOCHN1): reason.append('LOCHN1 ('+str(self.LOCHN1)+') out of range ()')
        if not E_validator.is_valid_LOCHN2(self.LOCHN2): reason.append('LOCHN2 ('+str(self.LOCHN2)+') out of range ()')
        if not E_validator.is_valid_LOCHNPR(self.LOCHNPR): reason.append('LOCHNPR ('+str(self.LOCHNPR)+') out of range ()')
        if not E_validator.is_valid_LOCHNPRE(self.LOCHNPRE): reason.append('LOCHNPRE ('+str(self.LOCHNPRE)+') out of range ()')
        if not E_validator.is_valid_LOCHNSEP(self.LOCHNSEP): reason.append('LOCHNSEP ('+str(self.LOCHNSEP)+') out of range ()')
        if not E_validator.is_valid_LOCHNSUF(self.LOCHNSUF): reason.append('LOCHNSUF ('+str(self.LOCHNSUF)+') out of range ()')
        if not E_validator.is_valid_LOCHNTYPE(self.LOCHNTYPE): reason.append('LOCHNTYPE ('+str(self.LOCHNTYPE)+') out of range (B-B, H-H)')
        if not E_validator.is_valid_LOCISMAIL(self.LOCISMAIL): reason.append('LOCISMAIL ('+str(self.LOCISMAIL)+') out of range (Y-Y, N-N)')
        if not E_validator.is_valid_LOCNAME(self.LOCNAME): reason.append('LOCNAME ('+str(self.LOCNAME)+') out of range ()')
        if not E_validator.is_valid_LOCPLUS4(self.LOCPLUS4): reason.append('LOCPLUS4 ('+str(self.LOCPLUS4)+') out of range ()')
        if not E_validator.is_valid_LOCPREDIR(self.LOCPREDIR): reason.append('LOCPREDIR ('+str(self.LOCPREDIR)+') out of range (NO-NO, N-N, O-O, NE-NE, NW-NW, S-S, SE-SE, SO-SO, SW-SW, W-W, E-E)')
        if not E_validator.is_valid_LOCPREQUAL(self.LOCPREQUAL): reason.append('LOCPREQUAL ('+str(self.LOCPREQUAL)+') out of range (PVT-PVT, SPR-SPR, BYP-BYP, HST-HST, OLD-OLD, PUB-PUB, EXD-EXD, LP-LP, BUS-BUS, ALT-ALT)')
        if not E_validator.is_valid_LOCPRETYP(self.LOCPRETYP): reason.append('LOCPRETYP ('+str(self.LOCPRETYP)+') out of range ()')
        if not E_validator.is_valid_LOCSTBLDIND(self.LOCSTBLDIND): reason.append('LOCSTBLDIND ('+str(self.LOCSTBLDIND)+') out of range (1-1, 0-0)')
        if not E_validator.is_valid_LOCSTNMSRC(self.LOCSTNMSRC): reason.append('LOCSTNMSRC ('+str(self.LOCSTNMSRC)+') out of range (1-1, 0-0)')
        if not E_validator.is_valid_LOCSUFDIR(self.LOCSUFDIR): reason.append('LOCSUFDIR ('+str(self.LOCSUFDIR)+') out of range (NO-NO, N-N, O-O, NW-NW, NE-NE, S-S, SE-SE, SO-SO, E-E, W-W, SW-SW)')
        if not E_validator.is_valid_LOCSUFQUAL(self.LOCSUFQUAL): reason.append('LOCSUFQUAL ('+str(self.LOCSUFQUAL)+') out of range (PVT-PVT, SPR-SPR, BYP-BYP, OVP-OVP, ALT-ALT, PUB-PUB, ACC-ACC, EXD-EXD, BUS-BUS, EXN-EXN, LP-LP, UNP-UNP, SCN-SCN, RMP-RMP, CON-CON)')
        if not E_validator.is_valid_LOCSUFTYP(self.LOCSUFTYP): reason.append('LOCSUFTYP ('+str(self.LOCSUFTYP)+') out of range ()')
        if not E_validator.is_valid_LOCURB(self.LOCURB): reason.append('LOCURB ('+str(self.LOCURB)+') out of range ()')
        if not E_validator.is_valid_LOCWSDESC1(self.LOCWSDESC1): reason.append('LOCWSDESC1 ('+str(self.LOCWSDESC1)+') out of range (PARTE-PARTE, BAY-BAY, PISO-PISO, STORE-STORE, UNIT-UNIT, STES-STES, ALTOS-ALTOS, IZQ-IZQ, SLIP-SLIP, BAJOS-BAJOS, EXT-EXT, HANGAR-HANGAR, APT-APT, STE-STE, DEPT-DEPT, STUDIO-STUDIO, PH-PH, ROOM-ROOM, ATRAS-ATRAS, LOT-LOT, DER-DER, MH-MH, SOTANO-SOTANO, STALL-STALL, STOP-STOP, SPACE-SPACE, TRLR-TRLR, ALD-ALD, INT-INT, PIER-PIER)')
        if not E_validator.is_valid_LOCWSID1(self.LOCWSID1): reason.append('LOCWSID1 ('+str(self.LOCWSID1)+') out of range ()')
        if not E_validator.is_valid_LOCZIP(self.LOCZIP): reason.append('LOCZIP ('+str(self.LOCZIP)+') out of range ()')
        if not E_validator.is_valid_LOCZIPCLASS(self.LOCZIPCLASS): reason.append('LOCZIPCLASS ('+str(self.LOCZIPCLASS)+') out of range (U-U, M-M, P-P)')
        if not E_validator.is_valid_LUCAAF2020(self.LUCAAF2020): reason.append('LUCAAF2020 ('+str(self.LUCAAF2020)+') out of range ()')
        if not E_validator.is_valid_MAFCSFAIL(self.MAFCSFAIL): reason.append('MAFCSFAIL ('+str(self.MAFCSFAIL)+') out of range ()')
        if not E_validator.is_valid_MAFID(self.MAFID): reason.append('MAFID ('+str(self.MAFID)+') out of range ()')
        if not E_validator.is_valid_MAFSRC(self.MAFSRC): reason.append('MAFSRC ('+str(self.MAFSRC)+') out of range ()')
        if not E_validator.is_valid_MAILAPTCOMPLEX(self.MAILAPTCOMPLEX): reason.append('MAILAPTCOMPLEX ('+str(self.MAILAPTCOMPLEX)+') out of range ()')
        if not E_validator.is_valid_MAILAREANM1(self.MAILAREANM1): reason.append('MAILAREANM1 ('+str(self.MAILAREANM1)+') out of range ()')
        if not E_validator.is_valid_MAILAREANM2(self.MAILAREANM2): reason.append('MAILAREANM2 ('+str(self.MAILAREANM2)+') out of range ()')
        if not E_validator.is_valid_MAILBLDGDESC(self.MAILBLDGDESC): reason.append('MAILBLDGDESC ('+str(self.MAILBLDGDESC)+') out of range ()')
        if not E_validator.is_valid_MAILBLDGID(self.MAILBLDGID): reason.append('MAILBLDGID ('+str(self.MAILBLDGID)+') out of range ()')
        if not E_validator.is_valid_MAILHN1(self.MAILHN1): reason.append('MAILHN1 ('+str(self.MAILHN1)+') out of range ()')
        if not E_validator.is_valid_MAILHN2(self.MAILHN2): reason.append('MAILHN2 ('+str(self.MAILHN2)+') out of range ()')
        if not E_validator.is_valid_MAILHNPR(self.MAILHNPR): reason.append('MAILHNPR ('+str(self.MAILHNPR)+') out of range ()')
        if not E_validator.is_valid_MAILHNPRE(self.MAILHNPRE): reason.append('MAILHNPRE ('+str(self.MAILHNPRE)+') out of range ()')
        if not E_validator.is_valid_MAILHNSEP(self.MAILHNSEP): reason.append('MAILHNSEP ('+str(self.MAILHNSEP)+') out of range ()')
        if not E_validator.is_valid_MAILHNSUF(self.MAILHNSUF): reason.append('MAILHNSUF ('+str(self.MAILHNSUF)+') out of range ()')
        if not E_validator.is_valid_MAILHNTYPE(self.MAILHNTYPE): reason.append('MAILHNTYPE ('+str(self.MAILHNTYPE)+') out of range (B-B, H-H)')
        if not E_validator.is_valid_MAILNAME(self.MAILNAME): reason.append('MAILNAME ('+str(self.MAILNAME)+') out of range ()')
        if not E_validator.is_valid_MAILPLUS4(self.MAILPLUS4): reason.append('MAILPLUS4 ('+str(self.MAILPLUS4)+') out of range ()')
        if not E_validator.is_valid_MAILPOBOXID(self.MAILPOBOXID): reason.append('MAILPOBOXID ('+str(self.MAILPOBOXID)+') out of range ()')
        if not E_validator.is_valid_MAILPREDIR(self.MAILPREDIR): reason.append('MAILPREDIR ('+str(self.MAILPREDIR)+') out of range (NO-NO, N-N, O-O, NW-NW, NE-NE, S-S, SE-SE, SO-SO, E-E, W-W, SW-SW)')
        if not E_validator.is_valid_MAILPREQUAL(self.MAILPREQUAL): reason.append('MAILPREQUAL ('+str(self.MAILPREQUAL)+') out of range (PVT-PVT, SPR-SPR, BYP-BYP, HST-HST, OLD-OLD, PUB-PUB, EXD-EXD, LP-LP, BUS-BUS, ALT-ALT)')
        if not E_validator.is_valid_MAILPRETYP(self.MAILPRETYP): reason.append('MAILPRETYP ('+str(self.MAILPRETYP)+') out of range ()')
        if not E_validator.is_valid_MAILRRBOXID(self.MAILRRBOXID): reason.append('MAILRRBOXID ('+str(self.MAILRRBOXID)+') out of range ()')
        if not E_validator.is_valid_MAILRRDESC(self.MAILRRDESC): reason.append('MAILRRDESC ('+str(self.MAILRRDESC)+') out of range (RR-RR, PSC-PSC, HC-HC)')
        if not E_validator.is_valid_MAILRRID(self.MAILRRID): reason.append('MAILRRID ('+str(self.MAILRRID)+') out of range ()')
        if not E_validator.is_valid_MAILSTBLDIND(self.MAILSTBLDIND): reason.append('MAILSTBLDIND ('+str(self.MAILSTBLDIND)+') out of range (1-1, 0-0)')
        if not E_validator.is_valid_MAILSTNMSRC(self.MAILSTNMSRC): reason.append('MAILSTNMSRC ('+str(self.MAILSTNMSRC)+') out of range (1-1, 0-0)')
        if not E_validator.is_valid_MAILSUFDIR(self.MAILSUFDIR): reason.append('MAILSUFDIR ('+str(self.MAILSUFDIR)+') out of range (NO-NO, N-N, O-O, NW-NW, NE-NE, S-S, SE-SE, SO-SO, E-E, W-W, SW-SW)')
        if not E_validator.is_valid_MAILSUFQUAL(self.MAILSUFQUAL): reason.append('MAILSUFQUAL ('+str(self.MAILSUFQUAL)+') out of range (PVT-PVT, SPR-SPR, BYP-BYP, OVP-OVP, ALT-ALT, PUB-PUB, ACC-ACC, EXD-EXD, BUS-BUS, EXN-EXN, LP-LP, UNP-UNP, SCN-SCN, RMP-RMP, CON-CON)')
        if not E_validator.is_valid_MAILSUFTYP(self.MAILSUFTYP): reason.append('MAILSUFTYP ('+str(self.MAILSUFTYP)+') out of range ()')
        if not E_validator.is_valid_MAILURB(self.MAILURB): reason.append('MAILURB ('+str(self.MAILURB)+') out of range ()')
        if not E_validator.is_valid_MAILWSDESC1(self.MAILWSDESC1): reason.append('MAILWSDESC1 ('+str(self.MAILWSDESC1)+') out of range (PARTE-PARTE, BAY-BAY, PISO-PISO, STORE-STORE, UNIT-UNIT, STES-STES, ALTOS-ALTOS, IZQ-IZQ, SLIP-SLIP, BAJOS-BAJOS, EXT-EXT, HANGAR-HANGAR, APT-APT, STE-STE, DEPT-DEPT, STUDIO-STUDIO, PH-PH, ROOM-ROOM, ATRAS-ATRAS, LOT-LOT, DER-DER, MH-MH, SOTANO-SOTANO, STALL-STALL, STOP-STOP, SPACE-SPACE, TRLR-TRLR, ALD-ALD, INT-INT, PIER-PIER)')
        if not E_validator.is_valid_MAILWSID1(self.MAILWSID1): reason.append('MAILWSID1 ('+str(self.MAILWSID1)+') out of range ()')
        if not E_validator.is_valid_MAILZIP(self.MAILZIP): reason.append('MAILZIP ('+str(self.MAILZIP)+') out of range ()')
        if not E_validator.is_valid_MAILZIPCLASS(self.MAILZIPCLASS): reason.append('MAILZIPCLASS ('+str(self.MAILZIPCLASS)+') out of range (U-U, M-M, P-P)')
        if not E_validator.is_valid_MSPID(self.MSPID): reason.append('MSPID ('+str(self.MSPID)+') out of range (1-99, 999-999)')
        if not E_validator.is_valid_MTFCC(self.MTFCC): reason.append('MTFCC ('+str(self.MTFCC)+') out of range (U3000-U3000, U2200-U2200, U1000-U1000, U1200-U1200, U2100-U2100, U2000-U2000)')
        if not E_validator.is_valid_NRFUAF(self.NRFUAF): reason.append('NRFUAF ('+str(self.NRFUAF)+') out of range (2-2, 1-1, 0-0)')
        if not E_validator.is_valid_NRFUUNV(self.NRFUUNV): reason.append('NRFUUNV ('+str(self.NRFUUNV)+') out of range (Y-Y, N-N)')
        if not E_validator.is_valid_NUMUNITS(self.NUMUNITS): reason.append('NUMUNITS ('+str(self.NUMUNITS)+') out of range ()')
        if not E_validator.is_valid_OFLAT(self.OFLAT): reason.append('OFLAT ('+str(self.OFLAT)+') out of range ()')
        if not E_validator.is_valid_OFLON(self.OFLON): reason.append('OFLON ('+str(self.OFLON)+') out of range ()')
        if not E_validator.is_valid_OID(self.OID): reason.append('OID ('+str(self.OID)+') out of range ()')
        if not E_validator.is_valid_OIDBCU(self.OIDBCU): reason.append('OIDBCU ('+str(self.OIDBCU)+') out of range ()')
        if not E_validator.is_valid_OIDTB(self.OIDTB): reason.append('OIDTB ('+str(self.OIDTB)+') out of range ()')
        if not E_validator.is_valid_PDCONVNEW(self.PDCONVNEW): reason.append('PDCONVNEW ('+str(self.PDCONVNEW)+') out of range (4-4, 3-3, 1-1, 8-8, 7-7, 6-6)')
        if not E_validator.is_valid_PDCONVOLD(self.PDCONVOLD): reason.append('PDCONVOLD ('+str(self.PDCONVOLD)+') out of range (4-4, 3-3, 1-1, 8-8, 7-7, 6-6)')
        if not E_validator.is_valid_POPDEC(self.POPDEC): reason.append('POPDEC ('+str(self.POPDEC)+') out of range (0-350, 000-000)')
        if not E_validator.is_valid_POPDEC2010(self.POPDEC2010): reason.append('POPDEC2010 ('+str(self.POPDEC2010)+') out of range ()')
        if not E_validator.is_valid_POPDEC2020(self.POPDEC2020): reason.append('POPDEC2020 ('+str(self.POPDEC2020)+') out of range ()')
        if not E_validator.is_valid_POSTPLUS4(self.POSTPLUS4): reason.append('POSTPLUS4 ('+str(self.POSTPLUS4)+') out of range ()')
        if not E_validator.is_valid_POSTZIP(self.POSTZIP): reason.append('POSTZIP ('+str(self.POSTZIP)+') out of range ()')
        if not E_validator.is_valid_POSTZIPCLASS(self.POSTZIPCLASS): reason.append('POSTZIPCLASS ('+str(self.POSTZIPCLASS)+') out of range (U-U, M-M, P-P)')
        if not E_validator.is_valid_RAMAL(self.RAMAL): reason.append('RAMAL ('+str(self.RAMAL)+') out of range ()')
        if not E_validator.is_valid_RESSTAT(self.RESSTAT): reason.append('RESSTAT ('+str(self.RESSTAT)+') out of range (2-2, 1-1)')
        if not E_validator.is_valid_SECCION(self.SECCION): reason.append('SECCION ('+str(self.SECCION)+') out of range ()')
        if not E_validator.is_valid_SIDE(self.SIDE): reason.append('SIDE ('+str(self.SIDE)+') out of range (R-R, L-L)')
        if not E_validator.is_valid_SUPNRFUAF(self.SUPNRFUAF): reason.append('SUPNRFUAF ('+str(self.SUPNRFUAF)+') out of range (4-4, 3-3, 1-1, 5-5, 6-6, 7-7, 2-2, 0-0)')
        if not E_validator.is_valid_SUPNRFUUNV(self.SUPNRFUUNV): reason.append('SUPNRFUUNV ('+str(self.SUPNRFUUNV)+') out of range (N-N, H-H)')
        if not E_validator.is_valid_SURVMAFID(self.SURVMAFID): reason.append('SURVMAFID ('+str(self.SURVMAFID)+') out of range ()')
        if not E_validator.is_valid_TAB2010BLK(self.TAB2010BLK): reason.append('TAB2010BLK ('+str(self.TAB2010BLK)+') out of range ()')
        if not E_validator.is_valid_TAB2010BLKCOU(self.TAB2010BLKCOU): reason.append('TAB2010BLKCOU ('+str(self.TAB2010BLKCOU)+') out of range (001-840)')
        if not E_validator.is_valid_TAB2010BLKST(self.TAB2010BLKST): reason.append('TAB2010BLKST ('+str(self.TAB2010BLKST)+') out of range (02-02, 66-66, 60-60, 44-51, 72-72, 74-74, 78-78, 69-69, 08-13, 01-01, 15-42, 04-06, 53-56)')
        if not E_validator.is_valid_TAB2010BLKSUFX1(self.TAB2010BLKSUFX1): reason.append('TAB2010BLKSUFX1 ('+str(self.TAB2010BLKSUFX1)+') out of range (A-Z)')
        if not E_validator.is_valid_TAB2010BLKSUFX2(self.TAB2010BLKSUFX2): reason.append('TAB2010BLKSUFX2 ('+str(self.TAB2010BLKSUFX2)+') out of range (A-Z)')
        if not E_validator.is_valid_TAB2010BLKTRACT(self.TAB2010BLKTRACT): reason.append('TAB2010BLKTRACT ('+str(self.TAB2010BLKTRACT)+') out of range (000100-998999)')
        if not E_validator.is_valid_TAB2020BLK(self.TAB2020BLK): reason.append('TAB2020BLK ('+str(self.TAB2020BLK)+') out of range ()')
        if not E_validator.is_valid_TAB2020BLKCOU(self.TAB2020BLKCOU): reason.append('TAB2020BLKCOU ('+str(self.TAB2020BLKCOU)+') out of range (001-840)')
        if not E_validator.is_valid_TAB2020BLKST(self.TAB2020BLKST): reason.append('TAB2020BLKST ('+str(self.TAB2020BLKST)+') out of range (02-02, 66-66, 60-60, 44-51, 72-72, 74-74, 78-78, 69-69, 08-13, 01-01, 15-42, 04-06, 53-56)')
        if not E_validator.is_valid_TAB2020BLKSUFX1(self.TAB2020BLKSUFX1): reason.append('TAB2020BLKSUFX1 ('+str(self.TAB2020BLKSUFX1)+') out of range (A-Z)')
        if not E_validator.is_valid_TAB2020BLKSUFX2(self.TAB2020BLKSUFX2): reason.append('TAB2020BLKSUFX2 ('+str(self.TAB2020BLKSUFX2)+') out of range (A-Z)')
        if not E_validator.is_valid_TAB2020BLKTRACT(self.TAB2020BLKTRACT): reason.append('TAB2020BLKTRACT ('+str(self.TAB2020BLKTRACT)+') out of range (000100-998999)')
        if not E_validator.is_valid_TABAF(self.TABAF): reason.append('TABAF ('+str(self.TABAF)+') out of range (1-1, 0-0)')
        if not E_validator.is_valid_TABMS(self.TABMS): reason.append('TABMS ('+str(self.TABMS)+') out of range ()')
        if not E_validator.is_valid_TEA(self.TEA): reason.append('TEA ('+str(self.TEA)+') out of range (5-5, 4-4, 3-3, 1-1, 2-2, 6-6)')
        if not E_validator.is_valid_TLID(self.TLID): reason.append('TLID ('+str(self.TLID)+') out of range ()')
        if not E_validator.is_valid_UNITSTAT(self.UNITSTAT): reason.append('UNITSTAT ('+str(self.UNITSTAT)+') out of range (01-01)')
        if not E_validator.is_valid_WSDESC2PR(self.WSDESC2PR): reason.append('WSDESC2PR ('+str(self.WSDESC2PR)+') out of range (STE-STE, PARC-PARC, PISO-PISO, PDA-PDA)')
        if not E_validator.is_valid_WSID2PR(self.WSID2PR): reason.append('WSID2PR ('+str(self.WSID2PR)+') out of range ()')
        if not E_validator.is_valid_XTYP(self.XTYP): reason.append('XTYP ('+str(self.XTYP)+') out of range (9-9, 4-4, 3-3, 1-1, 5-5, 2-2, 0-0)')
        return ', '.join(reason)

    def SparkSQLRow(self):
        """Return a SparkSQL Row object for this object."""
        from pyspark.sql import Row
        return Row(
            abraf=safe_str(self.ABRAF),
            acoce=safe_str(self.ACOCE),
            bcucountyfp=safe_str(self.BCUCOUNTYFP),
            bcuid=safe_str(self.BCUID),
            bcustatefp=safe_str(self.BCUSTATEFP),
            bcutractce=safe_str(self.BCUTRACTCE),
            carretera=safe_str(self.CARRETERA),
            censtat2010=safe_str(self.CENSTAT2010),
            censtat2020=safe_str(self.CENSTAT2020),
            censurv=safe_str(self.CENSURV),
            census2010=safe_str(self.CENSUS2010),
            census2020=safe_str(self.CENSUS2020),
            censusaf=safe_str(self.CENSUSAF),
            cfufvaf=safe_str(self.CFUFVAF),
            collaf=safe_str(self.COLLAF),
            collunv=safe_str(self.COLLUNV),
            completelocname=safe_str(self.COMPLETELOCNAME),
            completemailname=safe_str(self.COMPLETEMAILNAME),
            contitle=safe_str(self.CONTITLE),
            coordtyp=safe_str(self.COORDTYP),
            curblk=safe_str(self.CURBLK),
            curblkcou=safe_str(self.CURBLKCOU),
            curblkst=safe_str(self.CURBLKST),
            curblksufx1=safe_str(self.CURBLKSUFX1),
            curblksufx2=safe_str(self.CURBLKSUFX2),
            curblktract=safe_str(self.CURBLKTRACT),
            curcounty=safe_str(self.CURCOUNTY),
            curstate=safe_str(self.CURSTATE),
            delpttype=safe_str(self.DELPTTYPE),
            dsaf=safe_str(self.DSAF),
            dsfbasealt=safe_str(self.DSFBASEALT),
            dsffallast=safe_str(self.DSFFALLAST),
            dsfrt=safe_str(self.DSFRT),
            dsfsprlast=safe_str(self.DSFSPRLAST),
            enumaf=safe_str(self.ENUMAF),
            enumaf2010=safe_str(self.ENUMAF2010),
            enumunv=safe_str(self.ENUMUNV),
            factlname=safe_str(self.FACTLNAME),
            gqareacode=safe_str(self.GQAREACODE),
            gqcontact=safe_str(self.GQCONTACT),
            gqcurrmaxpop=safe_int(self.GQCURRMAXPOP),
            gqcurrsize=safe_int(self.GQCURRSIZE),
            gqext=safe_str(self.GQEXT),
            gqhuflag=safe_str(self.GQHUFLAG),
            gqid=safe_int(self.GQID),
            gqname=safe_str(self.GQNAME),
            gqphone=safe_str(self.GQPHONE),
            gqtypcur=safe_str(self.GQTYPCUR),
            hutyp=safe_str(self.HUTYP),
            initucmaf=safe_str(self.INITUCMAF),
            insite=safe_str(self.INSITE),
            ioaciraf=safe_str(self.IOACIRAF),
            is2020dlv=safe_str(self.IS2020DLV),
            isolq=safe_str(self.ISOLQ),
            isucmdlv=safe_str(self.ISUCMDLV),
            kmhm=safe_str(self.KMHM),
            legacymafid=safe_str(self.LEGACYMAFID),
            limadel=safe_str(self.LIMADEL),
            locaptcomplex=safe_str(self.LOCAPTCOMPLEX),
            locareanm1=safe_str(self.LOCAREANM1),
            locareanm2=safe_str(self.LOCAREANM2),
            locbldgdesc=safe_str(self.LOCBLDGDESC),
            locbldgid=safe_str(self.LOCBLDGID),
            locdesc=safe_str(self.LOCDESC),
            lochn1=safe_str(self.LOCHN1),
            lochn2=safe_str(self.LOCHN2),
            lochnpr=safe_str(self.LOCHNPR),
            lochnpre=safe_str(self.LOCHNPRE),
            lochnsep=safe_str(self.LOCHNSEP),
            lochnsuf=safe_str(self.LOCHNSUF),
            lochntype=safe_str(self.LOCHNTYPE),
            locismail=safe_str(self.LOCISMAIL),
            locname=safe_str(self.LOCNAME),
            locplus4=safe_str(self.LOCPLUS4),
            locpredir=safe_str(self.LOCPREDIR),
            locprequal=safe_str(self.LOCPREQUAL),
            locpretyp=safe_str(self.LOCPRETYP),
            locstbldind=safe_str(self.LOCSTBLDIND),
            locstnmsrc=safe_str(self.LOCSTNMSRC),
            locsufdir=safe_str(self.LOCSUFDIR),
            locsufqual=safe_str(self.LOCSUFQUAL),
            locsuftyp=safe_str(self.LOCSUFTYP),
            locurb=safe_str(self.LOCURB),
            locwsdesc1=safe_str(self.LOCWSDESC1),
            locwsid1=safe_str(self.LOCWSID1),
            loczip=safe_str(self.LOCZIP),
            loczipclass=safe_str(self.LOCZIPCLASS),
            lucaaf2020=safe_str(self.LUCAAF2020),
            mafcsfail=safe_str(self.MAFCSFAIL),
            mafid=safe_int(self.MAFID),
            mafsrc=safe_str(self.MAFSRC),
            mailaptcomplex=safe_str(self.MAILAPTCOMPLEX),
            mailareanm1=safe_str(self.MAILAREANM1),
            mailareanm2=safe_str(self.MAILAREANM2),
            mailbldgdesc=safe_str(self.MAILBLDGDESC),
            mailbldgid=safe_str(self.MAILBLDGID),
            mailhn1=safe_str(self.MAILHN1),
            mailhn2=safe_str(self.MAILHN2),
            mailhnpr=safe_str(self.MAILHNPR),
            mailhnpre=safe_str(self.MAILHNPRE),
            mailhnsep=safe_str(self.MAILHNSEP),
            mailhnsuf=safe_str(self.MAILHNSUF),
            mailhntype=safe_str(self.MAILHNTYPE),
            mailname=safe_str(self.MAILNAME),
            mailplus4=safe_str(self.MAILPLUS4),
            mailpoboxid=safe_str(self.MAILPOBOXID),
            mailpredir=safe_str(self.MAILPREDIR),
            mailprequal=safe_str(self.MAILPREQUAL),
            mailpretyp=safe_str(self.MAILPRETYP),
            mailrrboxid=safe_str(self.MAILRRBOXID),
            mailrrdesc=safe_str(self.MAILRRDESC),
            mailrrid=safe_str(self.MAILRRID),
            mailstbldind=safe_str(self.MAILSTBLDIND),
            mailstnmsrc=safe_str(self.MAILSTNMSRC),
            mailsufdir=safe_str(self.MAILSUFDIR),
            mailsufqual=safe_str(self.MAILSUFQUAL),
            mailsuftyp=safe_str(self.MAILSUFTYP),
            mailurb=safe_str(self.MAILURB),
            mailwsdesc1=safe_str(self.MAILWSDESC1),
            mailwsid1=safe_str(self.MAILWSID1),
            mailzip=safe_str(self.MAILZIP),
            mailzipclass=safe_str(self.MAILZIPCLASS),
            mspid=safe_int(self.MSPID),
            mtfcc=safe_str(self.MTFCC),
            nrfuaf=safe_str(self.NRFUAF),
            nrfuunv=safe_str(self.NRFUUNV),
            numunits=safe_int(self.NUMUNITS),
            oflat=safe_str(self.OFLAT),
            oflon=safe_str(self.OFLON),
            oid=safe_int(self.OID),
            oidbcu=safe_int(self.OIDBCU),
            oidtb=safe_int(self.OIDTB),
            pdconvnew=safe_str(self.PDCONVNEW),
            pdconvold=safe_str(self.PDCONVOLD),
            popdec=safe_int(self.POPDEC),
            popdec2010=safe_int(self.POPDEC2010),
            popdec2020=safe_int(self.POPDEC2020),
            postplus4=safe_str(self.POSTPLUS4),
            postzip=safe_str(self.POSTZIP),
            postzipclass=safe_str(self.POSTZIPCLASS),
            ramal=safe_str(self.RAMAL),
            resstat=safe_str(self.RESSTAT),
            seccion=safe_str(self.SECCION),
            side=safe_str(self.SIDE),
            supnrfuaf=safe_str(self.SUPNRFUAF),
            supnrfuunv=safe_str(self.SUPNRFUUNV),
            survmafid=safe_int(self.SURVMAFID),
            tab2010blk=safe_str(self.TAB2010BLK),
            tab2010blkcou=safe_str(self.TAB2010BLKCOU),
            tab2010blkst=safe_str(self.TAB2010BLKST),
            tab2010blksufx1=safe_str(self.TAB2010BLKSUFX1),
            tab2010blksufx2=safe_str(self.TAB2010BLKSUFX2),
            tab2010blktract=safe_str(self.TAB2010BLKTRACT),
            tab2020blk=safe_str(self.TAB2020BLK),
            tab2020blkcou=safe_str(self.TAB2020BLKCOU),
            tab2020blkst=safe_str(self.TAB2020BLKST),
            tab2020blksufx1=safe_str(self.TAB2020BLKSUFX1),
            tab2020blksufx2=safe_str(self.TAB2020BLKSUFX2),
            tab2020blktract=safe_str(self.TAB2020BLKTRACT),
            tabaf=safe_str(self.TABAF),
            tabms=safe_str(self.TABMS),
            tea=safe_str(self.TEA),
            tlid=safe_int(self.TLID),
            unitstat=safe_str(self.UNITSTAT),
            wsdesc2pr=safe_str(self.WSDESC2PR),
            wsid2pr=safe_str(self.WSID2PR),
            xtyp=safe_str(self.XTYP),
        )


    @staticmethod
    def parse_line(line):
        # Read a line and return it as a dictionary.
        inst: E = E()
        inst.parse_column_specified(line)
        assert inst.validate(), f'A line is invalid!! line: {line}, validate_reason: {inst.validate_reason()}'
        row = inst.SparkSQLRow()
        return row

    @staticmethod
    def parse_piped_line(line):
        # Read a pipe-delimited line and return it as a dictionary.
        inst: E = E()
        inst.parse_pipe_delimited(line)
        assert inst.validate(), f'A line is invalid!! line: {line}, validate_reason: {inst.validate_reason()}'
        row = inst.SparkSQLRow()
        return row



# Automatically generated on Fri Oct 30 14:06:06 2020 by /mnt/users/user007/new-das-vm/das-vm-config/das_decennial/das_framework/ctools/schema/table.py

def leftpad(x,width):
    return ' '*(width-len(str(x)))+str(x)

def between(a,b,c,width):
    if len(b) > width:
        return False
    if '.' in a or '.' in b or '.' in c:
        try:
            return float(a) <= float(b) <= float(c)
        except ValueError:
            pass  # tries to return a float but might have weird input like 1.1.0 which will be compared traditionally instead
    b = b.replace(' ', '0')
    return leftpad(a,width) <= leftpad(b,width) <= leftpad(c,width)


def safe_int(i):
    try:
        return int(i)
    except (TypeError, ValueError):
        return None

def safe_float(i):
    try:
        return float(i)
    except (TypeError, ValueError):
        return None

def safe_str(i):
    try:
        return str(i)
    except (TypeError, ValueError):
        return None


class I_validator:
    @classmethod
    def is_valid_OIDBCU(self,x):
        """Basic Collection Unit OID [PK/Unique within Nation]"""
        if x is None or x == "None":
            return False
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return True
    @classmethod
    def is_valid_STATEFP(self,x):
        """FIPS State Code"""
        if x is None or x == "None":
            return False
        return True
    @classmethod
    def is_valid_COUNTYFP(self,x):
        """FIPS County Code"""
        if x is None or x == "None":
            return False
        return True
    @classmethod
    def is_valid_TRACTCE(self,x):
        """Census Tract Code"""
        if x is None or x == "None":
            return False
        return True
    @classmethod
    def is_valid_BCUID(self,x):
        """Basic Collection Unit Identification Code"""
        if x is None or x == "None":
            return False
        return True
    @classmethod
    def is_valid_LWBCUTYP(self,x):
        """Land/Water BCU Type"""
        if x is None or x == "None":
            return False
        return (leftpad(x,8)==leftpad('L',8)) or (leftpad(x,8)==leftpad('W',8)) or (leftpad(x,8)==leftpad('B',8))
    @classmethod
    def is_valid_RCCCE(self,x):
        """RCC Code"""
        if x is None or x == "None":
            return False
        return (leftpad(x,28)==leftpad('2299239925992999319932994099',28))
    @classmethod
    def is_valid_ACOCE(self,x):
        """Area Census Office Code"""
        if x is None or x == "None":
            return False
        return (between('2201',x,'22992301',8))
    @classmethod
    def is_valid_CFMCE(self,x):
        """Census Field Manager Area Code"""
        if x is None or x == "None":
            return False
        return (between('01',x,'99',8))
    @classmethod
    def is_valid_CFSCE(self,x):
        """Census Field Supervisor Area Code"""
        if x is None or x == "None":
            return False
        return (between('01',x,'99',8))
    @classmethod
    def is_valid_FLDOPCODE(self,x):
        """Operation Code for Field Division.This is required for all rows that are active for the delivery."""
        if x is None or x == "None":
            return False
        return (leftpad(x,8)==leftpad('01',8))
    @classmethod
    def is_valid_OPCODE(self,x):
        """Operation Code"""
        if x is None or x == "None":
            return False
        return (leftpad(x,72)==leftpad('200201202203204205206208210211212213300301302303304305306308310311312313',72))
    @classmethod
    def is_valid_TEA(self,x):
        """Type of Enumeration Area"""
        if x is None or x == "None":
            return False
        return (leftpad(x,8)==leftpad('123456',8))
    @classmethod
    def is_valid_AIANNHCE(self,x):
        """Census AI/AN/NH area code"""
        if x is None or x == "None":
            return False
        return True
    @classmethod
    def is_valid_MILITARYANSI(self,x):
        """Military ANSI Code (ANSI code is not available, but non-blank indicates a military block)"""
        if x is None or x == "None":
            return False
        return True
    @classmethod
    def is_valid_INTPTLON(self,x):
        """Internal Point Longitude"""
        if x is None or x == "None":
            return False
        return (between('-64.0000000',x,'-180.000000',12)) or (between('+179.9999999',x,'+131.0000000',12))
    @classmethod
    def is_valid_INTPTLAT(self,x):
        """Internal Point Latitude"""
        if x is None or x == "None":
            return False
        return (between('-15.0000000',x,'+72.0000000',11))
    @classmethod
    def is_valid_AREALAND(self,x):
        """Current Land Area"""
        if x is None or x == "None":
            return False
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return True
    @classmethod
    def is_valid_AREAWATER(self,x):
        """Current Water Area"""
        if x is None or x == "None":
            return False
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return True
    @classmethod
    def is_valid_HOUSING(self,x):
        """Provides the count, for this geographic area, of the actual number of valid decennial addresses that are being transmitted as part of this delivery includes housing units, group quarters, and transient locations."""
        if x is None or x == "None":
            return False
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return True
    @classmethod
    def is_valid_ADCNFLG(self,x):
        """Defines whether or not the BCU is in the In-Field Address Canvassing Operation"""
        if x is None or x == "None":
            return False
        return True
    @classmethod
    def is_valid_VINTAGE(self,x):
        """Vintage of the data"""
        if x is None or x == "None":
            return False
        return (leftpad(x,8)==leftpad('737290',8))
    @classmethod
    def is_valid_ISINSITE(self,x):
        """Defines whether or not the BCU is in the test area"""
        if x is None or x == "None":
            return False
        return True
    @classmethod
    def is_valid_ADCNACOCE(self,x):
        """Address Canvassing Area Census Office Code"""
        if x is None or x == "None":
            return False
        return True

    @classmethod
    def validate_pipe_delimited(self,x):
        fields = x.split('|')
        if len(fields)!=24: return False
        if self.is_valid_OIDBCU(fields[0]) == False: return False
        if self.is_valid_STATEFP(fields[1]) == False: return False
        if self.is_valid_COUNTYFP(fields[2]) == False: return False
        if self.is_valid_TRACTCE(fields[3]) == False: return False
        if self.is_valid_BCUID(fields[4]) == False: return False
        if self.is_valid_LWBCUTYP(fields[5]) == False: return False
        if self.is_valid_RCCCE(fields[6]) == False: return False
        if self.is_valid_ACOCE(fields[7]) == False: return False
        if self.is_valid_CFMCE(fields[8]) == False: return False
        if self.is_valid_CFSCE(fields[9]) == False: return False
        if self.is_valid_FLDOPCODE(fields[10]) == False: return False
        if self.is_valid_OPCODE(fields[11]) == False: return False
        if self.is_valid_TEA(fields[12]) == False: return False
        if self.is_valid_AIANNHCE(fields[13]) == False: return False
        if self.is_valid_MILITARYANSI(fields[14]) == False: return False
        if self.is_valid_INTPTLON(fields[15]) == False: return False
        if self.is_valid_INTPTLAT(fields[16]) == False: return False
        if self.is_valid_AREALAND(fields[17]) == False: return False
        if self.is_valid_AREAWATER(fields[18]) == False: return False
        if self.is_valid_HOUSING(fields[19]) == False: return False
        if self.is_valid_ADCNFLG(fields[20]) == False: return False
        if self.is_valid_VINTAGE(fields[21]) == False: return False
        if self.is_valid_ISINSITE(fields[22]) == False: return False
        if self.is_valid_ADCNACOCE(fields[23]) == False: return False
        return True

class I:
    __slots__ = ['OIDBCU', 'STATEFP', 'COUNTYFP', 'TRACTCE', 'BCUID', 'LWBCUTYP', 'RCCCE', 'ACOCE', 'CFMCE', 'CFSCE', 'FLDOPCODE', 'OPCODE', 'TEA', 'AIANNHCE', 'MILITARYANSI', 'INTPTLON', 'INTPTLAT', 'AREALAND', 'AREAWATER', 'HOUSING', 'ADCNFLG', 'VINTAGE', 'ISINSITE', 'ADCNACOCE']
    def __repr__(self):
        return 'I<OIDBCU:{},STATEFP:{},COUNTYFP:{},TRACTCE:{},BCUID:{},LWBCUTYP:{},RCCCE:{},ACOCE:{},CFMCE:{},CFSCE:{},FLDOPCODE:{},OPCODE:{},TEA:{},AIANNHCE:{},MILITARYANSI:{},INTPTLON:{},INTPTLAT:{},AREALAND:{},AREAWATER:{},HOUSING:{},ADCNFLG:{},VINTAGE:{},ISINSITE:{},ADCNACOCE:{}>'.format(self.OIDBCU,self.STATEFP,self.COUNTYFP,self.TRACTCE,self.BCUID,self.LWBCUTYP,self.RCCCE,self.ACOCE,self.CFMCE,self.CFSCE,self.FLDOPCODE,self.OPCODE,self.TEA,self.AIANNHCE,self.MILITARYANSI,self.INTPTLON,self.INTPTLAT,self.AREALAND,self.AREAWATER,self.HOUSING,self.ADCNFLG,self.VINTAGE,self.ISINSITE,self.ADCNACOCE)
    def __init__(self,line=None):
        if line:
            if '|' in line:
                self.parse_pipe_delimited(line)
            else:
                self.parse_column_specified(line)
    @classmethod
    def name(self):
        return 'I'

    def parse_pipe_delimited(self,line):
        fields = line.split('|')
        if len(fields)!=24:
            raise ValueError(f'expected 24 fields, found {len(fields)}')
        self.OIDBCU          = fields[0]  # Basic Collection Unit OID [PK/Unique within Nation]
        self.STATEFP         = fields[1]  # FIPS State Code
        self.COUNTYFP        = fields[2]  # FIPS County Code
        self.TRACTCE         = fields[3]  # Census Tract Code
        self.BCUID           = fields[4]  # Basic Collection Unit Identification Code
        self.LWBCUTYP        = fields[5]  # Land/Water BCU Type
        self.RCCCE           = fields[6]  # RCC Code
        self.ACOCE           = fields[7]  # Area Census Office Code
        self.CFMCE           = fields[8]  # Census Field Manager Area Code
        self.CFSCE           = fields[9]  # Census Field Supervisor Area Code
        self.FLDOPCODE       = fields[10]  # Operation Code for Field Division.This is required for all rows that are active for the delivery.
        self.OPCODE          = fields[11]  # Operation Code
        self.TEA             = fields[12]  # Type of Enumeration Area
        self.AIANNHCE        = fields[13]  # Census AI/AN/NH area code
        self.MILITARYANSI    = fields[14]  # Military ANSI Code (ANSI code is not available, but non-blank indicates a military block)
        self.INTPTLON        = fields[15]  # Internal Point Longitude
        self.INTPTLAT        = fields[16]  # Internal Point Latitude
        self.AREALAND        = fields[17]  # Current Land Area
        self.AREAWATER       = fields[18]  # Current Water Area
        self.HOUSING         = fields[19]  # Provides the count, for this geographic area, of the actual number of valid decennial addresses that are being transmitted as part of this delivery includes housing units, group quarters, and transient locations.
        self.ADCNFLG         = fields[20]  # Defines whether or not the BCU is in the In-Field Address Canvassing Operation
        self.VINTAGE         = fields[21]  # Vintage of the data
        self.ISINSITE        = fields[22]  # Defines whether or not the BCU is in the test area
        self.ADCNACOCE       = fields[23]  # Address Canvassing Area Census Office Code

    def parse_column_specified(self,line):
        self.OIDBCU          = None   # no column information for OIDBCU
        self.STATEFP         = None   # no column information for STATEFP
        self.COUNTYFP        = None   # no column information for COUNTYFP
        self.TRACTCE         = None   # no column information for TRACTCE
        self.BCUID           = None   # no column information for BCUID
        self.LWBCUTYP        = None   # no column information for LWBCUTYP
        self.RCCCE           = None   # no column information for RCCCE
        self.ACOCE           = None   # no column information for ACOCE
        self.CFMCE           = None   # no column information for CFMCE
        self.CFSCE           = None   # no column information for CFSCE
        self.FLDOPCODE       = None   # no column information for FLDOPCODE
        self.OPCODE          = None   # no column information for OPCODE
        self.TEA             = None   # no column information for TEA
        self.AIANNHCE        = None   # no column information for AIANNHCE
        self.MILITARYANSI    = None   # no column information for MILITARYANSI
        self.INTPTLON        = None   # no column information for INTPTLON
        self.INTPTLAT        = None   # no column information for INTPTLAT
        self.AREALAND        = None   # no column information for AREALAND
        self.AREAWATER       = None   # no column information for AREAWATER
        self.HOUSING         = None   # no column information for HOUSING
        self.ADCNFLG         = None   # no column information for ADCNFLG
        self.VINTAGE         = None   # no column information for VINTAGE
        self.ISINSITE        = None   # no column information for ISINSITE
        self.ADCNACOCE       = None   # no column information for ADCNACOCE

    def validate(self):
        """Return True if the object data validates"""
        if not I_validator.is_valid_OIDBCU(self.OIDBCU): return False
        if not I_validator.is_valid_STATEFP(self.STATEFP): return False
        if not I_validator.is_valid_COUNTYFP(self.COUNTYFP): return False
        if not I_validator.is_valid_TRACTCE(self.TRACTCE): return False
        if not I_validator.is_valid_BCUID(self.BCUID): return False
        if not I_validator.is_valid_LWBCUTYP(self.LWBCUTYP): return False
        if not I_validator.is_valid_RCCCE(self.RCCCE): return False
        if not I_validator.is_valid_ACOCE(self.ACOCE): return False
        if not I_validator.is_valid_CFMCE(self.CFMCE): return False
        if not I_validator.is_valid_CFSCE(self.CFSCE): return False
        if not I_validator.is_valid_FLDOPCODE(self.FLDOPCODE): return False
        if not I_validator.is_valid_OPCODE(self.OPCODE): return False
        if not I_validator.is_valid_TEA(self.TEA): return False
        if not I_validator.is_valid_AIANNHCE(self.AIANNHCE): return False
        if not I_validator.is_valid_MILITARYANSI(self.MILITARYANSI): return False
        if not I_validator.is_valid_INTPTLON(self.INTPTLON): return False
        if not I_validator.is_valid_INTPTLAT(self.INTPTLAT): return False
        if not I_validator.is_valid_AREALAND(self.AREALAND): return False
        if not I_validator.is_valid_AREAWATER(self.AREAWATER): return False
        if not I_validator.is_valid_HOUSING(self.HOUSING): return False
        if not I_validator.is_valid_ADCNFLG(self.ADCNFLG): return False
        if not I_validator.is_valid_VINTAGE(self.VINTAGE): return False
        if not I_validator.is_valid_ISINSITE(self.ISINSITE): return False
        if not I_validator.is_valid_ADCNACOCE(self.ADCNACOCE): return False
        return True

    def validate_reason(self):
        reason=[]
        if not I_validator.is_valid_OIDBCU(self.OIDBCU): reason.append('OIDBCU ('+str(self.OIDBCU)+') out of range ()')
        if not I_validator.is_valid_STATEFP(self.STATEFP): reason.append('STATEFP ('+str(self.STATEFP)+') out of range ()')
        if not I_validator.is_valid_COUNTYFP(self.COUNTYFP): reason.append('COUNTYFP ('+str(self.COUNTYFP)+') out of range ()')
        if not I_validator.is_valid_TRACTCE(self.TRACTCE): reason.append('TRACTCE ('+str(self.TRACTCE)+') out of range ()')
        if not I_validator.is_valid_BCUID(self.BCUID): reason.append('BCUID ('+str(self.BCUID)+') out of range ()')
        if not I_validator.is_valid_LWBCUTYP(self.LWBCUTYP): reason.append('LWBCUTYP ('+str(self.LWBCUTYP)+') out of range (L-L, W-W, B-B)')
        if not I_validator.is_valid_RCCCE(self.RCCCE): reason.append('RCCCE ('+str(self.RCCCE)+') out of range (2299239925992999319932994099-2299239925992999319932994099)')
        if not I_validator.is_valid_ACOCE(self.ACOCE): reason.append('ACOCE ('+str(self.ACOCE)+') out of range (2201-22992301)')
        if not I_validator.is_valid_CFMCE(self.CFMCE): reason.append('CFMCE ('+str(self.CFMCE)+') out of range (01-99)')
        if not I_validator.is_valid_CFSCE(self.CFSCE): reason.append('CFSCE ('+str(self.CFSCE)+') out of range (01-99)')
        if not I_validator.is_valid_FLDOPCODE(self.FLDOPCODE): reason.append('FLDOPCODE ('+str(self.FLDOPCODE)+') out of range (01-01)')
        if not I_validator.is_valid_OPCODE(self.OPCODE): reason.append('OPCODE ('+str(self.OPCODE)+') out of range (200201202203204205206208210211212213300301302303304305306308310311312313-200201202203204205206208210211212213300301302303304305306308310311312313)')
        if not I_validator.is_valid_TEA(self.TEA): reason.append('TEA ('+str(self.TEA)+') out of range (123456-123456)')
        if not I_validator.is_valid_AIANNHCE(self.AIANNHCE): reason.append('AIANNHCE ('+str(self.AIANNHCE)+') out of range ()')
        if not I_validator.is_valid_MILITARYANSI(self.MILITARYANSI): reason.append('MILITARYANSI ('+str(self.MILITARYANSI)+') out of range ()')
        if not I_validator.is_valid_INTPTLON(self.INTPTLON): reason.append('INTPTLON ('+str(self.INTPTLON)+') out of range (-64.0000000--180.000000, +179.9999999-+131.0000000)')
        if not I_validator.is_valid_INTPTLAT(self.INTPTLAT): reason.append('INTPTLAT ('+str(self.INTPTLAT)+') out of range (-15.0000000-+72.0000000)')
        if not I_validator.is_valid_AREALAND(self.AREALAND): reason.append('AREALAND ('+str(self.AREALAND)+') out of range ()')
        if not I_validator.is_valid_AREAWATER(self.AREAWATER): reason.append('AREAWATER ('+str(self.AREAWATER)+') out of range ()')
        if not I_validator.is_valid_HOUSING(self.HOUSING): reason.append('HOUSING ('+str(self.HOUSING)+') out of range ()')
        if not I_validator.is_valid_ADCNFLG(self.ADCNFLG): reason.append('ADCNFLG ('+str(self.ADCNFLG)+') out of range ()')
        if not I_validator.is_valid_VINTAGE(self.VINTAGE): reason.append('VINTAGE ('+str(self.VINTAGE)+') out of range (737290-737290)')
        if not I_validator.is_valid_ISINSITE(self.ISINSITE): reason.append('ISINSITE ('+str(self.ISINSITE)+') out of range ()')
        if not I_validator.is_valid_ADCNACOCE(self.ADCNACOCE): reason.append('ADCNACOCE ('+str(self.ADCNACOCE)+') out of range ()')
        return ', '.join(reason)

    def SparkSQLRow(self):
        """Return a SparkSQL Row object for this object."""
        from pyspark.sql import Row
        return Row(
            oidbcu=safe_int(self.OIDBCU),
            statefp=safe_str(self.STATEFP),
            countyfp=safe_str(self.COUNTYFP),
            tractce=safe_str(self.TRACTCE),
            bcuid=safe_str(self.BCUID),
            lwbcutyp=safe_str(self.LWBCUTYP),
            rccce=safe_str(self.RCCCE),
            acoce=safe_str(self.ACOCE),
            cfmce=safe_str(self.CFMCE),
            cfsce=safe_str(self.CFSCE),
            fldopcode=safe_str(self.FLDOPCODE),
            opcode=safe_str(self.OPCODE),
            tea=safe_str(self.TEA),
            aiannhce=safe_str(self.AIANNHCE),
            militaryansi=safe_str(self.MILITARYANSI),
            intptlon=safe_str(self.INTPTLON),
            intptlat=safe_str(self.INTPTLAT),
            arealand=safe_int(self.AREALAND),
            areawater=safe_int(self.AREAWATER),
            housing=safe_int(self.HOUSING),
            adcnflg=safe_str(self.ADCNFLG),
            vintage=safe_str(self.VINTAGE),
            isinsite=safe_str(self.ISINSITE),
            adcnacoce=safe_str(self.ADCNACOCE),
        )


    @staticmethod
    def parse_line(line):
        # Read a line and return it as a dictionary.
        inst: I = I()
        inst.parse_column_specified(line)
        assert inst.validate(), f'A line is invalid!! line: {line}, validate_reason: {inst.validate_reason()}'
        row = inst.SparkSQLRow()
        return row

    @staticmethod
    def parse_piped_line(line):
        # Read a pipe-delimited line and return it as a dictionary.
        inst: I = I()
        inst.parse_pipe_delimited(line)
        assert inst.validate(), f'A line is invalid!! line: {line}, validate_reason: {inst.validate_reason()}'
        row = inst.SparkSQLRow()
        return row



# Automatically generated on Fri Oct 30 14:06:06 2020 by /mnt/users/user007/new-das-vm/das-vm-config/das_decennial/das_framework/ctools/schema/table.py

def leftpad(x,width):
    return ' '*(width-len(str(x)))+str(x)

def between(a,b,c,width):
    if len(b) > width:
        return False
    if '.' in a or '.' in b or '.' in c:
        try:
            return float(a) <= float(b) <= float(c)
        except ValueError:
            pass  # tries to return a float but might have weird input like 1.1.0 which will be compared traditionally instead
    b = b.replace(' ', '0')
    return leftpad(a,width) <= leftpad(b,width) <= leftpad(c,width)


def safe_int(i):
    try:
        return int(i)
    except (TypeError, ValueError):
        return None

def safe_float(i):
    try:
        return float(i)
    except (TypeError, ValueError):
        return None

def safe_str(i):
    try:
        return str(i)
    except (TypeError, ValueError):
        return None


class G_validator:
    @classmethod
    def is_valid_OID(self,x):
        """Object ID"""
        if x is None or x == "None":
            return False
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return True
    @classmethod
    def is_valid_STATEFP(self,x):
        """FIPS State Code"""
        if x is None or x == "None":
            return False
        return True
    @classmethod
    def is_valid_COUNTYFP(self,x):
        """FIPS County Code"""
        if x is None or x == "None":
            return False
        return True
    @classmethod
    def is_valid_TRACTCE(self,x):
        """Census Tract Code"""
        if x is None or x == "None":
            return False
        return True
    @classmethod
    def is_valid_RCCCE(self,x):
        """RCC Code"""
        if x is None or x == "None":
            return False
        return (leftpad(x,28)==leftpad('2299239925992999319932994099',28))
    @classmethod
    def is_valid_ACOCE(self,x):
        """Area Census Office Code"""
        if x is None or x == "None":
            return False
        return (between('2201',x,'22992301',8))
    @classmethod
    def is_valid_CFMCE(self,x):
        """Census Field Manager Area Code"""
        if x is None or x == "None":
            return False
        return (between('01',x,'99',2))
    @classmethod
    def is_valid_CFSCE(self,x):
        """Census Field Supervisor Area Code"""
        if x is None or x == "None":
            return False
        return (between('01',x,'99',2))
    @classmethod
    def is_valid_NAME(self,x):
        """Name of RCC, ACO, ADCNACO, Tract, or County"""
        if x is None or x == "None":
            return False
        return True
    @classmethod
    def is_valid_FLDOPCODE(self,x):
        """Operation Code for Field Division.  This is required for all rows that are active for the delivery."""
        if x is None or x == "None":
            return False
        return (leftpad(x,42)==leftpad('010509131731323539454850535760677072778091',42))
    @classmethod
    def is_valid_OPCODE(self,x):
        """Operation Code"""
        if x is None or x == "None":
            return False
        return (leftpad(x,72)==leftpad('200201202203204205206208210211212213300301302303304305306308310311312313',72))
    @classmethod
    def is_valid_INTPTLON(self,x):
        """Internal Point Longitude"""
        if x is None or x == "None":
            return False
        return (between('-180.000000',x,'-64.0000000',12)) or (between('+131.0000000',x,'+179.9999999',12))
    @classmethod
    def is_valid_INTPTLAT(self,x):
        """Internal Point Latitude"""
        if x is None or x == "None":
            return False
        return (between('-15.0000000',x,'+72.0000000',11))
    @classmethod
    def is_valid_CENTLON(self,x):
        """Centroid Longitude"""
        if x is None or x == "None":
            return False
        return (between('-180.000000',x,'-64.0000000',12)) or (between('+131.0000000',x,'+179.9999999',12))
    @classmethod
    def is_valid_CENTLAT(self,x):
        """Centroid Latitude"""
        if x is None or x == "None":
            return False
        return (between('-15.0000000',x,'+72.0000000',11))
    @classmethod
    def is_valid_AREALAND(self,x):
        """Current Land Area Measured in square meters."""
        if x is None or x == "None":
            return False
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return True
    @classmethod
    def is_valid_AREAWATER(self,x):
        """Current Water Area Measured in square meters."""
        if x is None or x == "None":
            return False
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return True
    @classmethod
    def is_valid_HOUSING(self,x):
        """Provides the count, for this geographic area, of the actual number of valid decennial addresses that are being transmitted as part of this delivery includes housing units, group quarters, and transient locations."""
        if x is None or x == "None":
            return False
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return True
    @classmethod
    def is_valid_MTFCC(self,x):
        """MAF/TIGER Feature Classification Code"""
        if x is None or x == "None":
            return False
        return (leftpad(x,5)==leftpad('G8020',5))

    @classmethod
    def validate_pipe_delimited(self,x):
        fields = x.split('|')
        if len(fields)!=19: return False
        if self.is_valid_OID(fields[0]) == False: return False
        if self.is_valid_STATEFP(fields[1]) == False: return False
        if self.is_valid_COUNTYFP(fields[2]) == False: return False
        if self.is_valid_TRACTCE(fields[3]) == False: return False
        if self.is_valid_RCCCE(fields[4]) == False: return False
        if self.is_valid_ACOCE(fields[5]) == False: return False
        if self.is_valid_CFMCE(fields[6]) == False: return False
        if self.is_valid_CFSCE(fields[7]) == False: return False
        if self.is_valid_NAME(fields[8]) == False: return False
        if self.is_valid_FLDOPCODE(fields[9]) == False: return False
        if self.is_valid_OPCODE(fields[10]) == False: return False
        if self.is_valid_INTPTLON(fields[11]) == False: return False
        if self.is_valid_INTPTLAT(fields[12]) == False: return False
        if self.is_valid_CENTLON(fields[13]) == False: return False
        if self.is_valid_CENTLAT(fields[14]) == False: return False
        if self.is_valid_AREALAND(fields[15]) == False: return False
        if self.is_valid_AREAWATER(fields[16]) == False: return False
        if self.is_valid_HOUSING(fields[17]) == False: return False
        if self.is_valid_MTFCC(fields[18]) == False: return False
        return True

class G:
    __slots__ = ['OID', 'STATEFP', 'COUNTYFP', 'TRACTCE', 'RCCCE', 'ACOCE', 'CFMCE', 'CFSCE', 'NAME', 'FLDOPCODE', 'OPCODE', 'INTPTLON', 'INTPTLAT', 'CENTLON', 'CENTLAT', 'AREALAND', 'AREAWATER', 'HOUSING', 'MTFCC']
    def __repr__(self):
        return 'G<OID:{},STATEFP:{},COUNTYFP:{},TRACTCE:{},RCCCE:{},ACOCE:{},CFMCE:{},CFSCE:{},NAME:{},FLDOPCODE:{},OPCODE:{},INTPTLON:{},INTPTLAT:{},CENTLON:{},CENTLAT:{},AREALAND:{},AREAWATER:{},HOUSING:{},MTFCC:{}>'.format(self.OID,self.STATEFP,self.COUNTYFP,self.TRACTCE,self.RCCCE,self.ACOCE,self.CFMCE,self.CFSCE,self.NAME,self.FLDOPCODE,self.OPCODE,self.INTPTLON,self.INTPTLAT,self.CENTLON,self.CENTLAT,self.AREALAND,self.AREAWATER,self.HOUSING,self.MTFCC)
    def __init__(self,line=None):
        if line:
            if '|' in line:
                self.parse_pipe_delimited(line)
            else:
                self.parse_column_specified(line)
    @classmethod
    def name(self):
        return 'G'

    def parse_pipe_delimited(self,line):
        fields = line.split('|')
        if len(fields)!=19:
            raise ValueError(f'expected 19 fields, found {len(fields)}')
        self.OID             = fields[0]  # Object ID
        self.STATEFP         = fields[1]  # FIPS State Code
        self.COUNTYFP        = fields[2]  # FIPS County Code
        self.TRACTCE         = fields[3]  # Census Tract Code
        self.RCCCE           = fields[4]  # RCC Code
        self.ACOCE           = fields[5]  # Area Census Office Code
        self.CFMCE           = fields[6]  # Census Field Manager Area Code
        self.CFSCE           = fields[7]  # Census Field Supervisor Area Code
        self.NAME            = fields[8]  # Name of RCC, ACO, ADCNACO, Tract, or County
        self.FLDOPCODE       = fields[9]  # Operation Code for Field Division.  This is required for all rows that are active for the delivery.
        self.OPCODE          = fields[10]  # Operation Code
        self.INTPTLON        = fields[11]  # Internal Point Longitude
        self.INTPTLAT        = fields[12]  # Internal Point Latitude
        self.CENTLON         = fields[13]  # Centroid Longitude
        self.CENTLAT         = fields[14]  # Centroid Latitude
        self.AREALAND        = fields[15]  # Current Land Area Measured in square meters.
        self.AREAWATER       = fields[16]  # Current Water Area Measured in square meters.
        self.HOUSING         = fields[17]  # Provides the count, for this geographic area, of the actual number of valid decennial addresses that are being transmitted as part of this delivery includes housing units, group quarters, and transient locations.
        self.MTFCC           = fields[18]  # MAF/TIGER Feature Classification Code

    def parse_column_specified(self,line):
        self.OID             = line[0:22] # Object ID
        self.STATEFP         = line[1:3] # FIPS State Code
        self.COUNTYFP        = line[2:5] # FIPS County Code
        self.TRACTCE         = line[3:9] # Census Tract Code
        self.RCCCE           = line[4:32] # RCC Code
        self.ACOCE           = line[5:13] # Area Census Office Code
        self.CFMCE           = line[6:8] # Census Field Manager Area Code
        self.CFSCE           = line[7:9] # Census Field Supervisor Area Code
        self.NAME            = line[8:108] # Name of RCC, ACO, ADCNACO, Tract, or County
        self.FLDOPCODE       = line[9:51] # Operation Code for Field Division.  This is required for all rows that are active for the delivery.
        self.OPCODE          = line[10:82] # Operation Code
        self.INTPTLON        = line[11:23] # Internal Point Longitude
        self.INTPTLAT        = line[12:23] # Internal Point Latitude
        self.CENTLON         = line[13:25] # Centroid Longitude
        self.CENTLAT         = line[14:25] # Centroid Latitude
        self.AREALAND        = line[15:29] # Current Land Area Measured in square meters.
        self.AREAWATER       = line[16:30] # Current Water Area Measured in square meters.
        self.HOUSING         = line[17:26] # Provides the count, for this geographic area, of the actual number of valid decennial addresses that are being transmitted as part of this delivery includes housing units, group quarters, and transient locations.
        self.MTFCC           = line[18:23] # MAF/TIGER Feature Classification Code

    def validate(self):
        """Return True if the object data validates"""
        if not G_validator.is_valid_OID(self.OID): return False
        if not G_validator.is_valid_STATEFP(self.STATEFP): return False
        if not G_validator.is_valid_COUNTYFP(self.COUNTYFP): return False
        if not G_validator.is_valid_TRACTCE(self.TRACTCE): return False
        if not G_validator.is_valid_RCCCE(self.RCCCE): return False
        if not G_validator.is_valid_ACOCE(self.ACOCE): return False
        if not G_validator.is_valid_CFMCE(self.CFMCE): return False
        if not G_validator.is_valid_CFSCE(self.CFSCE): return False
        if not G_validator.is_valid_NAME(self.NAME): return False
        if not G_validator.is_valid_FLDOPCODE(self.FLDOPCODE): return False
        if not G_validator.is_valid_OPCODE(self.OPCODE): return False
        if not G_validator.is_valid_INTPTLON(self.INTPTLON): return False
        if not G_validator.is_valid_INTPTLAT(self.INTPTLAT): return False
        if not G_validator.is_valid_CENTLON(self.CENTLON): return False
        if not G_validator.is_valid_CENTLAT(self.CENTLAT): return False
        if not G_validator.is_valid_AREALAND(self.AREALAND): return False
        if not G_validator.is_valid_AREAWATER(self.AREAWATER): return False
        if not G_validator.is_valid_HOUSING(self.HOUSING): return False
        if not G_validator.is_valid_MTFCC(self.MTFCC): return False
        return True

    def validate_reason(self):
        reason=[]
        if not G_validator.is_valid_OID(self.OID): reason.append('OID ('+str(self.OID)+') out of range ()')
        if not G_validator.is_valid_STATEFP(self.STATEFP): reason.append('STATEFP ('+str(self.STATEFP)+') out of range ()')
        if not G_validator.is_valid_COUNTYFP(self.COUNTYFP): reason.append('COUNTYFP ('+str(self.COUNTYFP)+') out of range ()')
        if not G_validator.is_valid_TRACTCE(self.TRACTCE): reason.append('TRACTCE ('+str(self.TRACTCE)+') out of range ()')
        if not G_validator.is_valid_RCCCE(self.RCCCE): reason.append('RCCCE ('+str(self.RCCCE)+') out of range (2299239925992999319932994099-2299239925992999319932994099)')
        if not G_validator.is_valid_ACOCE(self.ACOCE): reason.append('ACOCE ('+str(self.ACOCE)+') out of range (2201-22992301)')
        if not G_validator.is_valid_CFMCE(self.CFMCE): reason.append('CFMCE ('+str(self.CFMCE)+') out of range (01-99)')
        if not G_validator.is_valid_CFSCE(self.CFSCE): reason.append('CFSCE ('+str(self.CFSCE)+') out of range (01-99)')
        if not G_validator.is_valid_NAME(self.NAME): reason.append('NAME ('+str(self.NAME)+') out of range ()')
        if not G_validator.is_valid_FLDOPCODE(self.FLDOPCODE): reason.append('FLDOPCODE ('+str(self.FLDOPCODE)+') out of range (010509131731323539454850535760677072778091-010509131731323539454850535760677072778091)')
        if not G_validator.is_valid_OPCODE(self.OPCODE): reason.append('OPCODE ('+str(self.OPCODE)+') out of range (200201202203204205206208210211212213300301302303304305306308310311312313-200201202203204205206208210211212213300301302303304305306308310311312313)')
        if not G_validator.is_valid_INTPTLON(self.INTPTLON): reason.append('INTPTLON ('+str(self.INTPTLON)+') out of range (-180.000000--64.0000000, +131.0000000-+179.9999999)')
        if not G_validator.is_valid_INTPTLAT(self.INTPTLAT): reason.append('INTPTLAT ('+str(self.INTPTLAT)+') out of range (-15.0000000-+72.0000000)')
        if not G_validator.is_valid_CENTLON(self.CENTLON): reason.append('CENTLON ('+str(self.CENTLON)+') out of range (-180.000000--64.0000000, +131.0000000-+179.9999999)')
        if not G_validator.is_valid_CENTLAT(self.CENTLAT): reason.append('CENTLAT ('+str(self.CENTLAT)+') out of range (-15.0000000-+72.0000000)')
        if not G_validator.is_valid_AREALAND(self.AREALAND): reason.append('AREALAND ('+str(self.AREALAND)+') out of range ()')
        if not G_validator.is_valid_AREAWATER(self.AREAWATER): reason.append('AREAWATER ('+str(self.AREAWATER)+') out of range ()')
        if not G_validator.is_valid_HOUSING(self.HOUSING): reason.append('HOUSING ('+str(self.HOUSING)+') out of range ()')
        if not G_validator.is_valid_MTFCC(self.MTFCC): reason.append('MTFCC ('+str(self.MTFCC)+') out of range (G8020-G8020)')
        return ', '.join(reason)

    def SparkSQLRow(self):
        """Return a SparkSQL Row object for this object."""
        from pyspark.sql import Row
        return Row(
            oid=safe_int(self.OID),
            statefp=safe_str(self.STATEFP),
            countyfp=safe_str(self.COUNTYFP),
            tractce=safe_str(self.TRACTCE),
            rccce=safe_str(self.RCCCE),
            acoce=safe_str(self.ACOCE),
            cfmce=safe_str(self.CFMCE),
            cfsce=safe_str(self.CFSCE),
            name=safe_str(self.NAME),
            fldopcode=safe_str(self.FLDOPCODE),
            opcode=safe_str(self.OPCODE),
            intptlon=safe_str(self.INTPTLON),
            intptlat=safe_str(self.INTPTLAT),
            centlon=safe_str(self.CENTLON),
            centlat=safe_str(self.CENTLAT),
            arealand=safe_int(self.AREALAND),
            areawater=safe_int(self.AREAWATER),
            housing=safe_int(self.HOUSING),
            mtfcc=safe_str(self.MTFCC),
        )


    @staticmethod
    def parse_line(line):
        # Read a line and return it as a dictionary.
        inst: G = G()
        inst.parse_column_specified(line)
        assert inst.validate(), f'A line is invalid!! line: {line}, validate_reason: {inst.validate_reason()}'
        row = inst.SparkSQLRow()
        return row

    @staticmethod
    def parse_piped_line(line):
        # Read a pipe-delimited line and return it as a dictionary.
        inst: G = G()
        inst.parse_pipe_delimited(line)
        assert inst.validate(), f'A line is invalid!! line: {line}, validate_reason: {inst.validate_reason()}'
        row = inst.SparkSQLRow()
        return row



# Automatically generated on Fri Oct 30 14:06:06 2020 by /mnt/users/user007/new-das-vm/das-vm-config/das_decennial/das_framework/ctools/schema/table.py

def leftpad(x,width):
    return ' '*(width-len(str(x)))+str(x)

def between(a,b,c,width):
    if len(b) > width:
        return False
    if '.' in a or '.' in b or '.' in c:
        try:
            return float(a) <= float(b) <= float(c)
        except ValueError:
            pass  # tries to return a float but might have weird input like 1.1.0 which will be compared traditionally instead
    b = b.replace(' ', '0')
    return leftpad(a,width) <= leftpad(b,width) <= leftpad(c,width)


def safe_int(i):
    try:
        return int(i)
    except (TypeError, ValueError):
        return None

def safe_float(i):
    try:
        return float(i)
    except (TypeError, ValueError):
        return None

def safe_str(i):
    try:
        return str(i)
    except (TypeError, ValueError):
        return None


class GRFC20_validator:
    @classmethod
    def is_valid_TABBLKST(self,x):
        """2020 Tabulation State (FIPS)"""
        if x is None or x == "None":
            return False
        return (leftpad(x,2)==leftpad('66',2)) or (leftpad(x,2)==leftpad('60',2)) or (between('44',x,'51',2)) or (leftpad(x,2)==leftpad('72',2)) or (between('01',x,'02',2)) or (leftpad(x,2)==leftpad('78',2)) or (leftpad(x,2)==leftpad('69',2)) or (between('08',x,'13',2)) or (between('15',x,'42',2)) or (between('04',x,'06',2)) or (between('53',x,'56',2))
    @classmethod
    def is_valid_TABBLKCOU(self,x):
        """2020 Tabulation County (FIPS)"""
        if x is None or x == "None":
            return False
        return (between('001',x,'840',3))
    @classmethod
    def is_valid_TABTRACTCE(self,x):
        """2020 Tabulation Census Tract"""
        if x is None or x == "None":
            return False
        return (between('000100',x,'998999',6))
    @classmethod
    def is_valid_TABBLK(self,x):
        """2020 Block Number"""
        if x is None or x == "None":
            return False
        return (between('0001',x,'9999',4))
    @classmethod
    def is_valid_TABBLKSUFX1(self,x):
        """2020 Block Suffix 1 (Current Block Suffix)"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (between('A',x,'Z',1))
    @classmethod
    def is_valid_TABBLKSUFX2(self,x):
        """2020 Block Suffix 2"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (between('A',x,'Z',1))
    @classmethod
    def is_valid_TABBLKGRPCE(self,x):
        """2020 Census Block Group"""
        if x is None or x == "None":
            return False
        return (between('0',x,'9',1))
    @classmethod
    def is_valid_POPDEC(self,x):
        """2020 Population"""
        if x is None or x == "None" or len(x) == 0:
            return True
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return (000000000 <= x <= 999999999)
    @classmethod
    def is_valid_HOUSING(self,x):
        """2020 Housing Unit Count"""
        if x is None or x == "None" or len(x) == 0:
            return True
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return True
    @classmethod
    def is_valid_CURSTATE(self,x):
        """Current State (FIPS)"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_CURCOUNTY(self,x):
        """Current County (FIPS)"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_CURTRACTCE(self,x):
        """Current Census Tract"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_CURBLKGRPCE(self,x):
        """Current Block Group"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_REGIONCE(self,x):
        """Census Region"""
        if x is None or x == "None":
            return False
        return (between('1',x,'4',1)) or (leftpad(x,1)==leftpad('9',1))
    @classmethod
    def is_valid_DIVISIONCE(self,x):
        """Census Division"""
        if x is None or x == "None":
            return False
        return (between('0',x,'9',1))
    @classmethod
    def is_valid_STATENS(self,x):
        """State (National Standard)"""
        if x is None or x == "None":
            return False
        return (between('00000001',x,'99999998',8))
    @classmethod
    def is_valid_COUNTYNS(self,x):
        """County (National Standard)"""
        if x is None or x == "None":
            return False
        return (between('00000001',x,'99999998',8))
    @classmethod
    def is_valid_COUNTYFS(self,x):
        """County Functional Status"""
        if x is None or x == "None":
            return False
        return (leftpad(x,1)==leftpad('F',1)) or (leftpad(x,1)==leftpad('G',1)) or (leftpad(x,1)==leftpad('B',1)) or (leftpad(x,1)==leftpad('A',1)) or (leftpad(x,1)==leftpad('N',1)) or (leftpad(x,1)==leftpad('S',1)) or (leftpad(x,1)==leftpad('C',1))
    @classmethod
    def is_valid_COUSUBFP(self,x):
        """County Subdivision (FIPS)"""
        if x is None or x == "None":
            return False
        return (between('00000',x,'98999',5))
    @classmethod
    def is_valid_COUSUBNS(self,x):
        """County Subdivision (National Standard)"""
        if x is None or x == "None":
            return False
        return (between('00000000',x,'99999998',8))
    @classmethod
    def is_valid_SUBMCDFP(self,x):
        """Subminor Civil Division (FIPS)"""
        if x is None or x == "None":
            return False
        return (leftpad(x,5)==leftpad('99999',5)) or (between('00001',x,'89999',5))
    @classmethod
    def is_valid_SUBMCDNS(self,x):
        """Subminor Civil Division (National Standard)"""
        if x is None or x == "None":
            return False
        return (between('00000001',x,'99999998',8)) or (leftpad(x,8)==leftpad('99999999',8))
    @classmethod
    def is_valid_ESTATEFP(self,x):
        """Estate (FIPS)"""
        return (leftpad(x,5)==leftpad('99999',5)) or (between('00001',x,'89999',5)) or (x is None) or (x == "None") or (x == "")
    @classmethod
    def is_valid_ESTATENS(self,x):
        """Estate (National Standard)"""
        return (between('00000001',x,'99999998',8)) or (leftpad(x,8)==leftpad('99999999',8)) or (x is None) or (x == "None") or (x == "")
    @classmethod
    def is_valid_CONCITFP(self,x):
        """Consolidated City (FIPS)"""
        if x is None or x == "None":
            return False
        return (leftpad(x,5)==leftpad('99999',5)) or (between('00001',x,'89999',5))
    @classmethod
    def is_valid_CONCITNS(self,x):
        """Consolidated City (National Standard)"""
        if x is None or x == "None":
            return False
        return (between('00000001',x,'99999998',8)) or (leftpad(x,8)==leftpad('99999999',8))
    @classmethod
    def is_valid_PLACEFP(self,x):
        """Place (FIPS)"""
        if x is None or x == "None":
            return False
        return (leftpad(x,5)==leftpad('99999',5)) or (between('00001',x,'89999',5))
    @classmethod
    def is_valid_PLACENS(self,x):
        """Place (National Standard)"""
        if x is None or x == "None":
            return False
        return (between('00000001',x,'99999998',8)) or (leftpad(x,8)==leftpad('99999999',8))
    @classmethod
    def is_valid_PLACEFS(self,x):
        """Place Functional Status"""
        if x is None or x == "None":
            return False
        return (leftpad(x,1)==leftpad('F',1)) or (leftpad(x,1)==leftpad('I',1)) or (leftpad(x,1)==leftpad('N',1)) or (leftpad(x,1)==leftpad('B',1)) or (leftpad(x,1)==leftpad('A',1)) or (leftpad(x,1)==leftpad('S',1)) or (leftpad(x,1)==leftpad('9',1))
    @classmethod
    def is_valid_AIANNHFP(self,x):
        """AIANNH (FIPS)"""
        if x is None or x == "None":
            return False
        return (leftpad(x,5)==leftpad('99999',5)) or (between('00001',x,'89999',5))
    @classmethod
    def is_valid_AIANNHCE(self,x):
        """AIANNH (Census)"""
        if x is None or x == "None":
            return False
        return (between('00001',x,'9998',4)) or (leftpad(x,4)==leftpad('9999',4))
    @classmethod
    def is_valid_AIANNHNS(self,x):
        """AIANNH (National Standard)"""
        if x is None or x == "None":
            return False
        return (between('00000001',x,'99999998',8)) or (leftpad(x,8)==leftpad('99999999',8))
    @classmethod
    def is_valid_AIHHTLI(self,x):
        """American Indian/Hawaiian Home Land Trust Land Indicator"""
        if x is None or x == "None":
            return False
        return (leftpad(x,1)==leftpad('9',1)) or (leftpad(x,1)==leftpad('R',1)) or (leftpad(x,1)==leftpad('T',1))
    @classmethod
    def is_valid_TRIBALSUBFP(self,x):
        """American Indian Tribal Subdivision (FIPS)"""
        if x is None or x == "None":
            return False
        return (leftpad(x,5)==leftpad('99999',5)) or (between('00001',x,'89999',5))
    @classmethod
    def is_valid_TRIBALSUBCE(self,x):
        """American Indian Tribal Subdivision (Census)"""
        if x is None or x == "None":
            return False
        return (leftpad(x,3)==leftpad('999',3)) or (between('001',x,'998',3))
    @classmethod
    def is_valid_TRIBALSUBNS(self,x):
        """American Indian Tribal Subdivision (National Standard)"""
        if x is None or x == "None":
            return False
        return (between('00000001',x,'99999998',8)) or (leftpad(x,8)==leftpad('99999999',8))
    @classmethod
    def is_valid_TTRACTCE(self,x):
        """American Indian Tribal Tract"""
        if x is None or x == "None":
            return False
        return (between('T00100',x,'T98999',6)) or (leftpad(x,6)==leftpad('999999',6))
    @classmethod
    def is_valid_TBLKGRPCE(self,x):
        """American Indian Tribal Block Group"""
        if x is None or x == "None":
            return False
        return (leftpad(x,1)==leftpad('K',1)) or (leftpad(x,1)==leftpad('9',1)) or (leftpad(x,1)==leftpad('J',1)) or (between('A',x,'H',1))
    @classmethod
    def is_valid_ANRCFP(self,x):
        """Alaska Native Regional Corporation (FIPS)"""
        if x is None or x == "None":
            return False
        return (leftpad(x,5)==leftpad('17140',5)) or (leftpad(x,5)==leftpad('00590',5)) or (leftpad(x,5)==leftpad('09040',5)) or (leftpad(x,5)==leftpad('03950',5)) or (leftpad(x,5)==leftpad('14410',5)) or (leftpad(x,5)==leftpad('20010',5)) or (leftpad(x,5)==leftpad('41640',5)) or (leftpad(x,5)==leftpad('01570',5)) or (leftpad(x,5)==leftpad('06370',5)) or (leftpad(x,5)==leftpad('52120',5)) or (leftpad(x,5)==leftpad('67940',5)) or (leftpad(x,5)==leftpad('99999',5)) or (leftpad(x,5)==leftpad('09800',5))
    @classmethod
    def is_valid_ANRCNS(self,x):
        """Alaska Native Regional Corporation (National Standard)"""
        if x is None or x == "None":
            return False
        return (between('00000001',x,'99999998',8)) or (leftpad(x,8)==leftpad('99999999',8))
    @classmethod
    def is_valid_UACE(self,x):
        """Urban Area"""
        if x is None or x == "None":
            return False
        return (between('00001',x,'98999',5)) or (leftpad(x,5)==leftpad('!!!!!',5)) or (leftpad(x,5)==leftpad('99999',5))
    @classmethod
    def is_valid_UATYP(self,x):
        """Urban Area Type"""
        if x is None or x == "None":
            return False
        return (leftpad(x,1)==leftpad('U',1)) or (leftpad(x,1)==leftpad('!',1)) or (leftpad(x,1)==leftpad('9',1)) or (leftpad(x,1)==leftpad('C',1))
    @classmethod
    def is_valid_UR(self,x):
        """Urban/Rural"""
        if x is None or x == "None":
            return False
        return (leftpad(x,1)==leftpad('U',1)) or (leftpad(x,1)==leftpad('R',1)) or (leftpad(x,1)==leftpad('!',1))
    @classmethod
    def is_valid_CD116FP(self,x):
        """Congressional District (Decennial)"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (between('00',x,'53',2)) or (leftpad(x,2)==leftpad('ZZ',2)) or (leftpad(x,2)==leftpad('98',2)) or (leftpad(x,2)==leftpad('99',2))
    @classmethod
    def is_valid_CDCURFP(self,x):
        """Congressional District (Current)"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_VTDST(self,x):
        """Voting District"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (between('      ',x,'zzzzzz',6)) or (leftpad(x,6)==leftpad('ZZZZZZ',6))
    @classmethod
    def is_valid_SLDUST(self,x):
        """State Legislative District (Upper Chamber)"""
        if x is None or x == "None":
            return False
        return (between('   ',x,'zzz',3)) or (leftpad(x,3)==leftpad('999',3)) or (leftpad(x,3)==leftpad('ZZZ',3))
    @classmethod
    def is_valid_SLDLST(self,x):
        """State Legislative District (Lower Chamber)"""
        if x is None or x == "None":
            return False
        return (between('   ',x,'zzz',3)) or (leftpad(x,3)==leftpad('999',3)) or (leftpad(x,3)==leftpad('ZZZ',3))
    @classmethod
    def is_valid_ZCTA5CE(self,x):
        """ZIP Code Tabulation Area (5-Digit)"""
        if x is None or x == "None":
            return False
        return (leftpad(x,5)==leftpad('!!!!!',5)) or (between('00601',x,'99929',5)) or (leftpad(x,5)==leftpad('00000',5)) or (leftpad(x,5)==leftpad('99999',5))
    @classmethod
    def is_valid_SDELMLEA(self,x):
        """School District (Elementary)"""
        if x is None or x == "None":
            return False
        return (between('00001',x,'99996',5)) or (leftpad(x,5)==leftpad('99999',5))
    @classmethod
    def is_valid_SDSECLEA(self,x):
        """School District (Secondary)"""
        if x is None or x == "None":
            return False
        return (between('00001',x,'99996',5)) or (leftpad(x,5)==leftpad('99999',5))
    @classmethod
    def is_valid_SDUNILEA(self,x):
        """School District (Unified)"""
        if x is None or x == "None":
            return False
        return (between('00001',x,'99998',5)) or (leftpad(x,5)==leftpad('99999',5))
    @classmethod
    def is_valid_UGACE(self,x):
        """Urban Growth Area"""
        if x is None or x == "None":
            return False
        return (leftpad(x,5)==leftpad('99999',5)) or (between('00001',x,'89999',5))
    @classmethod
    def is_valid_PUMA(self,x):
        """Public Use Microdata Area"""
        if x is None or x == "None":
            return False
        return (between('00001',x,'99998',5)) or (leftpad(x,5)==leftpad('!!!!!',5)) or (leftpad(x,5)==leftpad('99999',5))
    @classmethod
    def is_valid_LWBLKTYP(self,x):
        """Block Type"""
        if x is None or x == "None":
            return False
        return (leftpad(x,1)==leftpad('W',1)) or (leftpad(x,1)==leftpad('L',1)) or (leftpad(x,1)==leftpad('B',1))
    @classmethod
    def is_valid_INTPTLAT(self,x):
        """Internal Point (Latitude)"""
        if x is None or x == "None":
            return False
        return (between('-15.0000000',x,'+72.0000000',11))
    @classmethod
    def is_valid_INTPTLON(self,x):
        """Internal Point (Longitude)"""
        if x is None or x == "None":
            return False
        return (between('-180.000000',x,'-64.0000000',12)) or (between('+131.0000000',x,'+179.9999999',12))
    @classmethod
    def is_valid_AREALAND(self,x):
        """Area (Land)"""
        if x is None or x == "None":
            return False
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return (00000000000000 <= x <= 99999999999999)
    @classmethod
    def is_valid_AREAWATER(self,x):
        """Area (Water)"""
        if x is None or x == "None":
            return False
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return (00000000000000 <= x <= 99999999999999)
    @classmethod
    def is_valid_AREAWATERINLD(self,x):
        """Area (Water-Inland)"""
        if x is None or x == "None":
            return False
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return (00000000000000 <= x <= 99999999999999)
    @classmethod
    def is_valid_AREAWATERCSTL(self,x):
        """Area (Water-Coastal)"""
        if x is None or x == "None":
            return False
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return (00000000000000 <= x <= 99999999999999)
    @classmethod
    def is_valid_AREAWATERGRLK(self,x):
        """Area (Water-Great Lakes)"""
        if x is None or x == "None":
            return False
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return (00000000000000 <= x <= 99999999999999)
    @classmethod
    def is_valid_AREAWATERTSEA(self,x):
        """Area (Water-Territorial Sea)"""
        if x is None or x == "None":
            return False
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return (00000000000000 <= x <= 99999999999999)
    @classmethod
    def is_valid_CSAFP(self,x):
        """Combined Statistical Area"""
        if x is None or x == "None":
            return False
        return (between('100',x,'599',3)) or (leftpad(x,3)==leftpad('999',3))
    @classmethod
    def is_valid_CBSAFP(self,x):
        """Metropolitan and Micropolitan Statistical Area"""
        if x is None or x == "None":
            return False
        return (between('10000',x,'49999',5)) or (leftpad(x,5)==leftpad('99999',5))
    @classmethod
    def is_valid_METDIVFP(self,x):
        """Metropolitan Division"""
        if x is None or x == "None":
            return False
        return (between('10004',x,'49994',5)) or (leftpad(x,5)==leftpad('99999',5))
    @classmethod
    def is_valid_PCICBSA(self,x):
        """CBSA Principal City Indicator"""
        if x is None or x == "None":
            return False
        return (leftpad(x,1)==leftpad('9',1)) or (leftpad(x,1)==leftpad('Y',1)) or (leftpad(x,1)==leftpad('N',1))
    @classmethod
    def is_valid_CNECTAFP(self,x):
        """New England City and Town Combined Statistical Area"""
        if x is None or x == "None":
            return False
        return (between('700',x,'799',3)) or (leftpad(x,3)==leftpad('999',3))
    @classmethod
    def is_valid_NECTAFP(self,x):
        """New England City and Town Area"""
        if x is None or x == "None":
            return False
        return (between('70000',x,'79999',5)) or (leftpad(x,5)==leftpad('99999',5))
    @classmethod
    def is_valid_NECTADIVFP(self,x):
        """New England City and Town Area Division"""
        if x is None or x == "None":
            return False
        return (between('70004',x,'79994',5)) or (leftpad(x,5)==leftpad('99999',5))
    @classmethod
    def is_valid_PCINECTA(self,x):
        """NECTA Principal City Indicator"""
        if x is None or x == "None":
            return False
        return (leftpad(x,1)==leftpad('9',1)) or (leftpad(x,1)==leftpad('Y',1)) or (leftpad(x,1)==leftpad('N',1))
    @classmethod
    def is_valid_ACT(self,x):
        """Address Stringistic Type"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,2)==leftpad('P3',2)) or (leftpad(x,2)==leftpad('P1',2)) or (leftpad(x,2)==leftpad('D1',2)) or (leftpad(x,2)==leftpad('MC',2)) or (leftpad(x,2)==leftpad('C2',2)) or (leftpad(x,2)==leftpad('R1',2)) or (leftpad(x,2)==leftpad('B3',2)) or (leftpad(x,2)==leftpad('N1',2)) or (leftpad(x,2)==leftpad('C3',2)) or (leftpad(x,2)==leftpad('P2',2)) or (leftpad(x,2)==leftpad('MA',2)) or (leftpad(x,2)==leftpad('D2',2)) or (leftpad(x,2)==leftpad('M3',2)) or (leftpad(x,2)==leftpad('B1',2)) or (leftpad(x,2)==leftpad('ME',2)) or (leftpad(x,2)==leftpad('MB',2)) or (leftpad(x,2)==leftpad('N3',2)) or (leftpad(x,2)==leftpad('R2',2)) or (leftpad(x,2)==leftpad('B2',2)) or (leftpad(x,2)==leftpad('D3',2)) or (leftpad(x,2)==leftpad('MF',2)) or (leftpad(x,2)==leftpad('N2',2)) or (leftpad(x,2)==leftpad('M1',2)) or (leftpad(x,2)==leftpad('MG',2)) or (leftpad(x,2)==leftpad('Z0',2)) or (leftpad(x,2)==leftpad('MD',2)) or (leftpad(x,2)==leftpad('C1',2)) or (leftpad(x,2)==leftpad('R3',2))
    @classmethod
    def is_valid_MEMI(self,x):
        """CBSA Metropolitan/Micropolitan Status Indicator"""
        if x is None or x == "None":
            return False
        return (leftpad(x,1)==leftpad('2',1)) or (leftpad(x,1)==leftpad('9',1)) or (leftpad(x,1)==leftpad('1',1))
    @classmethod
    def is_valid_NMEMI(self,x):
        """NECTA Metropolitan/Micropolitan Status Indicator"""
        if x is None or x == "None":
            return False
        return (leftpad(x,1)==leftpad('2',1)) or (leftpad(x,1)==leftpad('9',1)) or (leftpad(x,1)==leftpad('1',1))
    @classmethod
    def is_valid_OIDTABBLK(self,x):
        """Tabulation Block Object ID"""
        if x is None or x == "None" or len(x) == 0:
            return True
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return (1 <= x <= 9999999999999999999999)

    @classmethod
    def validate_pipe_delimited(self,x):
        fields = x.split('|')
        if len(fields)!=76: return False
        if self.is_valid_TABBLKST(fields[0]) == False: return False
        if self.is_valid_TABBLKCOU(fields[1]) == False: return False
        if self.is_valid_TABTRACTCE(fields[2]) == False: return False
        if self.is_valid_TABBLK(fields[3]) == False: return False
        if self.is_valid_TABBLKSUFX1(fields[4]) == False: return False
        if self.is_valid_TABBLKSUFX2(fields[5]) == False: return False
        if self.is_valid_TABBLKGRPCE(fields[6]) == False: return False
        if self.is_valid_POPDEC(fields[7]) == False: return False
        if self.is_valid_HOUSING(fields[8]) == False: return False
        if self.is_valid_CURSTATE(fields[9]) == False: return False
        if self.is_valid_CURCOUNTY(fields[10]) == False: return False
        if self.is_valid_CURTRACTCE(fields[11]) == False: return False
        if self.is_valid_CURBLKGRPCE(fields[12]) == False: return False
        if self.is_valid_REGIONCE(fields[13]) == False: return False
        if self.is_valid_DIVISIONCE(fields[14]) == False: return False
        if self.is_valid_STATENS(fields[15]) == False: return False
        if self.is_valid_COUNTYNS(fields[16]) == False: return False
        if self.is_valid_COUNTYFS(fields[17]) == False: return False
        if self.is_valid_COUSUBFP(fields[18]) == False: return False
        if self.is_valid_COUSUBNS(fields[19]) == False: return False
        if self.is_valid_SUBMCDFP(fields[20]) == False: return False
        if self.is_valid_SUBMCDNS(fields[21]) == False: return False
        if self.is_valid_ESTATEFP(fields[22]) == False: return False
        if self.is_valid_ESTATENS(fields[23]) == False: return False
        if self.is_valid_CONCITFP(fields[24]) == False: return False
        if self.is_valid_CONCITNS(fields[25]) == False: return False
        if self.is_valid_PLACEFP(fields[26]) == False: return False
        if self.is_valid_PLACENS(fields[27]) == False: return False
        if self.is_valid_PLACEFS(fields[28]) == False: return False
        if self.is_valid_AIANNHFP(fields[29]) == False: return False
        if self.is_valid_AIANNHCE(fields[30]) == False: return False
        if self.is_valid_AIANNHNS(fields[31]) == False: return False
        if self.is_valid_AIHHTLI(fields[32]) == False: return False
        if self.is_valid_TRIBALSUBFP(fields[33]) == False: return False
        if self.is_valid_TRIBALSUBCE(fields[34]) == False: return False
        if self.is_valid_TRIBALSUBNS(fields[35]) == False: return False
        if self.is_valid_TTRACTCE(fields[36]) == False: return False
        if self.is_valid_TBLKGRPCE(fields[37]) == False: return False
        if self.is_valid_ANRCFP(fields[38]) == False: return False
        if self.is_valid_ANRCNS(fields[39]) == False: return False
        if self.is_valid_UACE(fields[40]) == False: return False
        if self.is_valid_UATYP(fields[41]) == False: return False
        if self.is_valid_UR(fields[42]) == False: return False
        if self.is_valid_CD116FP(fields[43]) == False: return False
        if self.is_valid_CDCURFP(fields[44]) == False: return False
        if self.is_valid_VTDST(fields[45]) == False: return False
        if self.is_valid_SLDUST(fields[46]) == False: return False
        if self.is_valid_SLDLST(fields[47]) == False: return False
        if self.is_valid_ZCTA5CE(fields[48]) == False: return False
        if self.is_valid_SDELMLEA(fields[49]) == False: return False
        if self.is_valid_SDSECLEA(fields[50]) == False: return False
        if self.is_valid_SDUNILEA(fields[51]) == False: return False
        if self.is_valid_UGACE(fields[52]) == False: return False
        if self.is_valid_PUMA(fields[53]) == False: return False
        if self.is_valid_LWBLKTYP(fields[54]) == False: return False
        if self.is_valid_INTPTLAT(fields[55]) == False: return False
        if self.is_valid_INTPTLON(fields[56]) == False: return False
        if self.is_valid_AREALAND(fields[57]) == False: return False
        if self.is_valid_AREAWATER(fields[58]) == False: return False
        if self.is_valid_AREAWATERINLD(fields[59]) == False: return False
        if self.is_valid_AREAWATERCSTL(fields[60]) == False: return False
        if self.is_valid_AREAWATERGRLK(fields[61]) == False: return False
        if self.is_valid_AREAWATERTSEA(fields[62]) == False: return False
        if self.is_valid_CSAFP(fields[63]) == False: return False
        if self.is_valid_CBSAFP(fields[64]) == False: return False
        if self.is_valid_METDIVFP(fields[65]) == False: return False
        if self.is_valid_PCICBSA(fields[66]) == False: return False
        if self.is_valid_CNECTAFP(fields[67]) == False: return False
        if self.is_valid_NECTAFP(fields[68]) == False: return False
        if self.is_valid_NECTADIVFP(fields[69]) == False: return False
        if self.is_valid_PCINECTA(fields[70]) == False: return False
        if self.is_valid_ACT(fields[71]) == False: return False
        if self.is_valid_MEMI(fields[72]) == False: return False
        if self.is_valid_NMEMI(fields[73]) == False: return False
        if self.is_valid_OIDTABBLK(fields[74]) == False: return False
        return True

class GRFC20:
    __slots__ = ['TABBLKST', 'TABBLKCOU', 'TABTRACTCE', 'TABBLK', 'TABBLKSUFX1', 'TABBLKSUFX2', 'TABBLKGRPCE', 'POPDEC', 'HOUSING', 'CURSTATE', 'CURCOUNTY', 'CURTRACTCE', 'CURBLKGRPCE', 'REGIONCE', 'DIVISIONCE', 'STATENS', 'COUNTYNS', 'COUNTYFS', 'COUSUBFP', 'COUSUBNS', 'SUBMCDFP', 'SUBMCDNS', 'ESTATEFP', 'ESTATENS', 'CONCITFP', 'CONCITNS', 'PLACEFP', 'PLACENS', 'PLACEFS', 'AIANNHFP', 'AIANNHCE', 'AIANNHNS', 'AIHHTLI', 'TRIBALSUBFP', 'TRIBALSUBCE', 'TRIBALSUBNS', 'TTRACTCE', 'TBLKGRPCE', 'ANRCFP', 'ANRCNS', 'UACE', 'UATYP', 'UR', 'CD116FP', 'CDCURFP', 'VTDST', 'SLDUST', 'SLDLST', 'ZCTA5CE', 'SDELMLEA', 'SDSECLEA', 'SDUNILEA', 'UGACE', 'PUMA', 'LWBLKTYP', 'INTPTLAT', 'INTPTLON', 'AREALAND', 'AREAWATER', 'AREAWATERINLD', 'AREAWATERCSTL', 'AREAWATERGRLK', 'AREAWATERTSEA', 'CSAFP', 'CBSAFP', 'METDIVFP', 'PCICBSA', 'CNECTAFP', 'NECTAFP', 'NECTADIVFP', 'PCINECTA', 'ACT', 'MEMI', 'NMEMI', 'OIDTABBLK']
    def __repr__(self):
        return 'GRFC20<TABBLKST:{},TABBLKCOU:{},TABTRACTCE:{},TABBLK:{},TABBLKSUFX1:{},TABBLKSUFX2:{},TABBLKGRPCE:{},POPDEC:{},HOUSING:{},CURSTATE:{},CURCOUNTY:{},CURTRACTCE:{},CURBLKGRPCE:{},REGIONCE:{},DIVISIONCE:{},STATENS:{},COUNTYNS:{},COUNTYFS:{},COUSUBFP:{},COUSUBNS:{},SUBMCDFP:{},SUBMCDNS:{},ESTATEFP:{},ESTATENS:{},CONCITFP:{},CONCITNS:{},PLACEFP:{},PLACENS:{},PLACEFS:{},AIANNHFP:{},AIANNHCE:{},AIANNHNS:{},AIHHTLI:{},TRIBALSUBFP:{},TRIBALSUBCE:{},TRIBALSUBNS:{},TTRACTCE:{},TBLKGRPCE:{},ANRCFP:{},ANRCNS:{},UACE:{},UATYP:{},UR:{},CD116FP:{},CDCURFP:{},VTDST:{},SLDUST:{},SLDLST:{},ZCTA5CE:{},SDELMLEA:{},SDSECLEA:{},SDUNILEA:{},UGACE:{},PUMA:{},LWBLKTYP:{},INTPTLAT:{},INTPTLON:{},AREALAND:{},AREAWATER:{},AREAWATERINLD:{},AREAWATERCSTL:{},AREAWATERGRLK:{},AREAWATERTSEA:{},CSAFP:{},CBSAFP:{},METDIVFP:{},PCICBSA:{},CNECTAFP:{},NECTAFP:{},NECTADIVFP:{},PCINECTA:{},ACT:{},MEMI:{},NMEMI:{},OIDTABBLK:{}>'.format(self.TABBLKST,self.TABBLKCOU,self.TABTRACTCE,self.TABBLK,self.TABBLKSUFX1,self.TABBLKSUFX2,self.TABBLKGRPCE,self.POPDEC,self.HOUSING,self.CURSTATE,self.CURCOUNTY,self.CURTRACTCE,self.CURBLKGRPCE,self.REGIONCE,self.DIVISIONCE,self.STATENS,self.COUNTYNS,self.COUNTYFS,self.COUSUBFP,self.COUSUBNS,self.SUBMCDFP,self.SUBMCDNS,self.ESTATEFP,self.ESTATENS,self.CONCITFP,self.CONCITNS,self.PLACEFP,self.PLACENS,self.PLACEFS,self.AIANNHFP,self.AIANNHCE,self.AIANNHNS,self.AIHHTLI,self.TRIBALSUBFP,self.TRIBALSUBCE,self.TRIBALSUBNS,self.TTRACTCE,self.TBLKGRPCE,self.ANRCFP,self.ANRCNS,self.UACE,self.UATYP,self.UR,self.CD116FP,self.CDCURFP,self.VTDST,self.SLDUST,self.SLDLST,self.ZCTA5CE,self.SDELMLEA,self.SDSECLEA,self.SDUNILEA,self.UGACE,self.PUMA,self.LWBLKTYP,self.INTPTLAT,self.INTPTLON,self.AREALAND,self.AREAWATER,self.AREAWATERINLD,self.AREAWATERCSTL,self.AREAWATERGRLK,self.AREAWATERTSEA,self.CSAFP,self.CBSAFP,self.METDIVFP,self.PCICBSA,self.CNECTAFP,self.NECTAFP,self.NECTADIVFP,self.PCINECTA,self.ACT,self.MEMI,self.NMEMI,self.OIDTABBLK)
    def __init__(self,line=None):
        if line:
            if '|' in line:
                self.parse_pipe_delimited(line)
            else:
                self.parse_column_specified(line)
    @classmethod
    def name(self):
        return 'GRFC20'

    def parse_pipe_delimited(self,line):
        fields = line.split('|')
        if len(fields)!=75:
            raise ValueError(f'expected 75 fields, found {len(fields)}')
        self.TABBLKST        = fields[0]  # 2020 Tabulation State (FIPS)
        self.TABBLKCOU       = fields[1]  # 2020 Tabulation County (FIPS)
        self.TABTRACTCE      = fields[2]  # 2020 Tabulation Census Tract
        self.TABBLK          = fields[3]  # 2020 Block Number
        self.TABBLKSUFX1     = fields[4]  # 2020 Block Suffix 1 (Current Block Suffix)
        self.TABBLKSUFX2     = fields[5]  # 2020 Block Suffix 2
        self.TABBLKGRPCE     = fields[6]  # 2020 Census Block Group
        self.POPDEC          = fields[7]  # 2020 Population
        self.HOUSING         = fields[8]  # 2020 Housing Unit Count
        self.CURSTATE        = fields[9]  # Current State (FIPS)
        self.CURCOUNTY       = fields[10]  # Current County (FIPS)
        self.CURTRACTCE      = fields[11]  # Current Census Tract
        self.CURBLKGRPCE     = fields[12]  # Current Block Group
        self.REGIONCE        = fields[13]  # Census Region
        self.DIVISIONCE      = fields[14]  # Census Division
        self.STATENS         = fields[15]  # State (National Standard)
        self.COUNTYNS        = fields[16]  # County (National Standard)
        self.COUNTYFS        = fields[17]  # County Functional Status
        self.COUSUBFP        = fields[18]  # County Subdivision (FIPS)
        self.COUSUBNS        = fields[19]  # County Subdivision (National Standard)
        self.SUBMCDFP        = fields[20]  # Subminor Civil Division (FIPS)
        self.SUBMCDNS        = fields[21]  # Subminor Civil Division (National Standard)
        self.ESTATEFP        = fields[22]  # Estate (FIPS)
        self.ESTATENS        = fields[23]  # Estate (National Standard)
        self.CONCITFP        = fields[24]  # Consolidated City (FIPS)
        self.CONCITNS        = fields[25]  # Consolidated City (National Standard)
        self.PLACEFP         = fields[26]  # Place (FIPS)
        self.PLACENS         = fields[27]  # Place (National Standard)
        self.PLACEFS         = fields[28]  # Place Functional Status
        self.AIANNHFP        = fields[29]  # AIANNH (FIPS)
        self.AIANNHCE        = fields[30]  # AIANNH (Census)
        self.AIANNHNS        = fields[31]  # AIANNH (National Standard)
        self.AIHHTLI         = fields[32]  # American Indian/Hawaiian Home Land Trust Land Indicator
        self.TRIBALSUBFP     = fields[33]  # American Indian Tribal Subdivision (FIPS)
        self.TRIBALSUBCE     = fields[34]  # American Indian Tribal Subdivision (Census)
        self.TRIBALSUBNS     = fields[35]  # American Indian Tribal Subdivision (National Standard)
        self.TTRACTCE        = fields[36]  # American Indian Tribal Tract
        self.TBLKGRPCE       = fields[37]  # American Indian Tribal Block Group
        self.ANRCFP          = fields[38]  # Alaska Native Regional Corporation (FIPS)
        self.ANRCNS          = fields[39]  # Alaska Native Regional Corporation (National Standard)
        self.UACE            = fields[40]  # Urban Area
        self.UATYP           = fields[41]  # Urban Area Type
        self.UR              = fields[42]  # Urban/Rural
        self.CD116FP         = fields[43]  # Congressional District (Decennial)
        self.CDCURFP         = fields[44]  # Congressional District (Current)
        self.VTDST           = fields[45]  # Voting District
        self.SLDUST          = fields[46]  # State Legislative District (Upper Chamber)
        self.SLDLST          = fields[47]  # State Legislative District (Lower Chamber)
        self.ZCTA5CE         = fields[48]  # ZIP Code Tabulation Area (5-Digit)
        self.SDELMLEA        = fields[49]  # School District (Elementary)
        self.SDSECLEA        = fields[50]  # School District (Secondary)
        self.SDUNILEA        = fields[51]  # School District (Unified)
        self.UGACE           = fields[52]  # Urban Growth Area
        self.PUMA            = fields[53]  # Public Use Microdata Area
        self.LWBLKTYP        = fields[54]  # Block Type
        self.INTPTLAT        = fields[55]  # Internal Point (Latitude)
        self.INTPTLON        = fields[56]  # Internal Point (Longitude)
        self.AREALAND        = fields[57]  # Area (Land)
        self.AREAWATER       = fields[58]  # Area (Water)
        self.AREAWATERINLD   = fields[59]  # Area (Water-Inland)
        self.AREAWATERCSTL   = fields[60]  # Area (Water-Coastal)
        self.AREAWATERGRLK   = fields[61]  # Area (Water-Great Lakes)
        self.AREAWATERTSEA   = fields[62]  # Area (Water-Territorial Sea)
        self.CSAFP           = fields[63]  # Combined Statistical Area
        self.CBSAFP          = fields[64]  # Metropolitan and Micropolitan Statistical Area
        self.METDIVFP        = fields[65]  # Metropolitan Division
        self.PCICBSA         = fields[66]  # CBSA Principal City Indicator
        self.CNECTAFP        = fields[67]  # New England City and Town Combined Statistical Area
        self.NECTAFP         = fields[68]  # New England City and Town Area
        self.NECTADIVFP      = fields[69]  # New England City and Town Area Division
        self.PCINECTA        = fields[70]  # NECTA Principal City Indicator
        self.ACT             = fields[71]  # Address Stringistic Type
        self.MEMI            = fields[72]  # CBSA Metropolitan/Micropolitan Status Indicator
        self.NMEMI           = fields[73]  # NECTA Metropolitan/Micropolitan Status Indicator
        self.OIDTABBLK       = fields[74]  # Tabulation Block Object ID

    def parse_column_specified(self,line):
        self.TABBLKST        = line[0:2] # 2020 Tabulation State (FIPS)
        self.TABBLKCOU       = line[1:4] # 2020 Tabulation County (FIPS)
        self.TABTRACTCE      = line[2:8] # 2020 Tabulation Census Tract
        self.TABBLK          = line[3:7] # 2020 Block Number
        self.TABBLKSUFX1     = line[4:5] # 2020 Block Suffix 1 (Current Block Suffix)
        self.TABBLKSUFX2     = line[5:6] # 2020 Block Suffix 2
        self.TABBLKGRPCE     = line[6:7] # 2020 Census Block Group
        self.POPDEC          = line[7:16] # 2020 Population
        self.HOUSING         = line[8:17] # 2020 Housing Unit Count
        self.CURSTATE        = line[9:11] # Current State (FIPS)
        self.CURCOUNTY       = line[10:13] # Current County (FIPS)
        self.CURTRACTCE      = line[11:17] # Current Census Tract
        self.CURBLKGRPCE     = line[12:13] # Current Block Group
        self.REGIONCE        = line[13:14] # Census Region
        self.DIVISIONCE      = line[14:15] # Census Division
        self.STATENS         = line[15:23] # State (National Standard)
        self.COUNTYNS        = line[16:24] # County (National Standard)
        self.COUNTYFS        = line[17:18] # County Functional Status
        self.COUSUBFP        = line[18:23] # County Subdivision (FIPS)
        self.COUSUBNS        = line[19:27] # County Subdivision (National Standard)
        self.COUSUBFS        = line[20:21] # County Subdivision Functional Status
        self.SUBMCDFP        = line[21:26] # Subminor Civil Division (FIPS)
        self.SUBMCDNS        = line[22:30] # Subminor Civil Division (National Standard)
        self.ESTATEFP        = line[23:28] # Estate (FIPS)
        self.ESTATENS        = line[24:32] # Estate (National Standard)
        self.CONCITFP        = line[25:30] # Consolidated City (FIPS)
        self.CONCITNS        = line[26:34] # Consolidated City (National Standard)
        self.PLACEFP         = line[27:32] # Place (FIPS)
        self.PLACENS         = line[28:36] # Place (National Standard)
        self.PLACEFS         = line[29:30] # Place Functional Status
        self.AIANNHFP        = line[30:35] # AIANNH (FIPS)
        self.AIANNHCE        = line[31:35] # AIANNH (Census)
        self.AIANNHNS        = line[32:40] # AIANNH (National Standard)
        self.AIHHTLI         = line[33:34] # American Indian/Hawaiian Home Land Trust Land Indicator
        self.TRIBALSUBFP     = line[34:39] # American Indian Tribal Subdivision (FIPS)
        self.TRIBALSUBCE     = line[35:38] # American Indian Tribal Subdivision (Census)
        self.TRIBALSUBNS     = line[36:44] # American Indian Tribal Subdivision (National Standard)
        self.TTRACTCE        = line[37:43] # American Indian Tribal Tract
        self.TBLKGRPCE       = line[38:39] # American Indian Tribal Block Group
        self.ANRCFP          = line[39:44] # Alaska Native Regional Corporation (FIPS)
        self.ANRCNS          = line[40:48] # Alaska Native Regional Corporation (National Standard)
        self.UACE            = line[41:46] # Urban Area
        self.UATYP           = line[42:43] # Urban Area Type
        self.UR              = line[43:44] # Urban/Rural
        self.CD116FP         = line[44:46] # Congressional District (Decennial)
        self.CDCURFP         = line[45:47] # Congressional District (Current)
        self.VTDST           = line[46:52] # Voting District
        self.SLDUST          = line[47:50] # State Legislative District (Upper Chamber)
        self.SLDLST          = line[48:51] # State Legislative District (Lower Chamber)
        self.ZCTA5CE         = line[49:54] # ZIP Code Tabulation Area (5-Digit)
        self.SDELMLEA        = line[50:55] # School District (Elementary)
        self.SDSECLEA        = line[51:56] # School District (Secondary)
        self.SDUNILEA        = line[52:57] # School District (Unified)
        self.UGACE           = line[53:58] # Urban Growth Area
        self.PUMA            = line[54:59] # Public Use Microdata Area
        self.LWBLKTYP        = line[55:56] # Block Type
        self.INTPTLAT        = line[56:67] # Internal Point (Latitude)
        self.INTPTLON        = line[57:69] # Internal Point (Longitude)
        self.AREALAND        = line[58:72] # Area (Land)
        self.AREAWATER       = line[59:73] # Area (Water)
        self.AREAWATERINLD   = line[60:74] # Area (Water-Inland)
        self.AREAWATERCSTL   = line[61:75] # Area (Water-Coastal)
        self.AREAWATERGRLK   = line[62:76] # Area (Water-Great Lakes)
        self.AREAWATERTSEA   = line[63:77] # Area (Water-Territorial Sea)
        self.CSAFP           = line[64:67] # Combined Statistical Area
        self.CBSAFP          = line[65:70] # Metropolitan and Micropolitan Statistical Area
        self.METDIVFP        = line[66:71] # Metropolitan Division
        self.PCICBSA         = line[67:68] # CBSA Principal City Indicator
        self.CNECTAFP        = line[68:71] # New England City and Town Combined Statistical Area
        self.NECTAFP         = line[69:74] # New England City and Town Area
        self.NECTADIVFP      = line[70:75] # New England City and Town Area Division
        self.PCINECTA        = line[71:72] # NECTA Principal City Indicator
        self.ACT             = line[72:74] # Address Stringistic Type
        self.MEMI            = line[73:74] # CBSA Metropolitan/Micropolitan Status Indicator
        self.NMEMI           = line[74:75] # NECTA Metropolitan/Micropolitan Status Indicator
        self.OIDTABBLK       = line[75:97] # Tabulation Block Object ID

    def validate(self):
        """Return True if the object data validates"""
        if not GRFC20_validator.is_valid_TABBLKST(self.TABBLKST): return False
        if not GRFC20_validator.is_valid_TABBLKCOU(self.TABBLKCOU): return False
        if not GRFC20_validator.is_valid_TABTRACTCE(self.TABTRACTCE): return False
        if not GRFC20_validator.is_valid_TABBLK(self.TABBLK): return False
        if not GRFC20_validator.is_valid_TABBLKSUFX1(self.TABBLKSUFX1): return False
        if not GRFC20_validator.is_valid_TABBLKSUFX2(self.TABBLKSUFX2): return False
        if not GRFC20_validator.is_valid_TABBLKGRPCE(self.TABBLKGRPCE): return False
        if not GRFC20_validator.is_valid_POPDEC(self.POPDEC): return False
        if not GRFC20_validator.is_valid_HOUSING(self.HOUSING): return False
        if not GRFC20_validator.is_valid_CURSTATE(self.CURSTATE): return False
        if not GRFC20_validator.is_valid_CURCOUNTY(self.CURCOUNTY): return False
        if not GRFC20_validator.is_valid_CURTRACTCE(self.CURTRACTCE): return False
        if not GRFC20_validator.is_valid_CURBLKGRPCE(self.CURBLKGRPCE): return False
        if not GRFC20_validator.is_valid_REGIONCE(self.REGIONCE): return False
        if not GRFC20_validator.is_valid_DIVISIONCE(self.DIVISIONCE): return False
        if not GRFC20_validator.is_valid_STATENS(self.STATENS): return False
        if not GRFC20_validator.is_valid_COUNTYNS(self.COUNTYNS): return False
        if not GRFC20_validator.is_valid_COUNTYFS(self.COUNTYFS): return False
        if not GRFC20_validator.is_valid_COUSUBFP(self.COUSUBFP): return False
        if not GRFC20_validator.is_valid_COUSUBNS(self.COUSUBNS): return False
        if not GRFC20_validator.is_valid_SUBMCDFP(self.SUBMCDFP): return False
        if not GRFC20_validator.is_valid_SUBMCDNS(self.SUBMCDNS): return False
        if not GRFC20_validator.is_valid_ESTATEFP(self.ESTATEFP): return False
        if not GRFC20_validator.is_valid_ESTATENS(self.ESTATENS): return False
        if not GRFC20_validator.is_valid_CONCITFP(self.CONCITFP): return False
        if not GRFC20_validator.is_valid_CONCITNS(self.CONCITNS): return False
        if not GRFC20_validator.is_valid_PLACEFP(self.PLACEFP): return False
        if not GRFC20_validator.is_valid_PLACENS(self.PLACENS): return False
        if not GRFC20_validator.is_valid_PLACEFS(self.PLACEFS): return False
        if not GRFC20_validator.is_valid_AIANNHFP(self.AIANNHFP): return False
        if not GRFC20_validator.is_valid_AIANNHCE(self.AIANNHCE): return False
        if not GRFC20_validator.is_valid_AIANNHNS(self.AIANNHNS): return False
        if not GRFC20_validator.is_valid_AIHHTLI(self.AIHHTLI): return False
        if not GRFC20_validator.is_valid_TRIBALSUBFP(self.TRIBALSUBFP): return False
        if not GRFC20_validator.is_valid_TRIBALSUBCE(self.TRIBALSUBCE): return False
        if not GRFC20_validator.is_valid_TRIBALSUBNS(self.TRIBALSUBNS): return False
        if not GRFC20_validator.is_valid_TTRACTCE(self.TTRACTCE): return False
        if not GRFC20_validator.is_valid_TBLKGRPCE(self.TBLKGRPCE): return False
        if not GRFC20_validator.is_valid_ANRCFP(self.ANRCFP): return False
        if not GRFC20_validator.is_valid_ANRCNS(self.ANRCNS): return False
        if not GRFC20_validator.is_valid_UACE(self.UACE): return False
        if not GRFC20_validator.is_valid_UATYP(self.UATYP): return False
        if not GRFC20_validator.is_valid_UR(self.UR): return False
        if not GRFC20_validator.is_valid_CD116FP(self.CD116FP): return False
        if not GRFC20_validator.is_valid_CDCURFP(self.CDCURFP): return False
        if not GRFC20_validator.is_valid_VTDST(self.VTDST): return False
        if not GRFC20_validator.is_valid_SLDUST(self.SLDUST): return False
        if not GRFC20_validator.is_valid_SLDLST(self.SLDLST): return False
        if not GRFC20_validator.is_valid_ZCTA5CE(self.ZCTA5CE): return False
        if not GRFC20_validator.is_valid_SDELMLEA(self.SDELMLEA): return False
        if not GRFC20_validator.is_valid_SDSECLEA(self.SDSECLEA): return False
        if not GRFC20_validator.is_valid_SDUNILEA(self.SDUNILEA): return False
        if not GRFC20_validator.is_valid_UGACE(self.UGACE): return False
        if not GRFC20_validator.is_valid_PUMA(self.PUMA): return False
        if not GRFC20_validator.is_valid_LWBLKTYP(self.LWBLKTYP): return False
        if not GRFC20_validator.is_valid_INTPTLAT(self.INTPTLAT): return False
        if not GRFC20_validator.is_valid_INTPTLON(self.INTPTLON): return False
        if not GRFC20_validator.is_valid_AREALAND(self.AREALAND): return False
        if not GRFC20_validator.is_valid_AREAWATER(self.AREAWATER): return False
        if not GRFC20_validator.is_valid_AREAWATERINLD(self.AREAWATERINLD): return False
        if not GRFC20_validator.is_valid_AREAWATERCSTL(self.AREAWATERCSTL): return False
        if not GRFC20_validator.is_valid_AREAWATERGRLK(self.AREAWATERGRLK): return False
        if not GRFC20_validator.is_valid_AREAWATERTSEA(self.AREAWATERTSEA): return False
        if not GRFC20_validator.is_valid_CSAFP(self.CSAFP): return False
        if not GRFC20_validator.is_valid_CBSAFP(self.CBSAFP): return False
        if not GRFC20_validator.is_valid_METDIVFP(self.METDIVFP): return False
        if not GRFC20_validator.is_valid_PCICBSA(self.PCICBSA): return False
        if not GRFC20_validator.is_valid_CNECTAFP(self.CNECTAFP): return False
        if not GRFC20_validator.is_valid_NECTAFP(self.NECTAFP): return False
        if not GRFC20_validator.is_valid_NECTADIVFP(self.NECTADIVFP): return False
        if not GRFC20_validator.is_valid_PCINECTA(self.PCINECTA): return False
        if not GRFC20_validator.is_valid_ACT(self.ACT): return False
        if not GRFC20_validator.is_valid_MEMI(self.MEMI): return False
        if not GRFC20_validator.is_valid_NMEMI(self.NMEMI): return False
        if not GRFC20_validator.is_valid_OIDTABBLK(self.OIDTABBLK): return False
        return True

    def validate_reason(self):
        reason=[]
        if not GRFC20_validator.is_valid_TABBLKST(self.TABBLKST): reason.append('TABBLKST ('+str(self.TABBLKST)+') out of range (66-66, 60-60, 44-51, 72-72, 01-02, 78-78, 69-69, 08-13, 15-42, 04-06, 53-56)')
        if not GRFC20_validator.is_valid_TABBLKCOU(self.TABBLKCOU): reason.append('TABBLKCOU ('+str(self.TABBLKCOU)+') out of range (001-840)')
        if not GRFC20_validator.is_valid_TABTRACTCE(self.TABTRACTCE): reason.append('TABTRACTCE ('+str(self.TABTRACTCE)+') out of range (000100-998999)')
        if not GRFC20_validator.is_valid_TABBLK(self.TABBLK): reason.append('TABBLK ('+str(self.TABBLK)+') out of range (0001-9999)')
        if not GRFC20_validator.is_valid_TABBLKSUFX1(self.TABBLKSUFX1): reason.append('TABBLKSUFX1 ('+str(self.TABBLKSUFX1)+') out of range (A-Z)')
        if not GRFC20_validator.is_valid_TABBLKSUFX2(self.TABBLKSUFX2): reason.append('TABBLKSUFX2 ('+str(self.TABBLKSUFX2)+') out of range (A-Z)')
        if not GRFC20_validator.is_valid_TABBLKGRPCE(self.TABBLKGRPCE): reason.append('TABBLKGRPCE ('+str(self.TABBLKGRPCE)+') out of range (0-9)')
        if not GRFC20_validator.is_valid_POPDEC(self.POPDEC): reason.append('POPDEC ('+str(self.POPDEC)+') out of range (000000000-999999999)')
        if not GRFC20_validator.is_valid_HOUSING(self.HOUSING): reason.append('HOUSING ('+str(self.HOUSING)+') out of range ()')
        if not GRFC20_validator.is_valid_CURSTATE(self.CURSTATE): reason.append('CURSTATE ('+str(self.CURSTATE)+') out of range ()')
        if not GRFC20_validator.is_valid_CURCOUNTY(self.CURCOUNTY): reason.append('CURCOUNTY ('+str(self.CURCOUNTY)+') out of range ()')
        if not GRFC20_validator.is_valid_CURTRACTCE(self.CURTRACTCE): reason.append('CURTRACTCE ('+str(self.CURTRACTCE)+') out of range ()')
        if not GRFC20_validator.is_valid_CURBLKGRPCE(self.CURBLKGRPCE): reason.append('CURBLKGRPCE ('+str(self.CURBLKGRPCE)+') out of range ()')
        if not GRFC20_validator.is_valid_REGIONCE(self.REGIONCE): reason.append('REGIONCE ('+str(self.REGIONCE)+') out of range (1-4, 9-9)')
        if not GRFC20_validator.is_valid_DIVISIONCE(self.DIVISIONCE): reason.append('DIVISIONCE ('+str(self.DIVISIONCE)+') out of range (0-9)')
        if not GRFC20_validator.is_valid_STATENS(self.STATENS): reason.append('STATENS ('+str(self.STATENS)+') out of range (00000001-99999998)')
        if not GRFC20_validator.is_valid_COUNTYNS(self.COUNTYNS): reason.append('COUNTYNS ('+str(self.COUNTYNS)+') out of range (00000001-99999998)')
        if not GRFC20_validator.is_valid_COUNTYFS(self.COUNTYFS): reason.append('COUNTYFS ('+str(self.COUNTYFS)+') out of range (F-F, G-G, B-B, A-A, N-N, S-S, C-C)')
        if not GRFC20_validator.is_valid_COUSUBFP(self.COUSUBFP): reason.append('COUSUBFP ('+str(self.COUSUBFP)+') out of range (00000-98999)')
        if not GRFC20_validator.is_valid_COUSUBNS(self.COUSUBNS): reason.append('COUSUBNS ('+str(self.COUSUBNS)+') out of range (00000000-99999998)')
        if not GRFC20_validator.is_valid_SUBMCDFP(self.SUBMCDFP): reason.append('SUBMCDFP ('+str(self.SUBMCDFP)+') out of range (99999-99999, 00001-89999)')
        if not GRFC20_validator.is_valid_SUBMCDNS(self.SUBMCDNS): reason.append('SUBMCDNS ('+str(self.SUBMCDNS)+') out of range (00000001-99999998, 99999999-99999999)')
        if not GRFC20_validator.is_valid_ESTATEFP(self.ESTATEFP): reason.append('ESTATEFP ('+str(self.ESTATEFP)+') out of range (99999-99999, 00001-89999)')
        if not GRFC20_validator.is_valid_ESTATENS(self.ESTATENS): reason.append('ESTATENS ('+str(self.ESTATENS)+') out of range (00000001-99999998, 99999999-99999999)')
        if not GRFC20_validator.is_valid_CONCITFP(self.CONCITFP): reason.append('CONCITFP ('+str(self.CONCITFP)+') out of range (99999-99999, 00001-89999)')
        if not GRFC20_validator.is_valid_CONCITNS(self.CONCITNS): reason.append('CONCITNS ('+str(self.CONCITNS)+') out of range (00000001-99999998, 99999999-99999999)')
        if not GRFC20_validator.is_valid_PLACEFP(self.PLACEFP): reason.append('PLACEFP ('+str(self.PLACEFP)+') out of range (99999-99999, 00001-89999)')
        if not GRFC20_validator.is_valid_PLACENS(self.PLACENS): reason.append('PLACENS ('+str(self.PLACENS)+') out of range (00000001-99999998, 99999999-99999999)')
        if not GRFC20_validator.is_valid_PLACEFS(self.PLACEFS): reason.append('PLACEFS ('+str(self.PLACEFS)+') out of range (F-F, I-I, N-N, B-B, A-A, S-S, 9-9)')
        if not GRFC20_validator.is_valid_AIANNHFP(self.AIANNHFP): reason.append('AIANNHFP ('+str(self.AIANNHFP)+') out of range (99999-99999, 00001-89999)')
        if not GRFC20_validator.is_valid_AIANNHCE(self.AIANNHCE): reason.append('AIANNHCE ('+str(self.AIANNHCE)+') out of range (00001-9998, 9999-9999)')
        if not GRFC20_validator.is_valid_AIANNHNS(self.AIANNHNS): reason.append('AIANNHNS ('+str(self.AIANNHNS)+') out of range (00000001-99999998, 99999999-99999999)')
        if not GRFC20_validator.is_valid_AIHHTLI(self.AIHHTLI): reason.append('AIHHTLI ('+str(self.AIHHTLI)+') out of range (9-9, R-R, T-T)')
        if not GRFC20_validator.is_valid_TRIBALSUBFP(self.TRIBALSUBFP): reason.append('TRIBALSUBFP ('+str(self.TRIBALSUBFP)+') out of range (99999-99999, 00001-89999)')
        if not GRFC20_validator.is_valid_TRIBALSUBCE(self.TRIBALSUBCE): reason.append('TRIBALSUBCE ('+str(self.TRIBALSUBCE)+') out of range (999-999, 001-998)')
        if not GRFC20_validator.is_valid_TRIBALSUBNS(self.TRIBALSUBNS): reason.append('TRIBALSUBNS ('+str(self.TRIBALSUBNS)+') out of range (00000001-99999998, 99999999-99999999)')
        if not GRFC20_validator.is_valid_TTRACTCE(self.TTRACTCE): reason.append('TTRACTCE ('+str(self.TTRACTCE)+') out of range (T00100-T98999, 999999-999999)')
        if not GRFC20_validator.is_valid_TBLKGRPCE(self.TBLKGRPCE): reason.append('TBLKGRPCE ('+str(self.TBLKGRPCE)+') out of range (K-K, 9-9, J-J, A-H)')
        if not GRFC20_validator.is_valid_ANRCFP(self.ANRCFP): reason.append('ANRCFP ('+str(self.ANRCFP)+') out of range (17140-17140, 00590-00590, 09040-09040, 03950-03950, 14410-14410, 20010-20010, 41640-41640, 01570-01570, 06370-06370, 52120-52120, 67940-67940, 99999-99999, 09800-09800)')
        if not GRFC20_validator.is_valid_ANRCNS(self.ANRCNS): reason.append('ANRCNS ('+str(self.ANRCNS)+') out of range (00000001-99999998, 99999999-99999999)')
        if not GRFC20_validator.is_valid_UACE(self.UACE): reason.append('UACE ('+str(self.UACE)+') out of range (00001-98999, !!!!!-!!!!!, 99999-99999)')
        if not GRFC20_validator.is_valid_UATYP(self.UATYP): reason.append('UATYP ('+str(self.UATYP)+') out of range (U-U, !-!, 9-9, C-C)')
        if not GRFC20_validator.is_valid_UR(self.UR): reason.append('UR ('+str(self.UR)+') out of range (U-U, R-R, !-!)')
        if not GRFC20_validator.is_valid_CD116FP(self.CD116FP): reason.append('CD116FP ('+str(self.CD116FP)+') out of range (00-53, ZZ-ZZ, 98-98, 99-99)')
        if not GRFC20_validator.is_valid_CDCURFP(self.CDCURFP): reason.append('CDCURFP ('+str(self.CDCURFP)+') out of range ()')
        if not GRFC20_validator.is_valid_VTDST(self.VTDST): reason.append('VTDST ('+str(self.VTDST)+') out of range (      -zzzzzz, ZZZZZZ-ZZZZZZ)')
        if not GRFC20_validator.is_valid_SLDUST(self.SLDUST): reason.append('SLDUST ('+str(self.SLDUST)+') out of range (   -zzz, 999-999, ZZZ-ZZZ)')
        if not GRFC20_validator.is_valid_SLDLST(self.SLDLST): reason.append('SLDLST ('+str(self.SLDLST)+') out of range (   -zzz, 999-999, ZZZ-ZZZ)')
        if not GRFC20_validator.is_valid_ZCTA5CE(self.ZCTA5CE): reason.append('ZCTA5CE ('+str(self.ZCTA5CE)+') out of range (!!!!!-!!!!!, 00601-99929, 00000-00000, 99999-99999)')
        if not GRFC20_validator.is_valid_SDELMLEA(self.SDELMLEA): reason.append('SDELMLEA ('+str(self.SDELMLEA)+') out of range (00001-99996, 99999-99999)')
        if not GRFC20_validator.is_valid_SDSECLEA(self.SDSECLEA): reason.append('SDSECLEA ('+str(self.SDSECLEA)+') out of range (00001-99996, 99999-99999)')
        if not GRFC20_validator.is_valid_SDUNILEA(self.SDUNILEA): reason.append('SDUNILEA ('+str(self.SDUNILEA)+') out of range (00001-99998, 99999-99999)')
        if not GRFC20_validator.is_valid_UGACE(self.UGACE): reason.append('UGACE ('+str(self.UGACE)+') out of range (99999-99999, 00001-89999)')
        if not GRFC20_validator.is_valid_PUMA(self.PUMA): reason.append('PUMA ('+str(self.PUMA)+') out of range (00001-99998, !!!!!-!!!!!, 99999-99999)')
        if not GRFC20_validator.is_valid_LWBLKTYP(self.LWBLKTYP): reason.append('LWBLKTYP ('+str(self.LWBLKTYP)+') out of range (W-W, L-L, B-B)')
        if not GRFC20_validator.is_valid_INTPTLAT(self.INTPTLAT): reason.append('INTPTLAT ('+str(self.INTPTLAT)+') out of range (-15.0000000-+72.0000000)')
        if not GRFC20_validator.is_valid_INTPTLON(self.INTPTLON): reason.append('INTPTLON ('+str(self.INTPTLON)+') out of range (-180.000000--64.0000000, +131.0000000-+179.9999999)')
        if not GRFC20_validator.is_valid_AREALAND(self.AREALAND): reason.append('AREALAND ('+str(self.AREALAND)+') out of range (00000000000000-99999999999999)')
        if not GRFC20_validator.is_valid_AREAWATER(self.AREAWATER): reason.append('AREAWATER ('+str(self.AREAWATER)+') out of range (00000000000000-99999999999999)')
        if not GRFC20_validator.is_valid_AREAWATERINLD(self.AREAWATERINLD): reason.append('AREAWATERINLD ('+str(self.AREAWATERINLD)+') out of range (00000000000000-99999999999999)')
        if not GRFC20_validator.is_valid_AREAWATERCSTL(self.AREAWATERCSTL): reason.append('AREAWATERCSTL ('+str(self.AREAWATERCSTL)+') out of range (00000000000000-99999999999999)')
        if not GRFC20_validator.is_valid_AREAWATERGRLK(self.AREAWATERGRLK): reason.append('AREAWATERGRLK ('+str(self.AREAWATERGRLK)+') out of range (00000000000000-99999999999999)')
        if not GRFC20_validator.is_valid_AREAWATERTSEA(self.AREAWATERTSEA): reason.append('AREAWATERTSEA ('+str(self.AREAWATERTSEA)+') out of range (00000000000000-99999999999999)')
        if not GRFC20_validator.is_valid_CSAFP(self.CSAFP): reason.append('CSAFP ('+str(self.CSAFP)+') out of range (100-599, 999-999)')
        if not GRFC20_validator.is_valid_CBSAFP(self.CBSAFP): reason.append('CBSAFP ('+str(self.CBSAFP)+') out of range (10000-49999, 99999-99999)')
        if not GRFC20_validator.is_valid_METDIVFP(self.METDIVFP): reason.append('METDIVFP ('+str(self.METDIVFP)+') out of range (10004-49994, 99999-99999)')
        if not GRFC20_validator.is_valid_PCICBSA(self.PCICBSA): reason.append('PCICBSA ('+str(self.PCICBSA)+') out of range (9-9, Y-Y, N-N)')
        if not GRFC20_validator.is_valid_CNECTAFP(self.CNECTAFP): reason.append('CNECTAFP ('+str(self.CNECTAFP)+') out of range (700-799, 999-999)')
        if not GRFC20_validator.is_valid_NECTAFP(self.NECTAFP): reason.append('NECTAFP ('+str(self.NECTAFP)+') out of range (70000-79999, 99999-99999)')
        if not GRFC20_validator.is_valid_NECTADIVFP(self.NECTADIVFP): reason.append('NECTADIVFP ('+str(self.NECTADIVFP)+') out of range (70004-79994, 99999-99999)')
        if not GRFC20_validator.is_valid_PCINECTA(self.PCINECTA): reason.append('PCINECTA ('+str(self.PCINECTA)+') out of range (9-9, Y-Y, N-N)')
        if not GRFC20_validator.is_valid_ACT(self.ACT): reason.append('ACT ('+str(self.ACT)+') out of range (P3-P3, P1-P1, D1-D1, MC-MC, C2-C2, R1-R1, B3-B3, N1-N1, C3-C3, P2-P2, MA-MA, D2-D2, M3-M3, B1-B1, ME-ME, MB-MB, N3-N3, R2-R2, B2-B2, D3-D3, MF-MF, N2-N2, M1-M1, MG-MG, Z0-Z0, MD-MD, C1-C1, R3-R3)')
        if not GRFC20_validator.is_valid_MEMI(self.MEMI): reason.append('MEMI ('+str(self.MEMI)+') out of range (2-2, 9-9, 1-1)')
        if not GRFC20_validator.is_valid_NMEMI(self.NMEMI): reason.append('NMEMI ('+str(self.NMEMI)+') out of range (2-2, 9-9, 1-1)')
        if not GRFC20_validator.is_valid_OIDTABBLK(self.OIDTABBLK): reason.append('OIDTABBLK ('+str(self.OIDTABBLK)+') out of range (1-9999999999999999999999)')
        return ', '.join(reason)

    def SparkSQLRow(self):
        """Return a SparkSQL Row object for this object."""
        from pyspark.sql import Row
        return Row(
            tabblkst=safe_str(self.TABBLKST),
            tabblkcou=safe_str(self.TABBLKCOU),
            tabtractce=safe_str(self.TABTRACTCE),
            tabblk=safe_str(self.TABBLK),
            tabblksufx1=safe_str(self.TABBLKSUFX1),
            tabblksufx2=safe_str(self.TABBLKSUFX2),
            tabblkgrpce=safe_str(self.TABBLKGRPCE),
            popdec=safe_int(self.POPDEC),
            housing=safe_int(self.HOUSING),
            curstate=safe_str(self.CURSTATE),
            curcounty=safe_str(self.CURCOUNTY),
            curtractce=safe_str(self.CURTRACTCE),
            curblkgrpce=safe_str(self.CURBLKGRPCE),
            regionce=safe_str(self.REGIONCE),
            divisionce=safe_str(self.DIVISIONCE),
            statens=safe_str(self.STATENS),
            countyns=safe_str(self.COUNTYNS),
            countyfs=safe_str(self.COUNTYFS),
            cousubfp=safe_str(self.COUSUBFP),
            cousubns=safe_str(self.COUSUBNS),
            submcdfp=safe_str(self.SUBMCDFP),
            submcdns=safe_str(self.SUBMCDNS),
            estatefp=safe_str(self.ESTATEFP),
            estatens=safe_str(self.ESTATENS),
            concitfp=safe_str(self.CONCITFP),
            concitns=safe_str(self.CONCITNS),
            placefp=safe_str(self.PLACEFP),
            placens=safe_str(self.PLACENS),
            placefs=safe_str(self.PLACEFS),
            aiannhfp=safe_str(self.AIANNHFP),
            aiannhce=safe_str(self.AIANNHCE),
            aiannhns=safe_str(self.AIANNHNS),
            aihhtli=safe_str(self.AIHHTLI),
            tribalsubfp=safe_str(self.TRIBALSUBFP),
            tribalsubce=safe_str(self.TRIBALSUBCE),
            tribalsubns=safe_str(self.TRIBALSUBNS),
            ttractce=safe_str(self.TTRACTCE),
            tblkgrpce=safe_str(self.TBLKGRPCE),
            anrcfp=safe_str(self.ANRCFP),
            anrcns=safe_str(self.ANRCNS),
            uace=safe_str(self.UACE),
            uatyp=safe_str(self.UATYP),
            ur=safe_str(self.UR),
            cd116fp=safe_str(self.CD116FP),
            cdcurfp=safe_str(self.CDCURFP),
            vtdst=safe_str(self.VTDST),
            sldust=safe_str(self.SLDUST),
            sldlst=safe_str(self.SLDLST),
            zcta5ce=safe_str(self.ZCTA5CE),
            sdelmlea=safe_str(self.SDELMLEA),
            sdseclea=safe_str(self.SDSECLEA),
            sdunilea=safe_str(self.SDUNILEA),
            ugace=safe_str(self.UGACE),
            puma=safe_str(self.PUMA),
            lwblktyp=safe_str(self.LWBLKTYP),
            intptlat=safe_str(self.INTPTLAT),
            intptlon=safe_str(self.INTPTLON),
            arealand=safe_int(self.AREALAND),
            areawater=safe_int(self.AREAWATER),
            areawaterinld=safe_int(self.AREAWATERINLD),
            areawatercstl=safe_int(self.AREAWATERCSTL),
            areawatergrlk=safe_int(self.AREAWATERGRLK),
            areawatertsea=safe_int(self.AREAWATERTSEA),
            csafp=safe_str(self.CSAFP),
            cbsafp=safe_str(self.CBSAFP),
            metdivfp=safe_str(self.METDIVFP),
            pcicbsa=safe_str(self.PCICBSA),
            cnectafp=safe_str(self.CNECTAFP),
            nectafp=safe_str(self.NECTAFP),
            nectadivfp=safe_str(self.NECTADIVFP),
            pcinecta=safe_str(self.PCINECTA),
            act=safe_str(self.ACT),
            memi=safe_str(self.MEMI),
            nmemi=safe_str(self.NMEMI),
            oidtabblk=safe_int(self.OIDTABBLK),
        )


    @staticmethod
    def parse_line(line):
        # Read a line and return it as a dictionary.
        inst: GRFC20 = GRFC20()
        inst.parse_column_specified(line)
        assert inst.validate(), f'A line is invalid!! line: {line}, validate_reason: {inst.validate_reason()}'
        row = inst.SparkSQLRow()
        return row

    @staticmethod
    def parse_piped_line(line):
        # Read a pipe-delimited line and return it as a dictionary.
        inst: GRFC20 = GRFC20()
        inst.parse_pipe_delimited(line)
        assert inst.validate(), f'A line is invalid!! line: {line}, validate_reason: {inst.validate_reason()}'
        row = inst.SparkSQLRow()
        return row



# Automatically generated on Fri Oct 30 14:06:06 2020 by /mnt/users/user007/new-das-vm/das-vm-config/das_decennial/das_framework/ctools/schema/table.py

def leftpad(x,width):
    return ' '*(width-len(str(x)))+str(x)

def between(a,b,c,width):
    if len(b) > width:
        return False
    if '.' in a or '.' in b or '.' in c:
        try:
            return float(a) <= float(b) <= float(c)
        except ValueError:
            pass  # tries to return a float but might have weird input like 1.1.0 which will be compared traditionally instead
    b = b.replace(' ', '0')
    return leftpad(a,width) <= leftpad(b,width) <= leftpad(c,width)


def safe_int(i):
    try:
        return int(i)
    except (TypeError, ValueError):
        return None

def safe_float(i):
    try:
        return float(i)
    except (TypeError, ValueError):
        return None

def safe_str(i):
    try:
        return str(i)
    except (TypeError, ValueError):
        return None


class L_validator:
    @classmethod
    def is_valid_MTFCC(self,x):
        """MAF/TIGER Feature Class Code"""
        if x is None or x == "None":
            return False
        return (leftpad(x,5)==leftpad('S',5))
    @classmethod
    def is_valid_VINTAGE(self,x):
        """Vintage"""
        if x is None or x == "None":
            return False
        return True
    @classmethod
    def is_valid_STATEFP(self,x):
        """State or Equivalent Feature (FIPS)"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,2)==leftpad('S',2))
    @classmethod
    def is_valid_COUNTYFP(self,x):
        """County or Equivalent Feature (FIPS)"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_GEOCE(self,x):
        """Census Code"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_GEOFP(self,x):
        """FIPS Code"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_GEONS(self,x):
        """National Standard Code"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_PARENT(self,x):
        """Parent Code"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_PARENT2(self,x):
        """Parent Code 2"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_NAME(self,x):
        """Area Name (without LSADC)"""
        if x is None or x == "None":
            return False
        return True
    @classmethod
    def is_valid_NAMELSAD(self,x):
        """Area Name and Legal/Statistical Area Description Code"""
        if x is None or x == "None":
            return False
        return True
    @classmethod
    def is_valid_FUNCSTAT(self,x):
        """Functional Status"""
        if x is None or x == "None":
            return False
        return True
    @classmethod
    def is_valid_LSADC(self,x):
        """Legal/Statistical Area Description Code"""
        if x is None or x == "None":
            return False
        return True
    @classmethod
    def is_valid_PARTFLAG(self,x):
        """Part Flag (State)"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_AIANNHFSR(self,x):
        """AIANNHA Federal/State Recognition Flag"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_AIANNHTYP(self,x):
        """AIANNHA  Entity Type"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_CLASSFP(self,x):
        """FIPS 55 Class Code"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_STATEUSPS(self,x):
        """State/US Abbreviation"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,2)==leftpad('S',2))
    @classmethod
    def is_valid_MEMI(self,x):
        """Metropolitan/Micropolitan Status Indicator"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_PCICBSA(self,x):
        """CBSA Principal City Indicator"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,1)==leftpad('S',1))
    @classmethod
    def is_valid_PCINECTA(self,x):
        """NECTA Principal City Indicator"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return (leftpad(x,1)==leftpad('S',1))
    @classmethod
    def is_valid_CPI(self,x):
        """Central Place Indicator"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_CDSESSN(self,x):
        """Congressional District Session Code"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_LSY(self,x):
        """Legislative Session Year"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_VTDI(self,x):
        """Voting District Indicator"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_UR(self,x):
        """Urban/Rural Indicator"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_UATYPE(self,x):
        """Urban Area Type"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_GCUNI(self,x):
        """Geographic Change User Note"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_CENTLAT(self,x):
        """Centroid (Latitude)"""
        if x is None or x == "None":
            return False
        return (between('-15.0000000',x,'+72.0000000',11))
    @classmethod
    def is_valid_CENTLON(self,x):
        """Centroid (Longitude)"""
        if x is None or x == "None":
            return False
        return (between('-180.000000',x,'-64.0000000',12)) or (between('+131.0000000',x,'+179.9999999',12))
    @classmethod
    def is_valid_INTPTLAT(self,x):
        """Internal Point Latitude"""
        if x is None or x == "None":
            return False
        return (between('-15.0000000',x,'+72.0000000',11))
    @classmethod
    def is_valid_INTPTLON(self,x):
        """Internal Point Longitude"""
        if x is None or x == "None":
            return False
        return (between('-180.000000',x,'-64.0000000',12)) or (between('+131.0000000',x,'+179.9999999',12))
    @classmethod
    def is_valid_AREALAND(self,x):
        """Current Land Area"""
        if x is None or x == "None":
            return False
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return (00000000000000 <= x <= 99999999999999)
    @classmethod
    def is_valid_AREAWATER(self,x):
        """Current Water Area"""
        if x is None or x == "None":
            return False
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return (00000000000000 <= x <= 99999999999999)
    @classmethod
    def is_valid_OID(self,x):
        """Object Identifier"""
        if x is None or x == "None":
            return False
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return (0000000000000000000000 <= x <= 9999999999999999999999)

    @classmethod
    def validate_pipe_delimited(self,x):
        fields = x.split('|')
        if len(fields)!=35: return False
        if self.is_valid_MTFCC(fields[0]) == False: return False
        if self.is_valid_VINTAGE(fields[1]) == False: return False
        if self.is_valid_STATEFP(fields[2]) == False: return False
        if self.is_valid_COUNTYFP(fields[3]) == False: return False
        if self.is_valid_GEOCE(fields[4]) == False: return False
        if self.is_valid_GEOFP(fields[5]) == False: return False
        if self.is_valid_GEONS(fields[6]) == False: return False
        if self.is_valid_PARENT(fields[7]) == False: return False
        if self.is_valid_PARENT2(fields[8]) == False: return False
        if self.is_valid_NAME(fields[9]) == False: return False
        if self.is_valid_NAMELSAD(fields[10]) == False: return False
        if self.is_valid_FUNCSTAT(fields[11]) == False: return False
        if self.is_valid_LSADC(fields[12]) == False: return False
        if self.is_valid_PARTFLAG(fields[13]) == False: return False
        if self.is_valid_AIANNHFSR(fields[14]) == False: return False
        if self.is_valid_AIANNHTYP(fields[15]) == False: return False
        if self.is_valid_CLASSFP(fields[16]) == False: return False
        if self.is_valid_STATEUSPS(fields[17]) == False: return False
        if self.is_valid_MEMI(fields[18]) == False: return False
        if self.is_valid_PCICBSA(fields[19]) == False: return False
        if self.is_valid_PCINECTA(fields[20]) == False: return False
        if self.is_valid_CPI(fields[21]) == False: return False
        if self.is_valid_CDSESSN(fields[22]) == False: return False
        if self.is_valid_LSY(fields[23]) == False: return False
        if self.is_valid_VTDI(fields[24]) == False: return False
        if self.is_valid_UR(fields[25]) == False: return False
        if self.is_valid_UATYPE(fields[26]) == False: return False
        if self.is_valid_GCUNI(fields[27]) == False: return False
        if self.is_valid_CENTLAT(fields[28]) == False: return False
        if self.is_valid_CENTLON(fields[29]) == False: return False
        if self.is_valid_INTPTLAT(fields[30]) == False: return False
        if self.is_valid_INTPTLON(fields[31]) == False: return False
        if self.is_valid_AREALAND(fields[32]) == False: return False
        if self.is_valid_AREAWATER(fields[33]) == False: return False
        if self.is_valid_OID(fields[34]) == False: return False
        return True

class L:
    __slots__ = ['MTFCC', 'VINTAGE', 'STATEFP', 'COUNTYFP', 'GEOCE', 'GEOFP', 'GEONS', 'PARENT', 'PARENT2', 'NAME', 'NAMELSAD', 'FUNCSTAT', 'LSADC', 'PARTFLAG', 'AIANNHFSR', 'AIANNHTYP', 'CLASSFP', 'STATEUSPS', 'MEMI', 'PCICBSA', 'PCINECTA', 'CPI', 'CDSESSN', 'LSY', 'VTDI', 'UR', 'UATYPE', 'GCUNI', 'CENTLAT', 'CENTLON', 'INTPTLAT', 'INTPTLON', 'AREALAND', 'AREAWATER', 'OID']
    def __repr__(self):
        return 'L<MTFCC:{},VINTAGE:{},STATEFP:{},COUNTYFP:{},GEOCE:{},GEOFP:{},GEONS:{},PARENT:{},PARENT2:{},NAME:{},NAMELSAD:{},FUNCSTAT:{},LSADC:{},PARTFLAG:{},AIANNHFSR:{},AIANNHTYP:{},CLASSFP:{},STATEUSPS:{},MEMI:{},PCICBSA:{},PCINECTA:{},CPI:{},CDSESSN:{},LSY:{},VTDI:{},UR:{},UATYPE:{},GCUNI:{},CENTLAT:{},CENTLON:{},INTPTLAT:{},INTPTLON:{},AREALAND:{},AREAWATER:{},OID:{}>'.format(self.MTFCC,self.VINTAGE,self.STATEFP,self.COUNTYFP,self.GEOCE,self.GEOFP,self.GEONS,self.PARENT,self.PARENT2,self.NAME,self.NAMELSAD,self.FUNCSTAT,self.LSADC,self.PARTFLAG,self.AIANNHFSR,self.AIANNHTYP,self.CLASSFP,self.STATEUSPS,self.MEMI,self.PCICBSA,self.PCINECTA,self.CPI,self.CDSESSN,self.LSY,self.VTDI,self.UR,self.UATYPE,self.GCUNI,self.CENTLAT,self.CENTLON,self.INTPTLAT,self.INTPTLON,self.AREALAND,self.AREAWATER,self.OID)
    def __init__(self,line=None):
        if line:
            if '|' in line:
                self.parse_pipe_delimited(line)
            else:
                self.parse_column_specified(line)
    @classmethod
    def name(self):
        return 'L'

    def parse_pipe_delimited(self,line):
        fields = line.split('|')
        if len(fields)!=35:
            raise ValueError(f'expected 35 fields, found {len(fields)}')
        self.MTFCC           = fields[0]  # MAF/TIGER Feature Class Code
        self.VINTAGE         = fields[1]  # Vintage
        self.STATEFP         = fields[2]  # State or Equivalent Feature (FIPS)
        self.COUNTYFP        = fields[3]  # County or Equivalent Feature (FIPS)
        self.GEOCE           = fields[4]  # Census Code
        self.GEOFP           = fields[5]  # FIPS Code
        self.GEONS           = fields[6]  # National Standard Code
        self.PARENT          = fields[7]  # Parent Code
        self.PARENT2         = fields[8]  # Parent Code 2
        self.NAME            = fields[9]  # Area Name (without LSADC)
        self.NAMELSAD        = fields[10]  # Area Name and Legal/Statistical Area Description Code
        self.FUNCSTAT        = fields[11]  # Functional Status
        self.LSADC           = fields[12]  # Legal/Statistical Area Description Code
        self.PARTFLAG        = fields[13]  # Part Flag (State)
        self.AIANNHFSR       = fields[14]  # AIANNHA Federal/State Recognition Flag
        self.AIANNHTYP       = fields[15]  # AIANNHA  Entity Type
        self.CLASSFP         = fields[16]  # FIPS 55 Class Code
        self.STATEUSPS       = fields[17]  # State/US Abbreviation
        self.MEMI            = fields[18]  # Metropolitan/Micropolitan Status Indicator
        self.PCICBSA         = fields[19]  # CBSA Principal City Indicator
        self.PCINECTA        = fields[20]  # NECTA Principal City Indicator
        self.CPI             = fields[21]  # Central Place Indicator
        self.CDSESSN         = fields[22]  # Congressional District Session Code
        self.LSY             = fields[23]  # Legislative Session Year
        self.VTDI            = fields[24]  # Voting District Indicator
        self.UR              = fields[25]  # Urban/Rural Indicator
        self.UATYPE          = fields[26]  # Urban Area Type
        self.GCUNI           = fields[27]  # Geographic Change User Note
        self.CENTLAT         = fields[28]  # Centroid (Latitude)
        self.CENTLON         = fields[29]  # Centroid (Longitude)
        self.INTPTLAT        = fields[30]  # Internal Point Latitude
        self.INTPTLON        = fields[31]  # Internal Point Longitude
        self.AREALAND        = fields[32]  # Current Land Area
        self.AREAWATER       = fields[33]  # Current Water Area
        self.OID             = fields[34]  # Object Identifier

    def parse_column_specified(self,line):
        self.MTFCC           = line[0:5] # MAF/TIGER Feature Class Code
        self.VINTAGE         = line[1:3] # Vintage
        self.STATEFP         = line[2:4] # State or Equivalent Feature (FIPS)
        self.COUNTYFP        = line[3:6] # County or Equivalent Feature (FIPS)
        self.GEOCE           = line[4:12] # Census Code
        self.GEOFP           = line[5:10] # FIPS Code
        self.GEONS           = line[6:14] # National Standard Code
        self.PARENT          = line[7:15] # Parent Code
        self.PARENT2         = line[8:16] # Parent Code 2
        self.NAME            = line[9:109] # Area Name (without LSADC)
        self.NAMELSAD        = line[10:110] # Area Name and Legal/Statistical Area Description Code
        self.FUNCSTAT        = line[11:12] # Functional Status
        self.LSADC           = line[12:14] # Legal/Statistical Area Description Code
        self.PARTFLAG        = line[13:14] # Part Flag (State)
        self.AIANNHFSR       = line[14:15] # AIANNHA Federal/State Recognition Flag
        self.AIANNHTYP       = line[15:16] # AIANNHA  Entity Type
        self.CLASSFP         = line[16:18] # FIPS 55 Class Code
        self.STATEUSPS       = line[17:19] # State/US Abbreviation
        self.MEMI            = line[18:19] # Metropolitan/Micropolitan Status Indicator
        self.PCICBSA         = line[19:20] # CBSA Principal City Indicator
        self.PCINECTA        = line[20:21] # NECTA Principal City Indicator
        self.CPI             = line[21:22] # Central Place Indicator
        self.CDSESSN         = line[22:25] # Congressional District Session Code
        self.LSY             = line[23:27] # Legislative Session Year
        self.VTDI            = line[24:25] # Voting District Indicator
        self.UR              = line[25:26] # Urban/Rural Indicator
        self.UATYPE          = line[26:27] # Urban Area Type
        self.GCUNI           = line[27:28] # Geographic Change User Note
        self.CENTLAT         = line[28:39] # Centroid (Latitude)
        self.CENTLON         = line[29:41] # Centroid (Longitude)
        self.INTPTLAT        = line[30:41] # Internal Point Latitude
        self.INTPTLON        = line[31:43] # Internal Point Longitude
        self.AREALAND        = line[32:46] # Current Land Area
        self.AREAWATER       = line[33:47] # Current Water Area
        self.OID             = line[34:56] # Object Identifier

    def validate(self):
        """Return True if the object data validates"""
        if not L_validator.is_valid_MTFCC(self.MTFCC): return False
        if not L_validator.is_valid_VINTAGE(self.VINTAGE): return False
        if not L_validator.is_valid_STATEFP(self.STATEFP): return False
        if not L_validator.is_valid_COUNTYFP(self.COUNTYFP): return False
        if not L_validator.is_valid_GEOCE(self.GEOCE): return False
        if not L_validator.is_valid_GEOFP(self.GEOFP): return False
        if not L_validator.is_valid_GEONS(self.GEONS): return False
        if not L_validator.is_valid_PARENT(self.PARENT): return False
        if not L_validator.is_valid_PARENT2(self.PARENT2): return False
        if not L_validator.is_valid_NAME(self.NAME): return False
        if not L_validator.is_valid_NAMELSAD(self.NAMELSAD): return False
        if not L_validator.is_valid_FUNCSTAT(self.FUNCSTAT): return False
        if not L_validator.is_valid_LSADC(self.LSADC): return False
        if not L_validator.is_valid_PARTFLAG(self.PARTFLAG): return False
        if not L_validator.is_valid_AIANNHFSR(self.AIANNHFSR): return False
        if not L_validator.is_valid_AIANNHTYP(self.AIANNHTYP): return False
        if not L_validator.is_valid_CLASSFP(self.CLASSFP): return False
        if not L_validator.is_valid_STATEUSPS(self.STATEUSPS): return False
        if not L_validator.is_valid_MEMI(self.MEMI): return False
        if not L_validator.is_valid_PCICBSA(self.PCICBSA): return False
        if not L_validator.is_valid_PCINECTA(self.PCINECTA): return False
        if not L_validator.is_valid_CPI(self.CPI): return False
        if not L_validator.is_valid_CDSESSN(self.CDSESSN): return False
        if not L_validator.is_valid_LSY(self.LSY): return False
        if not L_validator.is_valid_VTDI(self.VTDI): return False
        if not L_validator.is_valid_UR(self.UR): return False
        if not L_validator.is_valid_UATYPE(self.UATYPE): return False
        if not L_validator.is_valid_GCUNI(self.GCUNI): return False
        if not L_validator.is_valid_CENTLAT(self.CENTLAT): return False
        if not L_validator.is_valid_CENTLON(self.CENTLON): return False
        if not L_validator.is_valid_INTPTLAT(self.INTPTLAT): return False
        if not L_validator.is_valid_INTPTLON(self.INTPTLON): return False
        if not L_validator.is_valid_AREALAND(self.AREALAND): return False
        if not L_validator.is_valid_AREAWATER(self.AREAWATER): return False
        if not L_validator.is_valid_OID(self.OID): return False
        return True

    def validate_reason(self):
        reason=[]
        if not L_validator.is_valid_MTFCC(self.MTFCC): reason.append('MTFCC ('+str(self.MTFCC)+') out of range (S-S)')
        if not L_validator.is_valid_VINTAGE(self.VINTAGE): reason.append('VINTAGE ('+str(self.VINTAGE)+') out of range ()')
        if not L_validator.is_valid_STATEFP(self.STATEFP): reason.append('STATEFP ('+str(self.STATEFP)+') out of range (S-S)')
        if not L_validator.is_valid_COUNTYFP(self.COUNTYFP): reason.append('COUNTYFP ('+str(self.COUNTYFP)+') out of range ()')
        if not L_validator.is_valid_GEOCE(self.GEOCE): reason.append('GEOCE ('+str(self.GEOCE)+') out of range ()')
        if not L_validator.is_valid_GEOFP(self.GEOFP): reason.append('GEOFP ('+str(self.GEOFP)+') out of range ()')
        if not L_validator.is_valid_GEONS(self.GEONS): reason.append('GEONS ('+str(self.GEONS)+') out of range ()')
        if not L_validator.is_valid_PARENT(self.PARENT): reason.append('PARENT ('+str(self.PARENT)+') out of range ()')
        if not L_validator.is_valid_PARENT2(self.PARENT2): reason.append('PARENT2 ('+str(self.PARENT2)+') out of range ()')
        if not L_validator.is_valid_NAME(self.NAME): reason.append('NAME ('+str(self.NAME)+') out of range ()')
        if not L_validator.is_valid_NAMELSAD(self.NAMELSAD): reason.append('NAMELSAD ('+str(self.NAMELSAD)+') out of range ()')
        if not L_validator.is_valid_FUNCSTAT(self.FUNCSTAT): reason.append('FUNCSTAT ('+str(self.FUNCSTAT)+') out of range ()')
        if not L_validator.is_valid_LSADC(self.LSADC): reason.append('LSADC ('+str(self.LSADC)+') out of range ()')
        if not L_validator.is_valid_PARTFLAG(self.PARTFLAG): reason.append('PARTFLAG ('+str(self.PARTFLAG)+') out of range ()')
        if not L_validator.is_valid_AIANNHFSR(self.AIANNHFSR): reason.append('AIANNHFSR ('+str(self.AIANNHFSR)+') out of range ()')
        if not L_validator.is_valid_AIANNHTYP(self.AIANNHTYP): reason.append('AIANNHTYP ('+str(self.AIANNHTYP)+') out of range ()')
        if not L_validator.is_valid_CLASSFP(self.CLASSFP): reason.append('CLASSFP ('+str(self.CLASSFP)+') out of range ()')
        if not L_validator.is_valid_STATEUSPS(self.STATEUSPS): reason.append('STATEUSPS ('+str(self.STATEUSPS)+') out of range (S-S)')
        if not L_validator.is_valid_MEMI(self.MEMI): reason.append('MEMI ('+str(self.MEMI)+') out of range ()')
        if not L_validator.is_valid_PCICBSA(self.PCICBSA): reason.append('PCICBSA ('+str(self.PCICBSA)+') out of range (S-S)')
        if not L_validator.is_valid_PCINECTA(self.PCINECTA): reason.append('PCINECTA ('+str(self.PCINECTA)+') out of range (S-S)')
        if not L_validator.is_valid_CPI(self.CPI): reason.append('CPI ('+str(self.CPI)+') out of range ()')
        if not L_validator.is_valid_CDSESSN(self.CDSESSN): reason.append('CDSESSN ('+str(self.CDSESSN)+') out of range ()')
        if not L_validator.is_valid_LSY(self.LSY): reason.append('LSY ('+str(self.LSY)+') out of range ()')
        if not L_validator.is_valid_VTDI(self.VTDI): reason.append('VTDI ('+str(self.VTDI)+') out of range ()')
        if not L_validator.is_valid_UR(self.UR): reason.append('UR ('+str(self.UR)+') out of range ()')
        if not L_validator.is_valid_UATYPE(self.UATYPE): reason.append('UATYPE ('+str(self.UATYPE)+') out of range ()')
        if not L_validator.is_valid_GCUNI(self.GCUNI): reason.append('GCUNI ('+str(self.GCUNI)+') out of range ()')
        if not L_validator.is_valid_CENTLAT(self.CENTLAT): reason.append('CENTLAT ('+str(self.CENTLAT)+') out of range (-15.0000000-+72.0000000)')
        if not L_validator.is_valid_CENTLON(self.CENTLON): reason.append('CENTLON ('+str(self.CENTLON)+') out of range (-180.000000--64.0000000, +131.0000000-+179.9999999)')
        if not L_validator.is_valid_INTPTLAT(self.INTPTLAT): reason.append('INTPTLAT ('+str(self.INTPTLAT)+') out of range (-15.0000000-+72.0000000)')
        if not L_validator.is_valid_INTPTLON(self.INTPTLON): reason.append('INTPTLON ('+str(self.INTPTLON)+') out of range (-180.000000--64.0000000, +131.0000000-+179.9999999)')
        if not L_validator.is_valid_AREALAND(self.AREALAND): reason.append('AREALAND ('+str(self.AREALAND)+') out of range (00000000000000-99999999999999)')
        if not L_validator.is_valid_AREAWATER(self.AREAWATER): reason.append('AREAWATER ('+str(self.AREAWATER)+') out of range (00000000000000-99999999999999)')
        if not L_validator.is_valid_OID(self.OID): reason.append('OID ('+str(self.OID)+') out of range (0000000000000000000000-9999999999999999999999)')
        return ', '.join(reason)

    def SparkSQLRow(self):
        """Return a SparkSQL Row object for this object."""
        from pyspark.sql import Row
        return Row(
            mtfcc=safe_str(self.MTFCC),
            vintage=safe_str(self.VINTAGE),
            statefp=safe_str(self.STATEFP),
            countyfp=safe_str(self.COUNTYFP),
            geoce=safe_str(self.GEOCE),
            geofp=safe_str(self.GEOFP),
            geons=safe_str(self.GEONS),
            parent=safe_str(self.PARENT),
            parent2=safe_str(self.PARENT2),
            name=safe_str(self.NAME),
            namelsad=safe_str(self.NAMELSAD),
            funcstat=safe_str(self.FUNCSTAT),
            lsadc=safe_str(self.LSADC),
            partflag=safe_str(self.PARTFLAG),
            aiannhfsr=safe_str(self.AIANNHFSR),
            aiannhtyp=safe_str(self.AIANNHTYP),
            classfp=safe_str(self.CLASSFP),
            stateusps=safe_str(self.STATEUSPS),
            memi=safe_str(self.MEMI),
            pcicbsa=safe_str(self.PCICBSA),
            pcinecta=safe_str(self.PCINECTA),
            cpi=safe_str(self.CPI),
            cdsessn=safe_str(self.CDSESSN),
            lsy=safe_str(self.LSY),
            vtdi=safe_str(self.VTDI),
            ur=safe_str(self.UR),
            uatype=safe_str(self.UATYPE),
            gcuni=safe_str(self.GCUNI),
            centlat=safe_str(self.CENTLAT),
            centlon=safe_str(self.CENTLON),
            intptlat=safe_str(self.INTPTLAT),
            intptlon=safe_str(self.INTPTLON),
            arealand=safe_int(self.AREALAND),
            areawater=safe_int(self.AREAWATER),
            oid=safe_int(self.OID),
        )


    @staticmethod
    def parse_line(line):
        # Read a line and return it as a dictionary.
        inst: L = L()
        inst.parse_column_specified(line)
        assert inst.validate(), f'A line is invalid!! line: {line}, validate_reason: {inst.validate_reason()}'
        row = inst.SparkSQLRow()
        return row

    @staticmethod
    def parse_piped_line(line):
        # Read a pipe-delimited line and return it as a dictionary.
        inst: L = L()
        inst.parse_pipe_delimited(line)
        assert inst.validate(), f'A line is invalid!! line: {line}, validate_reason: {inst.validate_reason()}'
        row = inst.SparkSQLRow()
        return row



# Automatically generated on Fri Oct 30 14:06:06 2020 by /mnt/users/user007/new-das-vm/das-vm-config/das_decennial/das_framework/ctools/schema/table.py

def leftpad(x,width):
    return ' '*(width-len(str(x)))+str(x)

def between(a,b,c,width):
    if len(b) > width:
        return False
    if '.' in a or '.' in b or '.' in c:
        try:
            return float(a) <= float(b) <= float(c)
        except ValueError:
            pass  # tries to return a float but might have weird input like 1.1.0 which will be compared traditionally instead
    b = b.replace(' ', '0')
    return leftpad(a,width) <= leftpad(b,width) <= leftpad(c,width)


def safe_int(i):
    try:
        return int(i)
    except (TypeError, ValueError):
        return None

def safe_float(i):
    try:
        return float(i)
    except (TypeError, ValueError):
        return None

def safe_str(i):
    try:
        return str(i)
    except (TypeError, ValueError):
        return None


class O_validator:
    @classmethod
    def is_valid_MAFID(self,x):
        """Permanent MAFUNIT ID"""
        if x is None or x == "None":
            return False
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return True
    @classmethod
    def is_valid_ACTION(self,x):
        """Action Code"""
        if x is None or x == "None":
            return False
        return (leftpad(x,8)==leftpad('A',8))
    @classmethod
    def is_valid_UNITSTAT(self,x):
        """Unit Status Code"""
        if x is None or x == "None":
            return False
        return (leftpad(x,8)==leftpad('01',8))
    @classmethod
    def is_valid_GQHUFLAG(self,x):
        """Group Quarters/HU Flag"""
        if x is None or x == "None":
            return False
        return (leftpad(x,8)==leftpad('N',8))
    @classmethod
    def is_valid_REJECT(self,x):
        """ADDUP Reject Code Values"""
        if x is None or x == "None":
            return False
        return (leftpad(x,8)==leftpad('N',8))
    @classmethod
    def is_valid_MAFSRC(self,x):
        """MAF Source Code"""
        if x is None or x == "None":
            return False
        return (leftpad(x,8)==leftpad('183',8))

    @classmethod
    def validate_pipe_delimited(self,x):
        fields = x.split('|')
        if len(fields)!=6: return False
        if self.is_valid_MAFID(fields[0]) == False: return False
        if self.is_valid_ACTION(fields[1]) == False: return False
        if self.is_valid_UNITSTAT(fields[2]) == False: return False
        if self.is_valid_GQHUFLAG(fields[3]) == False: return False
        if self.is_valid_REJECT(fields[4]) == False: return False
        if self.is_valid_MAFSRC(fields[5]) == False: return False
        return True

class O:
    __slots__ = ['MAFID', 'ACTION', 'UNITSTAT', 'GQHUFLAG', 'REJECT', 'MAFSRC']
    def __repr__(self):
        return 'O<MAFID:{},ACTION:{},UNITSTAT:{},GQHUFLAG:{},REJECT:{},MAFSRC:{}>'.format(self.MAFID,self.ACTION,self.UNITSTAT,self.GQHUFLAG,self.REJECT,self.MAFSRC)
    def __init__(self,line=None):
        if line:
            if '|' in line:
                self.parse_pipe_delimited(line)
            else:
                self.parse_column_specified(line)
    @classmethod
    def name(self):
        return 'O'

    def parse_pipe_delimited(self,line):
        fields = line.split('|')
        if len(fields)!=6:
            raise ValueError(f'expected 6 fields, found {len(fields)}')
        self.MAFID           = fields[0]  # Permanent MAFUNIT ID
        self.ACTION          = fields[1]  # Action Code
        self.UNITSTAT        = fields[2]  # Unit Status Code
        self.GQHUFLAG        = fields[3]  # Group Quarters/HU Flag
        self.REJECT          = fields[4]  # ADDUP Reject Code Values
        self.MAFSRC          = fields[5]  # MAF Source Code

    def parse_column_specified(self,line):
        self.MAFID           = None   # no column information for MAFID
        self.ACTION          = None   # no column information for ACTION
        self.UNITSTAT        = None   # no column information for UNITSTAT
        self.GQHUFLAG        = None   # no column information for GQHUFLAG
        self.REJECT          = None   # no column information for REJECT
        self.MAFSRC          = None   # no column information for MAFSRC

    def validate(self):
        """Return True if the object data validates"""
        if not O_validator.is_valid_MAFID(self.MAFID): return False
        if not O_validator.is_valid_ACTION(self.ACTION): return False
        if not O_validator.is_valid_UNITSTAT(self.UNITSTAT): return False
        if not O_validator.is_valid_GQHUFLAG(self.GQHUFLAG): return False
        if not O_validator.is_valid_REJECT(self.REJECT): return False
        if not O_validator.is_valid_MAFSRC(self.MAFSRC): return False
        return True

    def validate_reason(self):
        reason=[]
        if not O_validator.is_valid_MAFID(self.MAFID): reason.append('MAFID ('+str(self.MAFID)+') out of range ()')
        if not O_validator.is_valid_ACTION(self.ACTION): reason.append('ACTION ('+str(self.ACTION)+') out of range (A-A)')
        if not O_validator.is_valid_UNITSTAT(self.UNITSTAT): reason.append('UNITSTAT ('+str(self.UNITSTAT)+') out of range (01-01)')
        if not O_validator.is_valid_GQHUFLAG(self.GQHUFLAG): reason.append('GQHUFLAG ('+str(self.GQHUFLAG)+') out of range (N-N)')
        if not O_validator.is_valid_REJECT(self.REJECT): reason.append('REJECT ('+str(self.REJECT)+') out of range (N-N)')
        if not O_validator.is_valid_MAFSRC(self.MAFSRC): reason.append('MAFSRC ('+str(self.MAFSRC)+') out of range (183-183)')
        return ', '.join(reason)

    def SparkSQLRow(self):
        """Return a SparkSQL Row object for this object."""
        from pyspark.sql import Row
        return Row(
            mafid=safe_int(self.MAFID),
            action=safe_str(self.ACTION),
            unitstat=safe_str(self.UNITSTAT),
            gqhuflag=safe_str(self.GQHUFLAG),
            reject=safe_str(self.REJECT),
            mafsrc=safe_str(self.MAFSRC),
        )


    @staticmethod
    def parse_line(line):
        # Read a line and return it as a dictionary.
        inst: O = O()
        inst.parse_column_specified(line)
        assert inst.validate(), f'A line is invalid!! line: {line}, validate_reason: {inst.validate_reason()}'
        row = inst.SparkSQLRow()
        return row

    @staticmethod
    def parse_piped_line(line):
        # Read a pipe-delimited line and return it as a dictionary.
        inst: O = O()
        inst.parse_pipe_delimited(line)
        assert inst.validate(), f'A line is invalid!! line: {line}, validate_reason: {inst.validate_reason()}'
        row = inst.SparkSQLRow()
        return row



# Automatically generated on Fri Oct 30 14:06:06 2020 by /mnt/users/user007/new-das-vm/das-vm-config/das_decennial/das_framework/ctools/schema/table.py

def leftpad(x,width):
    return ' '*(width-len(str(x)))+str(x)

def between(a,b,c,width):
    if len(b) > width:
        return False
    if '.' in a or '.' in b or '.' in c:
        try:
            return float(a) <= float(b) <= float(c)
        except ValueError:
            pass  # tries to return a float but might have weird input like 1.1.0 which will be compared traditionally instead
    b = b.replace(' ', '0')
    return leftpad(a,width) <= leftpad(b,width) <= leftpad(c,width)


def safe_int(i):
    try:
        return int(i)
    except (TypeError, ValueError):
        return None

def safe_float(i):
    try:
        return float(i)
    except (TypeError, ValueError):
        return None

def safe_str(i):
    try:
        return str(i)
    except (TypeError, ValueError):
        return None


class P_validator:
    @classmethod
    def is_valid_MAFID(self,x):
        """Master Address File Identifier"""
        if x is None or x == "None":
            return False
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return True
    @classmethod
    def is_valid_STATE(self,x):
        """State GEO_ID"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_COUNTY(self,x):
        """County GEO_ID"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_TRACT(self,x):
        """Census tract GEO_ID"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_COUSUB(self,x):
        """County subdivision GEO_ID"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_PLACE(self,x):
        """Place GEO_ID"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_CONCITY(self,x):
        """Consolidated city GEO_ID"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_AIANNH(self,x):
        """American Indian/Alaska Native/Native Hawaiian area GEO_ID"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_TRIBALCT(self,x):
        """Tribal census tract GEO_ID"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_CD(self,x):
        """Congressional district GEO_ID"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_REGION(self,x):
        """Region GEO_ID"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True
    @classmethod
    def is_valid_ACO(self,x):
        """ACO code"""
        if x is None or x == "None" or len(x) == 0:
            return True
        return True

    @classmethod
    def validate_pipe_delimited(self,x):
        fields = x.split('|')
        if len(fields)!=12: return False
        if self.is_valid_MAFID(fields[0]) == False: return False
        if self.is_valid_STATE(fields[1]) == False: return False
        if self.is_valid_COUNTY(fields[2]) == False: return False
        if self.is_valid_TRACT(fields[3]) == False: return False
        if self.is_valid_COUSUB(fields[4]) == False: return False
        if self.is_valid_PLACE(fields[5]) == False: return False
        if self.is_valid_CONCITY(fields[6]) == False: return False
        if self.is_valid_AIANNH(fields[7]) == False: return False
        if self.is_valid_TRIBALCT(fields[8]) == False: return False
        if self.is_valid_CD(fields[9]) == False: return False
        if self.is_valid_REGION(fields[10]) == False: return False
        if self.is_valid_ACO(fields[11]) == False: return False
        return True

class P:
    __slots__ = ['MAFID', 'STATE', 'COUNTY', 'TRACT', 'COUSUB', 'PLACE', 'CONCITY', 'AIANNH', 'TRIBALCT', 'CD', 'REGION', 'ACO']
    def __repr__(self):
        return 'P<MAFID:{},STATE:{},COUNTY:{},TRACT:{},COUSUB:{},PLACE:{},CONCITY:{},AIANNH:{},TRIBALCT:{},CD:{},REGION:{},ACO:{}>'.format(self.MAFID,self.STATE,self.COUNTY,self.TRACT,self.COUSUB,self.PLACE,self.CONCITY,self.AIANNH,self.TRIBALCT,self.CD,self.REGION,self.ACO)
    def __init__(self,line=None):
        if line:
            if '|' in line:
                self.parse_pipe_delimited(line)
            else:
                self.parse_column_specified(line)
    @classmethod
    def name(self):
        return 'P'

    def parse_pipe_delimited(self,line):
        fields = line.split('|')
        if len(fields)!=12:
            raise ValueError(f'expected 12 fields, found {len(fields)}')
        self.MAFID           = fields[0]  # Master Address File Identifier
        self.STATE           = fields[1]  # State GEO_ID
        self.COUNTY          = fields[2]  # County GEO_ID
        self.TRACT           = fields[3]  # Census tract GEO_ID
        self.COUSUB          = fields[4]  # County subdivision GEO_ID
        self.PLACE           = fields[5]  # Place GEO_ID
        self.CONCITY         = fields[6]  # Consolidated city GEO_ID
        self.AIANNH          = fields[7]  # American Indian/Alaska Native/Native Hawaiian area GEO_ID
        self.TRIBALCT        = fields[8]  # Tribal census tract GEO_ID
        self.CD              = fields[9]  # Congressional district GEO_ID
        self.REGION          = fields[10]  # Region GEO_ID
        self.ACO             = fields[11]  # ACO code

    def parse_column_specified(self,line):
        self.MAFID           = line[0:9] # Master Address File Identifier
        self.STATE           = line[1:12] # State GEO_ID
        self.COUNTY          = line[2:16] # County GEO_ID
        self.TRACT           = line[3:23] # Census tract GEO_ID
        self.COUSUB          = line[4:23] # County subdivision GEO_ID
        self.PLACE           = line[5:21] # Place GEO_ID
        self.CONCITY         = line[6:22] # Consolidated city GEO_ID
        self.AIANNH          = line[7:20] # American Indian/Alaska Native/Native Hawaiian area GEO_ID
        self.TRIBALCT        = line[8:27] # Tribal census tract GEO_ID
        self.CD              = line[9:22] # Congressional district GEO_ID
        self.REGION          = line[10:20] # Region GEO_ID
        self.ACO             = line[11:15] # ACO code

    def validate(self):
        """Return True if the object data validates"""
        if not P_validator.is_valid_MAFID(self.MAFID): return False
        if not P_validator.is_valid_STATE(self.STATE): return False
        if not P_validator.is_valid_COUNTY(self.COUNTY): return False
        if not P_validator.is_valid_TRACT(self.TRACT): return False
        if not P_validator.is_valid_COUSUB(self.COUSUB): return False
        if not P_validator.is_valid_PLACE(self.PLACE): return False
        if not P_validator.is_valid_CONCITY(self.CONCITY): return False
        if not P_validator.is_valid_AIANNH(self.AIANNH): return False
        if not P_validator.is_valid_TRIBALCT(self.TRIBALCT): return False
        if not P_validator.is_valid_CD(self.CD): return False
        if not P_validator.is_valid_REGION(self.REGION): return False
        if not P_validator.is_valid_ACO(self.ACO): return False
        return True

    def validate_reason(self):
        reason=[]
        if not P_validator.is_valid_MAFID(self.MAFID): reason.append('MAFID ('+str(self.MAFID)+') out of range ()')
        if not P_validator.is_valid_STATE(self.STATE): reason.append('STATE ('+str(self.STATE)+') out of range ()')
        if not P_validator.is_valid_COUNTY(self.COUNTY): reason.append('COUNTY ('+str(self.COUNTY)+') out of range ()')
        if not P_validator.is_valid_TRACT(self.TRACT): reason.append('TRACT ('+str(self.TRACT)+') out of range ()')
        if not P_validator.is_valid_COUSUB(self.COUSUB): reason.append('COUSUB ('+str(self.COUSUB)+') out of range ()')
        if not P_validator.is_valid_PLACE(self.PLACE): reason.append('PLACE ('+str(self.PLACE)+') out of range ()')
        if not P_validator.is_valid_CONCITY(self.CONCITY): reason.append('CONCITY ('+str(self.CONCITY)+') out of range ()')
        if not P_validator.is_valid_AIANNH(self.AIANNH): reason.append('AIANNH ('+str(self.AIANNH)+') out of range ()')
        if not P_validator.is_valid_TRIBALCT(self.TRIBALCT): reason.append('TRIBALCT ('+str(self.TRIBALCT)+') out of range ()')
        if not P_validator.is_valid_CD(self.CD): reason.append('CD ('+str(self.CD)+') out of range ()')
        if not P_validator.is_valid_REGION(self.REGION): reason.append('REGION ('+str(self.REGION)+') out of range ()')
        if not P_validator.is_valid_ACO(self.ACO): reason.append('ACO ('+str(self.ACO)+') out of range ()')
        return ', '.join(reason)

    def SparkSQLRow(self):
        """Return a SparkSQL Row object for this object."""
        from pyspark.sql import Row
        return Row(
            mafid=safe_int(self.MAFID),
            state=safe_str(self.STATE),
            county=safe_str(self.COUNTY),
            tract=safe_str(self.TRACT),
            cousub=safe_str(self.COUSUB),
            place=safe_str(self.PLACE),
            concity=safe_str(self.CONCITY),
            aiannh=safe_str(self.AIANNH),
            tribalct=safe_str(self.TRIBALCT),
            cd=safe_str(self.CD),
            region=safe_str(self.REGION),
            aco=safe_str(self.ACO),
        )


    @staticmethod
    def parse_line(line):
        # Read a line and return it as a dictionary.
        inst: P = P()
        inst.parse_column_specified(line)
        assert inst.validate(), f'A line is invalid!! line: {line}, validate_reason: {inst.validate_reason()}'
        row = inst.SparkSQLRow()
        return row

    @staticmethod
    def parse_piped_line(line):
        # Read a pipe-delimited line and return it as a dictionary.
        inst: P = P()
        inst.parse_pipe_delimited(line)
        assert inst.validate(), f'A line is invalid!! line: {line}, validate_reason: {inst.validate_reason()}'
        row = inst.SparkSQLRow()
        return row



SPEC_CLASS_OBJECTS = [E(),I(),G(),GRFC20(),L(),O(),P()]
null = None
SPEC_DICT = {"tables": {"E": {"name": "E", "variables": [{"name": "ABRAF", "vtype": "VARCHAR", "position": 0, "desc": "Active Block Resolution Address Filter Flag", "column": 0, "width": 1, "ranges": []}, {"name": "ACOCE", "vtype": "VARCHAR", "position": 1, "desc": "Area Census Office", "column": 1, "width": 4, "ranges": [{"a": "2501", "b": "2599"}, {"a": "4030", "b": "4030"}, {"a": "3600", "b": "3600"}, {"a": "4000", "b": "4000"}, {"a": "3400", "b": "3400"}, {"a": "4020", "b": "4020"}, {"a": "3500", "b": "3500"}, {"a": "4010", "b": "4010"}, {"a": "4040", "b": "4040"}, {"a": "3201", "b": "3299"}, {"a": "2301", "b": "2399"}, {"a": "2901", "b": "2999"}, {"a": "3101", "b": "3199"}, {"a": "2201", "b": "2299"}]}, {"name": "BCUCOUNTYFP", "vtype": "VARCHAR", "position": 2, "desc": "FIPS County Code", "column": 2, "width": 3, "ranges": [{"a": "001", "b": "840"}]}, {"name": "BCUID", "vtype": "VARCHAR", "position": 3, "desc": "Basic Collection Unit Identification Code", "column": 3, "width": 8, "ranges": [{"a": "00000100", "b": "99999999"}]}, {"name": "BCUSTATEFP", "vtype": "VARCHAR", "position": 4, "desc": "FIPS State Code", "column": 4, "width": 2, "ranges": [{"a": "02", "b": "02"}, {"a": "66", "b": "66"}, {"a": "60", "b": "60"}, {"a": "44", "b": "51"}, {"a": "72", "b": "72"}, {"a": "74", "b": "74"}, {"a": "78", "b": "78"}, {"a": "69", "b": "69"}, {"a": "08", "b": "13"}, {"a": "01", "b": "01"}, {"a": "15", "b": "42"}, {"a": "04", "b": "06"}, {"a": "53", "b": "56"}]}, {"name": "BCUTRACTCE", "vtype": "VARCHAR", "position": 5, "desc": "Census Tract Code", "column": 5, "width": 6, "ranges": [{"a": "000100", "b": "998999"}]}, {"name": "CARRETERA", "vtype": "VARCHAR", "position": 6, "desc": "Carretera", "column": 6, "width": 20, "ranges": []}, {"name": "CENSTAT2010", "vtype": "VARCHAR", "position": 7, "desc": "Official Census 2010 enumeration status of this MAFID, as obtained from the Census 2010 Decennial Master Address File (DMAF)", "column": 7, "width": 1, "ranges": [{"a": "4", "b": "4"}, {"a": "3", "b": "3"}, {"a": "1", "b": "1"}, {"a": "5", "b": "5"}, {"a": "8", "b": "8"}, {"a": "6", "b": "6"}, {"a": "7", "b": "7"}, {"a": "2", "b": "2"}, {"a": "0", "b": "0"}]}, {"name": "CENSTAT2020", "vtype": "VARCHAR", "position": 8, "desc": "Official Census 2020 enumeration status", "column": 8, "width": 2, "ranges": []}, {"name": "CENSURV", "vtype": "VARCHAR", "position": 9, "desc": "Survivor of a Census Address Flag", "column": 9, "width": 1, "ranges": [{"a": "2", "b": "2"}, {"a": "1", "b": "1"}, {"a": "0", "b": "0"}]}, {"name": "CENSUS2010", "vtype": "VARCHAR", "position": 10, "desc": "Census 2010 Unit Flag", "column": 10, "width": 1, "ranges": [{"a": "Y", "b": "Y"}, {"a": "N", "b": "N"}]}, {"name": "CENSUS2020", "vtype": "VARCHAR", "position": 11, "desc": "Census 2020 Unit Flag", "column": 11, "width": 1, "ranges": [{"a": "Y", "b": "Y"}, {"a": "N", "b": "N"}]}, {"name": "CENSUSAF", "vtype": "VARCHAR", "position": 12, "desc": "Decennial Listing Filter Flag", "column": 12, "width": 1, "ranges": [{"a": "1", "b": "1"}, {"a": "0", "b": "0"}]}, {"name": "CFUFVAF", "vtype": "VARCHAR", "position": 13, "desc": "2010 Coverage Followup/Field Verification Address Filter Flag", "column": 13, "width": 1, "ranges": []}, {"name": "COLLAF", "vtype": "VARCHAR", "position": 14, "desc": "2010 Final Collection Address Filter Flag", "column": 14, "width": 1, "ranges": []}, {"name": "COLLUNV", "vtype": "VARCHAR", "position": 15, "desc": "Final Collection Universe Flag", "column": 15, "width": 1, "ranges": [{"a": "Y", "b": "Y"}, {"a": "N", "b": "N"}]}, {"name": "COMPLETELOCNAME", "vtype": "VARCHAR", "position": 16, "desc": "The Complete Location Display Name", "column": 16, "width": 100, "ranges": []}, {"name": "COMPLETEMAILNAME", "vtype": "VARCHAR", "position": 17, "desc": "The Complete Mailing Display Name", "column": 17, "width": 100, "ranges": []}, {"name": "CONTITLE", "vtype": "VARCHAR", "position": 18, "desc": "Title of Contact Person", "column": 18, "width": 50, "ranges": []}, {"name": "COORDTYP", "vtype": "VARCHAR", "position": 19, "desc": "Coordinate Collection Type", "column": 19, "width": 1, "ranges": [{"a": "D", "b": "D"}, {"a": "I", "b": "I"}, {"a": "L", "b": "L"}, {"a": "G", "b": "G"}, {"a": "O", "b": "O"}, {"a": "P", "b": "P"}, {"a": "R", "b": "R"}, {"a": "S", "b": "S"}, {"a": "M", "b": "M"}, {"a": "W", "b": "W"}, {"a": "E", "b": "E"}, {"a": "Q", "b": "Q"}]}, {"name": "CURBLK", "vtype": "VARCHAR", "position": 20, "desc": "Current Block \u2013 Census Block Number", "column": 20, "width": 4, "ranges": []}, {"name": "CURBLKCOU", "vtype": "VARCHAR", "position": 21, "desc": "Current Block \u2013 FIPS County Code", "column": 21, "width": 3, "ranges": [{"a": "001", "b": "840"}]}, {"name": "CURBLKST", "vtype": "VARCHAR", "position": 22, "desc": "Current Block \u2013 FIPS State Code", "column": 22, "width": 2, "ranges": [{"a": "02", "b": "02"}, {"a": "66", "b": "66"}, {"a": "60", "b": "60"}, {"a": "44", "b": "51"}, {"a": "72", "b": "72"}, {"a": "74", "b": "74"}, {"a": "78", "b": "78"}, {"a": "69", "b": "69"}, {"a": "08", "b": "13"}, {"a": "01", "b": "01"}, {"a": "15", "b": "42"}, {"a": "04", "b": "06"}, {"a": "53", "b": "56"}]}, {"name": "CURBLKSUFX1", "vtype": "VARCHAR", "position": 23, "desc": "Current Block \u2013 Block Suffix 1", "column": 23, "width": 1, "ranges": [{"a": "A", "b": "Z"}]}, {"name": "CURBLKSUFX2", "vtype": "VARCHAR", "position": 24, "desc": "Current Block \u2013 Block Suffix 2", "column": 24, "width": 1, "ranges": [{"a": "A", "b": "Z"}]}, {"name": "CURBLKTRACT", "vtype": "VARCHAR", "position": 25, "desc": "Current Block \u2013 Census Tract Code", "column": 25, "width": 6, "ranges": [{"a": "000100", "b": "998999"}]}, {"name": "CURCOUNTY", "vtype": "VARCHAR", "position": 26, "desc": "Current FIPS County Code", "column": 26, "width": 3, "ranges": [{"a": "001", "b": "840"}]}, {"name": "CURSTATE", "vtype": "VARCHAR", "position": 27, "desc": "Current FIPS State Code", "column": 27, "width": 2, "ranges": [{"a": "02", "b": "02"}, {"a": "66", "b": "66"}, {"a": "60", "b": "60"}, {"a": "44", "b": "51"}, {"a": "72", "b": "72"}, {"a": "74", "b": "74"}, {"a": "78", "b": "78"}, {"a": "69", "b": "69"}, {"a": "08", "b": "13"}, {"a": "01", "b": "01"}, {"a": "15", "b": "42"}, {"a": "04", "b": "06"}, {"a": "53", "b": "56"}]}, {"name": "DELPTTYPE", "vtype": "VARCHAR", "position": 28, "desc": "DSF Delivery Point Type", "column": 28, "width": 1, "ranges": [{"a": "D", "b": "D"}, {"a": "4", "b": "4"}, {"a": "8", "b": "8"}, {"a": "K", "b": "K"}, {"a": "B", "b": "B"}, {"a": "H", "b": "H"}, {"a": "N", "b": "N"}, {"a": "O", "b": "O"}, {"a": "V", "b": "V"}, {"a": "Z", "b": "Z"}, {"a": "F", "b": "F"}, {"a": "I", "b": "I"}, {"a": "J", "b": "J"}, {"a": "L", "b": "L"}, {"a": "R", "b": "R"}, {"a": "7", "b": "7"}, {"a": "C", "b": "C"}, {"a": "2", "b": "2"}, {"a": "T", "b": "T"}, {"a": "6", "b": "6"}, {"a": "W", "b": "W"}, {"a": "1", "b": "1"}, {"a": "A", "b": "A"}, {"a": "5", "b": "5"}, {"a": "3", "b": "3"}, {"a": "G", "b": "G"}, {"a": "P", "b": "P"}, {"a": "U", "b": "U"}, {"a": "Y", "b": "Y"}, {"a": "S", "b": "S"}, {"a": "M", "b": "M"}, {"a": "E", "b": "E"}, {"a": "X", "b": "X"}]}, {"name": "DSAF", "vtype": "VARCHAR", "position": 29, "desc": "Delivery Specific Address Flag", "column": 29, "width": 1, "ranges": [{"a": "2", "b": "2"}, {"a": "4", "b": "4"}, {"a": "3", "b": "3"}, {"a": "1", "b": "1"}]}, {"name": "DSFBASEALT", "vtype": "VARCHAR", "position": 30, "desc": "Alternate/Base Flag", "column": 30, "width": 1, "ranges": [{"a": "B", "b": "B"}, {"a": "A", "b": "A"}]}, {"name": "DSFFALLAST", "vtype": "VARCHAR", "position": 31, "desc": "Most Recent Fall DSF Value", "column": 31, "width": 1, "ranges": []}, {"name": "DSFRT", "vtype": "VARCHAR", "position": 32, "desc": "DSF Record Type", "column": 32, "width": 1, "ranges": [{"a": "G", "b": "G"}, {"a": "F", "b": "F"}, {"a": "P", "b": "P"}, {"a": "R", "b": "R"}, {"a": "H", "b": "H"}, {"a": "S", "b": "S"}]}, {"name": "DSFSPRLAST", "vtype": "VARCHAR", "position": 33, "desc": "Most Recent Spring DSF Value", "column": 33, "width": 1, "ranges": []}, {"name": "ENUMAF", "vtype": "VARCHAR", "position": 34, "desc": "Current Enumeration Universe Address Filter Flag", "column": 34, "width": 1, "ranges": [{"a": "1", "b": "1"}, {"a": "0", "b": "0"}]}, {"name": "ENUMAF2010", "vtype": "VARCHAR", "position": 35, "desc": "2010 Enumeration Universe Address Filter Flag", "column": 35, "width": 1, "ranges": []}, {"name": "ENUMUNV", "vtype": "VARCHAR", "position": 36, "desc": "Enumeration Universe Flag", "column": 36, "width": 1, "ranges": [{"a": "G", "b": "G"}, {"a": "N", "b": "N"}, {"a": "T", "b": "T"}, {"a": "H", "b": "H"}]}, {"name": "FACTLNAME", "vtype": "VARCHAR", "position": 37, "desc": "Facility Name for Group Quarters/Transitory Location Name", "column": 37, "width": 100, "ranges": []}, {"name": "GQAREACODE", "vtype": "VARCHAR", "position": 38, "desc": "GQ Area Code", "column": 38, "width": 3, "ranges": []}, {"name": "GQCONTACT", "vtype": "VARCHAR", "position": 39, "desc": "GQ Contact", "column": 39, "width": 35, "ranges": []}, {"name": "GQCURRMAXPOP", "vtype": "NUMBER", "position": 40, "desc": "Maximum number of persons at the GQ", "column": 40, "width": 5, "ranges": []}, {"name": "GQCURRSIZE", "vtype": "NUMBER", "position": 41, "desc": "A count at the GQ from the last ACS or Current Surveys visit", "column": 41, "width": 5, "ranges": []}, {"name": "GQEXT", "vtype": "VARCHAR", "position": 42, "desc": "GQ Phone Number Extension", "column": 42, "width": 8, "ranges": []}, {"name": "GQHUFLAG", "vtype": "VARCHAR", "position": 43, "desc": "Group Quarters/HU Flag", "column": 43, "width": 1, "ranges": [{"a": "5", "b": "5"}, {"a": "4", "b": "4"}, {"a": "3", "b": "3"}, {"a": "2", "b": "2"}, {"a": "0", "b": "0"}]}, {"name": "GQID", "vtype": "NUMBER", "position": 44, "desc": "Group Quarters ID", "column": 44, "width": 4, "ranges": [{"a": "1", "b": "9999"}]}, {"name": "GQNAME", "vtype": "VARCHAR", "position": 45, "desc": "Group Quarters Name", "column": 45, "width": 100, "ranges": []}, {"name": "GQPHONE", "vtype": "VARCHAR", "position": 46, "desc": "GQ Phone Number", "column": 46, "width": 8, "ranges": []}, {"name": "GQTYPCUR", "vtype": "VARCHAR", "position": 47, "desc": "Current Group Quarters Type code", "column": 47, "width": 3, "ranges": [{"a": "602", "b": "602"}, {"a": "703", "b": "703"}, {"a": "103", "b": "103"}, {"a": "301", "b": "301"}, {"a": "802", "b": "802"}, {"a": "902", "b": "902"}, {"a": "105", "b": "105"}, {"a": "104", "b": "104"}, {"a": "706", "b": "706"}, {"a": "900", "b": "900"}, {"a": "601", "b": "601"}, {"a": "0", "b": "0"}, {"a": "502", "b": "502"}, {"a": "101", "b": "101"}, {"a": "999", "b": "999"}, {"a": "404", "b": "404"}, {"a": "201", "b": "201"}, {"a": "106", "b": "106"}, {"a": "702", "b": "702"}, {"a": "202", "b": "202"}, {"a": "501", "b": "501"}, {"a": "704", "b": "704"}, {"a": "801", "b": "801"}, {"a": "901", "b": "901"}, {"a": "903", "b": "903"}, {"a": "102", "b": "102"}, {"a": "701", "b": "701"}, {"a": "401", "b": "401"}, {"a": "402", "b": "402"}, {"a": "403", "b": "403"}, {"a": "405", "b": "405"}, {"a": "203", "b": "203"}]}, {"name": "HUTYP", "vtype": "VARCHAR", "position": 48, "desc": "Housing unit type", "column": 48, "width": 1, "ranges": [{"a": "M", "b": "M"}, {"a": "T", "b": "T"}, {"a": "S", "b": "S"}, {"a": "O", "b": "O"}]}, {"name": "INITUCMAF", "vtype": "VARCHAR", "position": 49, "desc": "Initial UC & M Universe Address Filter Flag", "column": 49, "width": 1, "ranges": [{"a": "4", "b": "4"}, {"a": "3", "b": "3"}, {"a": "1", "b": "1"}, {"a": "5", "b": "5"}, {"a": "6", "b": "6"}, {"a": "2", "b": "2"}, {"a": "0", "b": "0"}]}, {"name": "INSITE", "vtype": "VARCHAR", "position": 50, "desc": "Test Site Flag", "column": 50, "width": 1, "ranges": [{"a": "Y", "b": "Y"}, {"a": "N", "b": "N"}, {"a": "1", "b": "1"}, {"a": "0", "b": "0"}]}, {"name": "IOACIRAF", "vtype": "VARCHAR", "position": 51, "desc": "In-Office Canvassing Interactive Review Address Filter Flag", "column": 51, "width": 1, "ranges": []}, {"name": "IS2020DLV", "vtype": "VARCHAR", "position": 52, "desc": "2020 Census Deliverable Flag", "column": 52, "width": 1, "ranges": [{"a": "Y", "b": "Y"}, {"a": "N", "b": "N"}]}, {"name": "ISOLQ", "vtype": "VARCHAR", "position": 53, "desc": "Military Address Flag", "column": 53, "width": 1, "ranges": [{"a": "1", "b": "1"}]}, {"name": "ISUCMDLV", "vtype": "VARCHAR", "position": 54, "desc": "2010 UC&M Deliverable Flag", "column": 54, "width": 1, "ranges": [{"a": "Y", "b": "Y"}, {"a": "N", "b": "N"}]}, {"name": "KMHM", "vtype": "VARCHAR", "position": 55, "desc": "Kilometer/Hectometer Marker", "column": 55, "width": 12, "ranges": []}, {"name": "LEGACYMAFID", "vtype": "VARCHAR", "position": 56, "desc": "Field that stores the Legacy Within-County MAFID", "column": 56, "width": 12, "ranges": []}, {"name": "LIMADEL", "vtype": "VARCHAR", "position": 57, "desc": "LIMA Delivery Flag", "column": 57, "width": 1, "ranges": []}, {"name": "LOCAPTCOMPLEX", "vtype": "VARCHAR", "position": 58, "desc": "Location Address \u2013 Name of an apartment Complex, subdivision, named development, or mobile park", "column": 58, "width": 100, "ranges": []}, {"name": "LOCAREANM1", "vtype": "VARCHAR", "position": 59, "desc": "Location Area Name Part 1 (Puerto Rico-only)", "column": 59, "width": 50, "ranges": []}, {"name": "LOCAREANM2", "vtype": "VARCHAR", "position": 60, "desc": "Location Area Name Part 2 (Puerto Rico-only)", "column": 60, "width": 50, "ranges": []}, {"name": "LOCBLDGDESC", "vtype": "VARCHAR", "position": 61, "desc": "Location Address Building Descriptor", "column": 61, "width": 10, "ranges": []}, {"name": "LOCBLDGID", "vtype": "VARCHAR", "position": 62, "desc": "Location Address Building Identifier", "column": 62, "width": 12, "ranges": []}, {"name": "LOCDESC", "vtype": "VARCHAR", "position": 63, "desc": "Location Description", "column": 63, "width": 100, "ranges": []}, {"name": "LOCHN1", "vtype": "VARCHAR", "position": 64, "desc": "Location Address First Part of House Number", "column": 64, "width": 12, "ranges": []}, {"name": "LOCHN2", "vtype": "VARCHAR", "position": 65, "desc": "Location address Second Part of House Number", "column": 65, "width": 12, "ranges": []}, {"name": "LOCHNPR", "vtype": "VARCHAR", "position": 66, "desc": "Location Address \u2013 House Number (Puerto Rico)", "column": 66, "width": 20, "ranges": []}, {"name": "LOCHNPRE", "vtype": "VARCHAR", "position": 67, "desc": "Location Address House Number Prefix", "column": 67, "width": 2, "ranges": []}, {"name": "LOCHNSEP", "vtype": "VARCHAR", "position": 68, "desc": "Location Address House Number Separator", "column": 68, "width": 2, "ranges": []}, {"name": "LOCHNSUF", "vtype": "VARCHAR", "position": 69, "desc": "Location Address House Number Suffix", "column": 69, "width": 3, "ranges": []}, {"name": "LOCHNTYPE", "vtype": "VARCHAR", "position": 70, "desc": "Location Address \u2013 House Number/Building Number Type", "column": 70, "width": 1, "ranges": [{"a": "B", "b": "B"}, {"a": "H", "b": "H"}]}, {"name": "LOCISMAIL", "vtype": "VARCHAR", "position": 71, "desc": "Location Address is also a Current DSF Address", "column": 71, "width": 1, "ranges": [{"a": "Y", "b": "Y"}, {"a": "N", "b": "N"}]}, {"name": "LOCNAME", "vtype": "VARCHAR", "position": 72, "desc": "Location Address \u2013 Base Street Name", "column": 72, "width": 100, "ranges": []}, {"name": "LOCPLUS4", "vtype": "VARCHAR", "position": 73, "desc": "Location Address ZIP+4 Code", "column": 73, "width": 4, "ranges": []}, {"name": "LOCPREDIR", "vtype": "VARCHAR", "position": 74, "desc": "Location Address \u2013 Street Name Prefix Direction", "column": 74, "width": 2, "ranges": [{"a": "NO", "b": "NO"}, {"a": "N", "b": "N"}, {"a": "O", "b": "O"}, {"a": "NE", "b": "NE"}, {"a": "NW", "b": "NW"}, {"a": "S", "b": "S"}, {"a": "SE", "b": "SE"}, {"a": "SO", "b": "SO"}, {"a": "SW", "b": "SW"}, {"a": "W", "b": "W"}, {"a": "E", "b": "E"}]}, {"name": "LOCPREQUAL", "vtype": "VARCHAR", "position": 75, "desc": "Location Address \u2013 Street Name Prefix Qualifier", "column": 75, "width": 3, "ranges": [{"a": "PVT", "b": "PVT"}, {"a": "SPR", "b": "SPR"}, {"a": "BYP", "b": "BYP"}, {"a": "HST", "b": "HST"}, {"a": "OLD", "b": "OLD"}, {"a": "PUB", "b": "PUB"}, {"a": "EXD", "b": "EXD"}, {"a": "LP", "b": "LP"}, {"a": "BUS", "b": "BUS"}, {"a": "ALT", "b": "ALT"}]}, {"name": "LOCPRETYP", "vtype": "VARCHAR", "position": 76, "desc": "Location Address \u2013 Street Name Prefix Type", "column": 76, "width": 14, "ranges": []}, {"name": "LOCSTBLDIND", "vtype": "VARCHAR", "position": 77, "desc": "Location Address \u2013 Street/Building Indicator", "column": 77, "width": 1, "ranges": [{"a": "1", "b": "1"}, {"a": "0", "b": "0"}]}, {"name": "LOCSTNMSRC", "vtype": "VARCHAR", "position": 78, "desc": "Location Address \u2013 Street Name Source", "column": 78, "width": 1, "ranges": [{"a": "1", "b": "1"}, {"a": "0", "b": "0"}]}, {"name": "LOCSUFDIR", "vtype": "VARCHAR", "position": 79, "desc": "Location Address \u2013 Street Name Suffix Direction", "column": 79, "width": 2, "ranges": [{"a": "NO", "b": "NO"}, {"a": "N", "b": "N"}, {"a": "O", "b": "O"}, {"a": "NW", "b": "NW"}, {"a": "NE", "b": "NE"}, {"a": "S", "b": "S"}, {"a": "SE", "b": "SE"}, {"a": "SO", "b": "SO"}, {"a": "E", "b": "E"}, {"a": "W", "b": "W"}, {"a": "SW", "b": "SW"}]}, {"name": "LOCSUFQUAL", "vtype": "VARCHAR", "position": 80, "desc": "Location Address \u2013 Street Name Suffix Qualifier", "column": 80, "width": 3, "ranges": [{"a": "PVT", "b": "PVT"}, {"a": "SPR", "b": "SPR"}, {"a": "BYP", "b": "BYP"}, {"a": "OVP", "b": "OVP"}, {"a": "ALT", "b": "ALT"}, {"a": "PUB", "b": "PUB"}, {"a": "ACC", "b": "ACC"}, {"a": "EXD", "b": "EXD"}, {"a": "BUS", "b": "BUS"}, {"a": "EXN", "b": "EXN"}, {"a": "LP", "b": "LP"}, {"a": "UNP", "b": "UNP"}, {"a": "SCN", "b": "SCN"}, {"a": "RMP", "b": "RMP"}, {"a": "CON", "b": "CON"}]}, {"name": "LOCSUFTYP", "vtype": "VARCHAR", "position": 81, "desc": "Location Address \u2013 Street Name Suffix Type", "column": 81, "width": 14, "ranges": []}, {"name": "LOCURB", "vtype": "VARCHAR", "position": 82, "desc": "Location Address Urbanization (Puerto Rico)", "column": 82, "width": 50, "ranges": []}, {"name": "LOCWSDESC1", "vtype": "VARCHAR", "position": 83, "desc": "Location Address Within Structure Descriptor 1", "column": 83, "width": 12, "ranges": [{"a": "PARTE", "b": "PARTE"}, {"a": "BAY", "b": "BAY"}, {"a": "PISO", "b": "PISO"}, {"a": "STORE", "b": "STORE"}, {"a": "UNIT", "b": "UNIT"}, {"a": "STES", "b": "STES"}, {"a": "ALTOS", "b": "ALTOS"}, {"a": "IZQ", "b": "IZQ"}, {"a": "SLIP", "b": "SLIP"}, {"a": "BAJOS", "b": "BAJOS"}, {"a": "EXT", "b": "EXT"}, {"a": "HANGAR", "b": "HANGAR"}, {"a": "APT", "b": "APT"}, {"a": "STE", "b": "STE"}, {"a": "DEPT", "b": "DEPT"}, {"a": "STUDIO", "b": "STUDIO"}, {"a": "PH", "b": "PH"}, {"a": "ROOM", "b": "ROOM"}, {"a": "ATRAS", "b": "ATRAS"}, {"a": "LOT", "b": "LOT"}, {"a": "DER", "b": "DER"}, {"a": "MH", "b": "MH"}, {"a": "SOTANO", "b": "SOTANO"}, {"a": "STALL", "b": "STALL"}, {"a": "STOP", "b": "STOP"}, {"a": "SPACE", "b": "SPACE"}, {"a": "TRLR", "b": "TRLR"}, {"a": "ALD", "b": "ALD"}, {"a": "INT", "b": "INT"}, {"a": "PIER", "b": "PIER"}]}, {"name": "LOCWSID1", "vtype": "VARCHAR", "position": 84, "desc": "Location Address Within Structure ID 1", "column": 84, "width": 40, "ranges": []}, {"name": "LOCZIP", "vtype": "VARCHAR", "position": 85, "desc": "Location Address 5-digit ZIP Code", "column": 85, "width": 5, "ranges": []}, {"name": "LOCZIPCLASS", "vtype": "VARCHAR", "position": 86, "desc": "Location Address \u2013 ZIP Code Classification Code", "column": 86, "width": 1, "ranges": [{"a": "U", "b": "U"}, {"a": "M", "b": "M"}, {"a": "P", "b": "P"}]}, {"name": "LUCAAF2020", "vtype": "VARCHAR", "position": 87, "desc": "LUCA Address Filter Flag for 2020", "column": 87, "width": 1, "ranges": []}, {"name": "MAFCSFAIL", "vtype": "VARCHAR", "position": 88, "desc": "MAF Coverage Study Fail Flag", "column": 88, "width": 1, "ranges": []}, {"name": "MAFID", "vtype": "NUMBER", "position": 89, "desc": "Permanent MAFUNIT ID", "column": 89, "width": 9, "ranges": []}, {"name": "MAFSRC", "vtype": "VARCHAR", "position": 90, "desc": "Original MAF Source Code", "column": 90, "width": 3, "ranges": []}, {"name": "MAILAPTCOMPLEX", "vtype": "VARCHAR", "position": 91, "desc": "Mailing Address \u2013 Name of an apartment complex, subdivision , named development, or mobile park", "column": 91, "width": 100, "ranges": []}, {"name": "MAILAREANM1", "vtype": "VARCHAR", "position": 92, "desc": "\u201cBarrio\u201d, \u201cBarriada\u201d,\u201dSector\u201d, \u201cParcela\u201d, \u201cCommunidad\u201d (Puerto Rico)", "column": 92, "width": 50, "ranges": []}, {"name": "MAILAREANM2", "vtype": "VARCHAR", "position": 93, "desc": "\u201cBarrio\u201d, \u201cBarriada\u201d,\u201dSector\u201d, \u201cParcela\u201d, \u201cCommunidad\u201d (Puerto Rico)", "column": 93, "width": 50, "ranges": []}, {"name": "MAILBLDGDESC", "vtype": "VARCHAR", "position": 94, "desc": "Mailing Address \u2013 Building Descriptor", "column": 94, "width": 10, "ranges": []}, {"name": "MAILBLDGID", "vtype": "VARCHAR", "position": 95, "desc": "Mailing Address \u2013 Building Identifier", "column": 95, "width": 12, "ranges": []}, {"name": "MAILHN1", "vtype": "VARCHAR", "position": 96, "desc": "Mailing Address First Part of House Number", "column": 96, "width": 12, "ranges": []}, {"name": "MAILHN2", "vtype": "VARCHAR", "position": 97, "desc": "Mailing Address Second Part of House Number", "column": 97, "width": 12, "ranges": []}, {"name": "MAILHNPR", "vtype": "VARCHAR", "position": 98, "desc": "Mailing Address \u2013 House Number (Puerto Rico)", "column": 98, "width": 20, "ranges": []}, {"name": "MAILHNPRE", "vtype": "VARCHAR", "position": 99, "desc": "Mailing Address House Number Prefix", "column": 99, "width": 2, "ranges": []}, {"name": "MAILHNSEP", "vtype": "VARCHAR", "position": 100, "desc": "Mailing Address House Number Separator", "column": 100, "width": 2, "ranges": []}, {"name": "MAILHNSUF", "vtype": "VARCHAR", "position": 101, "desc": "Mailing Address House Number Suffix", "column": 101, "width": 3, "ranges": []}, {"name": "MAILHNTYPE", "vtype": "VARCHAR", "position": 102, "desc": "Mailing Address House Number Type", "column": 102, "width": 1, "ranges": [{"a": "B", "b": "B"}, {"a": "H", "b": "H"}]}, {"name": "MAILNAME", "vtype": "VARCHAR", "position": 103, "desc": "Mailing Address \u2013 Base Street Name", "column": 103, "width": 100, "ranges": []}, {"name": "MAILPLUS4", "vtype": "VARCHAR", "position": 104, "desc": "Mailing Address ZIP+4 Code", "column": 104, "width": 4, "ranges": []}, {"name": "MAILPOBOXID", "vtype": "VARCHAR", "position": 105, "desc": "Mailing Address \u2013 Post Office Box ID", "column": 105, "width": 10, "ranges": []}, {"name": "MAILPREDIR", "vtype": "VARCHAR", "position": 106, "desc": "Mailing Address \u2013 Street Name Prefix Direction", "column": 106, "width": 2, "ranges": [{"a": "NO", "b": "NO"}, {"a": "N", "b": "N"}, {"a": "O", "b": "O"}, {"a": "NW", "b": "NW"}, {"a": "NE", "b": "NE"}, {"a": "S", "b": "S"}, {"a": "SE", "b": "SE"}, {"a": "SO", "b": "SO"}, {"a": "E", "b": "E"}, {"a": "W", "b": "W"}, {"a": "SW", "b": "SW"}]}, {"name": "MAILPREQUAL", "vtype": "VARCHAR", "position": 107, "desc": "Mailing Address \u2013 Street Name Prefix Qualifier", "column": 107, "width": 3, "ranges": [{"a": "PVT", "b": "PVT"}, {"a": "SPR", "b": "SPR"}, {"a": "BYP", "b": "BYP"}, {"a": "HST", "b": "HST"}, {"a": "OLD", "b": "OLD"}, {"a": "PUB", "b": "PUB"}, {"a": "EXD", "b": "EXD"}, {"a": "LP", "b": "LP"}, {"a": "BUS", "b": "BUS"}, {"a": "ALT", "b": "ALT"}]}, {"name": "MAILPRETYP", "vtype": "VARCHAR", "position": 108, "desc": "Mailing Address \u2013 Street Name Prefix Type", "column": 108, "width": 14, "ranges": []}, {"name": "MAILRRBOXID", "vtype": "VARCHAR", "position": 109, "desc": "Mailing Address \u2013 Rural Route Box ID", "column": 109, "width": 10, "ranges": []}, {"name": "MAILRRDESC", "vtype": "VARCHAR", "position": 110, "desc": "Mailing Address \u2013 Rural Route Descriptor", "column": 110, "width": 25, "ranges": [{"a": "RR", "b": "RR"}, {"a": "PSC", "b": "PSC"}, {"a": "HC", "b": "HC"}]}, {"name": "MAILRRID", "vtype": "VARCHAR", "position": 111, "desc": "Mailing Address \u2013 Rural Route ID", "column": 111, "width": 4, "ranges": []}, {"name": "MAILSTBLDIND", "vtype": "VARCHAR", "position": 112, "desc": "Mailing Address \u2013 Street/Building Indicator", "column": 112, "width": 1, "ranges": [{"a": "1", "b": "1"}, {"a": "0", "b": "0"}]}, {"name": "MAILSTNMSRC", "vtype": "VARCHAR", "position": 113, "desc": "Mailing Address \u2013 Street Name Source", "column": 113, "width": 1, "ranges": [{"a": "1", "b": "1"}, {"a": "0", "b": "0"}]}, {"name": "MAILSUFDIR", "vtype": "VARCHAR", "position": 114, "desc": "Mailing Address \u2013 Street Name Suffix Direction", "column": 114, "width": 2, "ranges": [{"a": "NO", "b": "NO"}, {"a": "N", "b": "N"}, {"a": "O", "b": "O"}, {"a": "NW", "b": "NW"}, {"a": "NE", "b": "NE"}, {"a": "S", "b": "S"}, {"a": "SE", "b": "SE"}, {"a": "SO", "b": "SO"}, {"a": "E", "b": "E"}, {"a": "W", "b": "W"}, {"a": "SW", "b": "SW"}]}, {"name": "MAILSUFQUAL", "vtype": "VARCHAR", "position": 115, "desc": "Mailing Address \u2013 Street Name Suffix Qualifier", "column": 115, "width": 3, "ranges": [{"a": "PVT", "b": "PVT"}, {"a": "SPR", "b": "SPR"}, {"a": "BYP", "b": "BYP"}, {"a": "OVP", "b": "OVP"}, {"a": "ALT", "b": "ALT"}, {"a": "PUB", "b": "PUB"}, {"a": "ACC", "b": "ACC"}, {"a": "EXD", "b": "EXD"}, {"a": "BUS", "b": "BUS"}, {"a": "EXN", "b": "EXN"}, {"a": "LP", "b": "LP"}, {"a": "UNP", "b": "UNP"}, {"a": "SCN", "b": "SCN"}, {"a": "RMP", "b": "RMP"}, {"a": "CON", "b": "CON"}]}, {"name": "MAILSUFTYP", "vtype": "VARCHAR", "position": 116, "desc": "Mailing Address \u2013 Street Name Suffix Type", "column": 116, "width": 14, "ranges": []}, {"name": "MAILURB", "vtype": "VARCHAR", "position": 117, "desc": "Mailing Address \u2013 Urbanization (Puerto Rico)", "column": 117, "width": 50, "ranges": []}, {"name": "MAILWSDESC1", "vtype": "VARCHAR", "position": 118, "desc": "Mailing Address \u2013 Within Structure Descriptor", "column": 118, "width": 12, "ranges": [{"a": "PARTE", "b": "PARTE"}, {"a": "BAY", "b": "BAY"}, {"a": "PISO", "b": "PISO"}, {"a": "STORE", "b": "STORE"}, {"a": "UNIT", "b": "UNIT"}, {"a": "STES", "b": "STES"}, {"a": "ALTOS", "b": "ALTOS"}, {"a": "IZQ", "b": "IZQ"}, {"a": "SLIP", "b": "SLIP"}, {"a": "BAJOS", "b": "BAJOS"}, {"a": "EXT", "b": "EXT"}, {"a": "HANGAR", "b": "HANGAR"}, {"a": "APT", "b": "APT"}, {"a": "STE", "b": "STE"}, {"a": "DEPT", "b": "DEPT"}, {"a": "STUDIO", "b": "STUDIO"}, {"a": "PH", "b": "PH"}, {"a": "ROOM", "b": "ROOM"}, {"a": "ATRAS", "b": "ATRAS"}, {"a": "LOT", "b": "LOT"}, {"a": "DER", "b": "DER"}, {"a": "MH", "b": "MH"}, {"a": "SOTANO", "b": "SOTANO"}, {"a": "STALL", "b": "STALL"}, {"a": "STOP", "b": "STOP"}, {"a": "SPACE", "b": "SPACE"}, {"a": "TRLR", "b": "TRLR"}, {"a": "ALD", "b": "ALD"}, {"a": "INT", "b": "INT"}, {"a": "PIER", "b": "PIER"}]}, {"name": "MAILWSID1", "vtype": "VARCHAR", "position": 119, "desc": "Mailing Address \u2013 Within Structure ID 1", "column": 119, "width": 40, "ranges": []}, {"name": "MAILZIP", "vtype": "VARCHAR", "position": 120, "desc": "Mailing Address 5-digit ZIP Code", "column": 120, "width": 5, "ranges": []}, {"name": "MAILZIPCLASS", "vtype": "VARCHAR", "position": 121, "desc": "Mailing Address \u2013 ZIP Code Classification Code", "column": 121, "width": 1, "ranges": [{"a": "U", "b": "U"}, {"a": "M", "b": "M"}, {"a": "P", "b": "P"}]}, {"name": "MSPID", "vtype": "NUMBER", "position": 122, "desc": "Map Spot Identification Code", "column": 122, "width": 9, "ranges": [{"a": "1", "b": "99"}, {"a": "999", "b": "999"}]}, {"name": "MTFCC", "vtype": "VARCHAR", "position": 123, "desc": "MAF TIGER Feature Class Code", "column": 123, "width": 5, "ranges": [{"a": "U3000", "b": "U3000"}, {"a": "U2200", "b": "U2200"}, {"a": "U1000", "b": "U1000"}, {"a": "U1200", "b": "U1200"}, {"a": "U2100", "b": "U2100"}, {"a": "U2000", "b": "U2000"}]}, {"name": "NRFUAF", "vtype": "VARCHAR", "position": 124, "desc": "Nonresponse Followup Address Filter Flag", "column": 124, "width": 1, "ranges": [{"a": "2", "b": "2"}, {"a": "1", "b": "1"}, {"a": "0", "b": "0"}]}, {"name": "NRFUUNV", "vtype": "VARCHAR", "position": 125, "desc": "Nonresponse Followup Universe Flag", "column": 125, "width": 1, "ranges": [{"a": "Y", "b": "Y"}, {"a": "N", "b": "N"}]}, {"name": "NUMUNITS", "vtype": "NUMBER", "position": 126, "desc": "Number of units at this BSA", "column": 126, "width": 4, "ranges": []}, {"name": "OFLAT", "vtype": "VARCHAR", "position": 127, "desc": "Official Coordinates \u2013 Latitude", "column": 127, "width": 11, "ranges": []}, {"name": "OFLON", "vtype": "VARCHAR", "position": 128, "desc": "Official Coordinates \u2013 Longitude", "column": 128, "width": 12, "ranges": []}, {"name": "OID", "vtype": "NUMBER", "position": 129, "desc": "MAF Unit Object Identification Code", "column": 129, "width": 22, "ranges": []}, {"name": "OIDBCU", "vtype": "NUMBER", "position": 130, "desc": "Basic Collection Unit Object Identification Code", "column": 130, "width": 22, "ranges": []}, {"name": "OIDTB", "vtype": "NUMBER", "position": 131, "desc": "PD Tabulation Block OID", "column": 131, "width": 22, "ranges": []}, {"name": "PDCONVNEW", "vtype": "VARCHAR", "position": 132, "desc": "LACS Conversion Flag (New Unit)", "column": 132, "width": 1, "ranges": [{"a": "4", "b": "4"}, {"a": "3", "b": "3"}, {"a": "1", "b": "1"}, {"a": "8", "b": "8"}, {"a": "7", "b": "7"}, {"a": "6", "b": "6"}]}, {"name": "PDCONVOLD", "vtype": "VARCHAR", "position": 133, "desc": "LACS Conversion Flag (Old Unit)", "column": 133, "width": 1, "ranges": [{"a": "4", "b": "4"}, {"a": "3", "b": "3"}, {"a": "1", "b": "1"}, {"a": "8", "b": "8"}, {"a": "7", "b": "7"}, {"a": "6", "b": "6"}]}, {"name": "POPDEC", "vtype": "NUMBER", "position": 134, "desc": "Census 2000 Population", "column": 134, "width": 9, "ranges": [{"a": "0", "b": "350"}, {"a": "000", "b": "000"}]}, {"name": "POPDEC2010", "vtype": "NUMBER", "position": 135, "desc": "Census 2010 Population", "column": 135, "width": 22, "ranges": []}, {"name": "POPDEC2020", "vtype": "NUMBER", "position": 136, "desc": "Census 2020 Population", "column": 136, "width": 9, "ranges": []}, {"name": "POSTPLUS4", "vtype": "VARCHAR", "position": 137, "desc": "USPS \u2013 ZIP+4 Code", "column": 137, "width": 4, "ranges": []}, {"name": "POSTZIP", "vtype": "VARCHAR", "position": 138, "desc": "USPS \u2013 5-digit ZIP Code", "column": 138, "width": 5, "ranges": []}, {"name": "POSTZIPCLASS", "vtype": "VARCHAR", "position": 139, "desc": "USPS \u2013 ZIP Code Classification Code", "column": 139, "width": 1, "ranges": [{"a": "U", "b": "U"}, {"a": "M", "b": "M"}, {"a": "P", "b": "P"}]}, {"name": "RAMAL", "vtype": "VARCHAR", "position": 140, "desc": "Ramal", "column": 140, "width": 20, "ranges": []}, {"name": "RESSTAT", "vtype": "VARCHAR", "position": 141, "desc": "Residential Status Flag", "column": 141, "width": 1, "ranges": [{"a": "2", "b": "2"}, {"a": "1", "b": "1"}]}, {"name": "SECCION", "vtype": "VARCHAR", "position": 142, "desc": "Seccion", "column": 142, "width": 40, "ranges": []}, {"name": "SIDE", "vtype": "VARCHAR", "position": 143, "desc": "Side Indicator Flag", "column": 143, "width": 1, "ranges": [{"a": "R", "b": "R"}, {"a": "L", "b": "L"}]}, {"name": "SUPNRFUAF", "vtype": "VARCHAR", "position": 144, "desc": "2010 Supplemental Nonresponse Followup Address Filter Flag", "column": 144, "width": 1, "ranges": [{"a": "4", "b": "4"}, {"a": "3", "b": "3"}, {"a": "1", "b": "1"}, {"a": "5", "b": "5"}, {"a": "6", "b": "6"}, {"a": "7", "b": "7"}, {"a": "2", "b": "2"}, {"a": "0", "b": "0"}]}, {"name": "SUPNRFUUNV", "vtype": "VARCHAR", "position": 145, "desc": "Supplemental NRFU Universe Flag", "column": 145, "width": 1, "ranges": [{"a": "N", "b": "N"}, {"a": "H", "b": "H"}]}, {"name": "SURVMAFID", "vtype": "NUMBER", "position": 146, "desc": "Surviving MAFID", "column": 146, "width": 9, "ranges": []}, {"name": "TAB2010BLK", "vtype": "VARCHAR", "position": 147, "desc": "2010 TAB Block \u2013 Census Block Number", "column": 147, "width": 4, "ranges": []}, {"name": "TAB2010BLKCOU", "vtype": "VARCHAR", "position": 148, "desc": "2010 TAB Block \u2013 FIPS County Code", "column": 148, "width": 3, "ranges": [{"a": "001", "b": "840"}]}, {"name": "TAB2010BLKST", "vtype": "VARCHAR", "position": 149, "desc": "2010 TAB Block \u2013 FIPS State Code", "column": 149, "width": 2, "ranges": [{"a": "02", "b": "02"}, {"a": "66", "b": "66"}, {"a": "60", "b": "60"}, {"a": "44", "b": "51"}, {"a": "72", "b": "72"}, {"a": "74", "b": "74"}, {"a": "78", "b": "78"}, {"a": "69", "b": "69"}, {"a": "08", "b": "13"}, {"a": "01", "b": "01"}, {"a": "15", "b": "42"}, {"a": "04", "b": "06"}, {"a": "53", "b": "56"}]}, {"name": "TAB2010BLKSUFX1", "vtype": "VARCHAR", "position": 150, "desc": "2010 TAB Block \u2013 Block Suffix 1", "column": 150, "width": 1, "ranges": [{"a": "A", "b": "Z"}]}, {"name": "TAB2010BLKSUFX2", "vtype": "VARCHAR", "position": 151, "desc": "2010 TAB Block \u2013 Block Suffix 2", "column": 151, "width": 1, "ranges": [{"a": "A", "b": "Z"}]}, {"name": "TAB2010BLKTRACT", "vtype": "VARCHAR", "position": 152, "desc": "2010 TAB Block \u2013 Census Tract Code", "column": 152, "width": 6, "ranges": [{"a": "000100", "b": "998999"}]}, {"name": "TAB2020BLK", "vtype": "VARCHAR", "position": 153, "desc": "2020 TAB Block \u2013 Census Block Number", "column": 153, "width": 4, "ranges": []}, {"name": "TAB2020BLKCOU", "vtype": "VARCHAR", "position": 154, "desc": "2020 TAB Block \u2013 FIPS County Code", "column": 154, "width": 3, "ranges": [{"a": "001", "b": "840"}]}, {"name": "TAB2020BLKST", "vtype": "VARCHAR", "position": 155, "desc": "2020 TAB Block \u2013 FIPS State Code", "column": 155, "width": 2, "ranges": [{"a": "02", "b": "02"}, {"a": "66", "b": "66"}, {"a": "60", "b": "60"}, {"a": "44", "b": "51"}, {"a": "72", "b": "72"}, {"a": "74", "b": "74"}, {"a": "78", "b": "78"}, {"a": "69", "b": "69"}, {"a": "08", "b": "13"}, {"a": "01", "b": "01"}, {"a": "15", "b": "42"}, {"a": "04", "b": "06"}, {"a": "53", "b": "56"}]}, {"name": "TAB2020BLKSUFX1", "vtype": "VARCHAR", "position": 156, "desc": "2020 TAB Block \u2013 Block Suffix 1", "column": 156, "width": 1, "ranges": [{"a": "A", "b": "Z"}]}, {"name": "TAB2020BLKSUFX2", "vtype": "VARCHAR", "position": 157, "desc": "2020 TAB Block \u2013 Block Suffix 2", "column": 157, "width": 1, "ranges": [{"a": "A", "b": "Z"}]}, {"name": "TAB2020BLKTRACT", "vtype": "VARCHAR", "position": 158, "desc": "2020 TAB Block \u2013 Census Tract Code", "column": 158, "width": 6, "ranges": [{"a": "000100", "b": "998999"}]}, {"name": "TABAF", "vtype": "VARCHAR", "position": 159, "desc": "2010 Final Tabulation Address Filter Flag", "column": 159, "width": 1, "ranges": [{"a": "1", "b": "1"}, {"a": "0", "b": "0"}]}, {"name": "TABMS", "vtype": "VARCHAR", "position": 160, "desc": "2010 Current Block Map Spot ID", "column": 160, "width": 21, "ranges": []}, {"name": "TEA", "vtype": "VARCHAR", "position": 161, "desc": "Type of Enumeration Area", "column": 161, "width": 1, "ranges": [{"a": "5", "b": "5"}, {"a": "4", "b": "4"}, {"a": "3", "b": "3"}, {"a": "1", "b": "1"}, {"a": "2", "b": "2"}, {"a": "6", "b": "6"}]}, {"name": "TLID", "vtype": "NUMBER", "position": 162, "desc": "Permanent Edge ID where this unit geocodes", "column": 162, "width": 10, "ranges": []}, {"name": "UNITSTAT", "vtype": "VARCHAR", "position": 163, "desc": "Unit Status Code", "column": 163, "width": 2, "ranges": [{"a": "01", "b": "01"}]}, {"name": "WSDESC2PR", "vtype": "VARCHAR", "position": 164, "desc": "Puerto Rico Within Structure Descriptor 2", "column": 164, "width": 12, "ranges": [{"a": "STE", "b": "STE"}, {"a": "PARC", "b": "PARC"}, {"a": "PISO", "b": "PISO"}, {"a": "PDA", "b": "PDA"}]}, {"name": "WSID2PR", "vtype": "VARCHAR", "position": 165, "desc": "Within Structure ID 2", "column": 165, "width": 40, "ranges": []}, {"name": "XTYP", "vtype": "VARCHAR", "position": 166, "desc": "ACS x-type flag", "column": 166, "width": 1, "ranges": [{"a": "9", "b": "9"}, {"a": "4", "b": "4"}, {"a": "3", "b": "3"}, {"a": "1", "b": "1"}, {"a": "5", "b": "5"}, {"a": "2", "b": "2"}, {"a": "0", "b": "0"}]}]}, "I": {"name": "I", "variables": [{"name": "OIDBCU", "vtype": "NUMBER", "position": 0, "desc": "Basic Collection Unit OID [PK/Unique within Nation]", "column": null, "width": 8, "ranges": []}, {"name": "STATEFP", "vtype": "VARCHAR", "position": 1, "desc": "FIPS State Code", "column": null, "width": 8, "ranges": []}, {"name": "COUNTYFP", "vtype": "VARCHAR", "position": 2, "desc": "FIPS County Code", "column": null, "width": 8, "ranges": []}, {"name": "TRACTCE", "vtype": "VARCHAR", "position": 3, "desc": "Census Tract Code", "column": null, "width": 8, "ranges": []}, {"name": "BCUID", "vtype": "VARCHAR", "position": 4, "desc": "Basic Collection Unit Identification Code", "column": null, "width": 8, "ranges": []}, {"name": "LWBCUTYP", "vtype": "VARCHAR", "position": 5, "desc": "Land/Water BCU Type", "column": null, "width": 8, "ranges": [{"a": "L", "b": "L"}, {"a": "W", "b": "W"}, {"a": "B", "b": "B"}]}, {"name": "RCCCE", "vtype": "VARCHAR", "position": 6, "desc": "RCC Code", "column": null, "width": 28, "ranges": [{"a": "2299239925992999319932994099", "b": "2299239925992999319932994099"}]}, {"name": "ACOCE", "vtype": "VARCHAR", "position": 7, "desc": "Area Census Office Code", "column": null, "width": 8, "ranges": [{"a": "2201", "b": "22992301"}]}, {"name": "CFMCE", "vtype": "VARCHAR", "position": 8, "desc": "Census Field Manager Area Code", "column": null, "width": 8, "ranges": [{"a": "01", "b": "99"}]}, {"name": "CFSCE", "vtype": "VARCHAR", "position": 9, "desc": "Census Field Supervisor Area Code", "column": null, "width": 8, "ranges": [{"a": "01", "b": "99"}]}, {"name": "FLDOPCODE", "vtype": "VARCHAR", "position": 10, "desc": "Operation Code for Field Division.This is required for all rows that are active for the delivery.", "column": null, "width": 8, "ranges": [{"a": "01", "b": "01"}]}, {"name": "OPCODE", "vtype": "VARCHAR", "position": 11, "desc": "Operation Code", "column": null, "width": 72, "ranges": [{"a": "200201202203204205206208210211212213300301302303304305306308310311312313", "b": "200201202203204205206208210211212213300301302303304305306308310311312313"}]}, {"name": "TEA", "vtype": "VARCHAR", "position": 12, "desc": "Type of Enumeration Area", "column": null, "width": 8, "ranges": [{"a": "123456", "b": "123456"}]}, {"name": "AIANNHCE", "vtype": "VARCHAR", "position": 13, "desc": "Census AI/AN/NH area code", "column": null, "width": 8, "ranges": []}, {"name": "MILITARYANSI", "vtype": "VARCHAR", "position": 14, "desc": "Military ANSI Code (ANSI code is not available, but non-blank indicates a military block)", "column": null, "width": 8, "ranges": []}, {"name": "INTPTLON", "vtype": "VARCHAR", "position": 15, "desc": "Internal Point Longitude", "column": null, "width": 12, "ranges": [{"a": "-64.0000000", "b": "-180.000000"}, {"a": "+179.9999999", "b": "+131.0000000"}]}, {"name": "INTPTLAT", "vtype": "VARCHAR", "position": 16, "desc": "Internal Point Latitude", "column": null, "width": 11, "ranges": [{"a": "-15.0000000", "b": "+72.0000000"}]}, {"name": "AREALAND", "vtype": "NUMBER", "position": 17, "desc": "Current Land Area", "column": null, "width": 8, "ranges": []}, {"name": "AREAWATER", "vtype": "NUMBER", "position": 18, "desc": "Current Water Area", "column": null, "width": 8, "ranges": []}, {"name": "HOUSING", "vtype": "NUMBER", "position": 19, "desc": "Provides the count, for this geographic area, of the actual number of valid decennial addresses that are being transmitted as part of this delivery includes housing units, group quarters, and transient locations.", "column": null, "width": 8, "ranges": []}, {"name": "ADCNFLG", "vtype": "VARCHAR", "position": 20, "desc": "Defines whether or not the BCU is in the In-Field Address Canvassing Operation", "column": null, "width": 8, "ranges": []}, {"name": "VINTAGE", "vtype": "VARCHAR", "position": 21, "desc": "Vintage of the data", "column": null, "width": 8, "ranges": [{"a": "737290", "b": "737290"}]}, {"name": "ISINSITE", "vtype": "VARCHAR", "position": 22, "desc": "Defines whether or not the BCU is in the test area", "column": null, "width": 8, "ranges": []}, {"name": "ADCNACOCE", "vtype": "VARCHAR", "position": 23, "desc": "Address Canvassing Area Census Office Code", "column": null, "width": 8, "ranges": []}]}, "G": {"name": "G", "variables": [{"name": "OID", "vtype": "NUMBER", "position": 0, "desc": "Object ID", "column": 0, "width": 22, "ranges": []}, {"name": "STATEFP", "vtype": "VARCHAR", "position": 1, "desc": "FIPS State Code", "column": 1, "width": 2, "ranges": []}, {"name": "COUNTYFP", "vtype": "VARCHAR", "position": 2, "desc": "FIPS County Code", "column": 2, "width": 3, "ranges": []}, {"name": "TRACTCE", "vtype": "VARCHAR", "position": 3, "desc": "Census Tract Code", "column": 3, "width": 6, "ranges": []}, {"name": "RCCCE", "vtype": "VARCHAR", "position": 4, "desc": "RCC Code", "column": 4, "width": 28, "ranges": [{"a": "2299239925992999319932994099", "b": "2299239925992999319932994099"}]}, {"name": "ACOCE", "vtype": "VARCHAR", "position": 5, "desc": "Area Census Office Code", "column": 5, "width": 8, "ranges": [{"a": "2201", "b": "22992301"}]}, {"name": "CFMCE", "vtype": "VARCHAR", "position": 6, "desc": "Census Field Manager Area Code", "column": 6, "width": 2, "ranges": [{"a": "01", "b": "99"}]}, {"name": "CFSCE", "vtype": "VARCHAR", "position": 7, "desc": "Census Field Supervisor Area Code", "column": 7, "width": 2, "ranges": [{"a": "01", "b": "99"}]}, {"name": "NAME", "vtype": "VARCHAR", "position": 8, "desc": "Name of RCC, ACO, ADCNACO, Tract, or County", "column": 8, "width": 100, "ranges": []}, {"name": "FLDOPCODE", "vtype": "VARCHAR", "position": 9, "desc": "Operation Code for Field Division.  This is required for all rows that are active for the delivery.", "column": 9, "width": 42, "ranges": [{"a": "010509131731323539454850535760677072778091", "b": "010509131731323539454850535760677072778091"}]}, {"name": "OPCODE", "vtype": "VARCHAR", "position": 10, "desc": "Operation Code", "column": 10, "width": 72, "ranges": [{"a": "200201202203204205206208210211212213300301302303304305306308310311312313", "b": "200201202203204205206208210211212213300301302303304305306308310311312313"}]}, {"name": "INTPTLON", "vtype": "VARCHAR", "position": 11, "desc": "Internal Point Longitude", "column": 11, "width": 12, "ranges": [{"a": "-180.000000", "b": "-64.0000000"}, {"a": "+131.0000000", "b": "+179.9999999"}]}, {"name": "INTPTLAT", "vtype": "VARCHAR", "position": 12, "desc": "Internal Point Latitude", "column": 12, "width": 11, "ranges": [{"a": "-15.0000000", "b": "+72.0000000"}]}, {"name": "CENTLON", "vtype": "VARCHAR", "position": 13, "desc": "Centroid Longitude", "column": 13, "width": 12, "ranges": [{"a": "-180.000000", "b": "-64.0000000"}, {"a": "+131.0000000", "b": "+179.9999999"}]}, {"name": "CENTLAT", "vtype": "VARCHAR", "position": 14, "desc": "Centroid Latitude", "column": 14, "width": 11, "ranges": [{"a": "-15.0000000", "b": "+72.0000000"}]}, {"name": "AREALAND", "vtype": "NUMBER", "position": 15, "desc": "Current Land Area Measured in square meters.", "column": 15, "width": 14, "ranges": []}, {"name": "AREAWATER", "vtype": "NUMBER", "position": 16, "desc": "Current Water Area Measured in square meters.", "column": 16, "width": 14, "ranges": []}, {"name": "HOUSING", "vtype": "NUMBER", "position": 17, "desc": "Provides the count, for this geographic area, of the actual number of valid decennial addresses that are being transmitted as part of this delivery includes housing units, group quarters, and transient locations.", "column": 17, "width": 9, "ranges": []}, {"name": "MTFCC", "vtype": "VARCHAR", "position": 18, "desc": "MAF/TIGER Feature Classification Code", "column": 18, "width": 5, "ranges": [{"a": "G8020", "b": "G8020"}]}]}, "GRFC20": {"name": "GRFC20", "variables": [{"name": "TABBLKST", "vtype": "STRING", "position": 0, "desc": "2020 Tabulation State (FIPS)", "column": 0, "width": 2, "ranges": [{"a": "66", "b": "66"}, {"a": "60", "b": "60"}, {"a": "44", "b": "51"}, {"a": "72", "b": "72"}, {"a": "01", "b": "02"}, {"a": "78", "b": "78"}, {"a": "69", "b": "69"}, {"a": "08", "b": "13"}, {"a": "15", "b": "42"}, {"a": "04", "b": "06"}, {"a": "53", "b": "56"}]}, {"name": "TABBLKCOU", "vtype": "STRING", "position": 1, "desc": "2020 Tabulation County (FIPS)", "column": 1, "width": 3, "ranges": [{"a": "001", "b": "840"}]}, {"name": "TABTRACTCE", "vtype": "STRING", "position": 2, "desc": "2020 Tabulation Census Tract", "column": 2, "width": 6, "ranges": [{"a": "000100", "b": "998999"}]}, {"name": "TABBLK", "vtype": "STRING", "position": 3, "desc": "2020 Block Number", "column": 3, "width": 4, "ranges": [{"a": "0001", "b": "9999"}]}, {"name": "TABBLKSUFX1", "vtype": "STRING", "position": 4, "desc": "2020 Block Suffix 1 (Current Block Suffix)", "column": 4, "width": 1, "ranges": [{"a": "A", "b": "Z"}]}, {"name": "TABBLKSUFX2", "vtype": "STRING", "position": 5, "desc": "2020 Block Suffix 2", "column": 5, "width": 1, "ranges": [{"a": "A", "b": "Z"}]}, {"name": "TABBLKGRPCE", "vtype": "STRING", "position": 6, "desc": "2020 Census Block Group", "column": 6, "width": 1, "ranges": [{"a": "0", "b": "9"}]}, {"name": "POPDEC", "vtype": "NUMBER", "position": 7, "desc": "2020 Population", "column": 7, "width": 9, "ranges": [{"a": "000000000", "b": "999999999"}]}, {"name": "HOUSING", "vtype": "NUMBER", "position": 8, "desc": "2020 Housing Unit Count", "column": 8, "width": 9, "ranges": []}, {"name": "CURSTATE", "vtype": "STRING", "position": 9, "desc": "Current State (FIPS)", "column": 9, "width": 2, "ranges": []}, {"name": "CURCOUNTY", "vtype": "STRING", "position": 10, "desc": "Current County (FIPS)", "column": 10, "width": 3, "ranges": []}, {"name": "CURTRACTCE", "vtype": "STRING", "position": 11, "desc": "Current Census Tract", "column": 11, "width": 6, "ranges": []}, {"name": "CURBLKGRPCE", "vtype": "STRING", "position": 12, "desc": "Current Block Group", "column": 12, "width": 1, "ranges": []}, {"name": "REGIONCE", "vtype": "STRING", "position": 13, "desc": "Census Region", "column": 13, "width": 1, "ranges": [{"a": "1", "b": "4"}, {"a": "9", "b": "9"}]}, {"name": "DIVISIONCE", "vtype": "STRING", "position": 14, "desc": "Census Division", "column": 14, "width": 1, "ranges": [{"a": "0", "b": "9"}]}, {"name": "STATENS", "vtype": "STRING", "position": 15, "desc": "State (National Standard)", "column": 15, "width": 8, "ranges": [{"a": "00000001", "b": "99999998"}]}, {"name": "COUNTYNS", "vtype": "STRING", "position": 16, "desc": "County (National Standard)", "column": 16, "width": 8, "ranges": [{"a": "00000001", "b": "99999998"}]}, {"name": "COUNTYFS", "vtype": "STRING", "position": 17, "desc": "County Functional Status", "column": 17, "width": 1, "ranges": [{"a": "F", "b": "F"}, {"a": "G", "b": "G"}, {"a": "B", "b": "B"}, {"a": "A", "b": "A"}, {"a": "N", "b": "N"}, {"a": "S", "b": "S"}, {"a": "C", "b": "C"}]}, {"name": "COUSUBFP", "vtype": "STRING", "position": 18, "desc": "County Subdivision (FIPS)", "column": 18, "width": 5, "ranges": [{"a": "00000", "b": "98999"}]}, {"name": "COUSUBNS", "vtype": "STRING", "position": 19, "desc": "County Subdivision (National Standard)", "column": 19, "width": 8, "ranges": [{"a": "00000000", "b": "99999998"}]}, {"name": "SUBMCDFP", "vtype": "STRING", "position": 21, "desc": "Subminor Civil Division (FIPS)", "column": 21, "width": 5, "ranges": [{"a": "99999", "b": "99999"}, {"a": "00001", "b": "89999"}]}, {"name": "SUBMCDNS", "vtype": "STRING", "position": 22, "desc": "Subminor Civil Division (National Standard)", "column": 22, "width": 8, "ranges": [{"a": "00000001", "b": "99999998"}, {"a": "99999999", "b": "99999999"}]}, {"name": "ESTATEFP", "vtype": "STRING", "position": 23, "desc": "Estate (FIPS)", "column": 23, "width": 5, "ranges": [{"a": "99999", "b": "99999"}, {"a": "00001", "b": "89999"}]}, {"name": "ESTATENS", "vtype": "STRING", "position": 24, "desc": "Estate (National Standard)", "column": 24, "width": 8, "ranges": [{"a": "00000001", "b": "99999998"}, {"a": "99999999", "b": "99999999"}]}, {"name": "CONCITFP", "vtype": "STRING", "position": 25, "desc": "Consolidated City (FIPS)", "column": 25, "width": 5, "ranges": [{"a": "99999", "b": "99999"}, {"a": "00001", "b": "89999"}]}, {"name": "CONCITNS", "vtype": "STRING", "position": 26, "desc": "Consolidated City (National Standard)", "column": 26, "width": 8, "ranges": [{"a": "00000001", "b": "99999998"}, {"a": "99999999", "b": "99999999"}]}, {"name": "PLACEFP", "vtype": "STRING", "position": 27, "desc": "Place (FIPS)", "column": 27, "width": 5, "ranges": [{"a": "99999", "b": "99999"}, {"a": "00001", "b": "89999"}]}, {"name": "PLACENS", "vtype": "STRING", "position": 28, "desc": "Place (National Standard)", "column": 28, "width": 8, "ranges": [{"a": "00000001", "b": "99999998"}, {"a": "99999999", "b": "99999999"}]}, {"name": "PLACEFS", "vtype": "STRING", "position": 29, "desc": "Place Functional Status", "column": 29, "width": 1, "ranges": [{"a": "F", "b": "F"}, {"a": "I", "b": "I"}, {"a": "N", "b": "N"}, {"a": "B", "b": "B"}, {"a": "A", "b": "A"}, {"a": "S", "b": "S"}, {"a": "9", "b": "9"}]}, {"name": "AIANNHFP", "vtype": "STRING", "position": 30, "desc": "AIANNH (FIPS)", "column": 30, "width": 5, "ranges": [{"a": "99999", "b": "99999"}, {"a": "00001", "b": "89999"}]}, {"name": "AIANNHCE", "vtype": "STRING", "position": 31, "desc": "AIANNH (Census)", "column": 31, "width": 4, "ranges": [{"a": "00001", "b": "9998"}, {"a": "9999", "b": "9999"}]}, {"name": "AIANNHNS", "vtype": "STRING", "position": 32, "desc": "AIANNH (National Standard)", "column": 32, "width": 8, "ranges": [{"a": "00000001", "b": "99999998"}, {"a": "99999999", "b": "99999999"}]}, {"name": "AIHHTLI", "vtype": "STRING", "position": 33, "desc": "American Indian/Hawaiian Home Land Trust Land Indicator", "column": 33, "width": 1, "ranges": [{"a": "9", "b": "9"}, {"a": "R", "b": "R"}, {"a": "T", "b": "T"}]}, {"name": "TRIBALSUBFP", "vtype": "STRING", "position": 34, "desc": "American Indian Tribal Subdivision (FIPS)", "column": 34, "width": 5, "ranges": [{"a": "99999", "b": "99999"}, {"a": "00001", "b": "89999"}]}, {"name": "TRIBALSUBCE", "vtype": "STRING", "position": 35, "desc": "American Indian Tribal Subdivision (Census)", "column": 35, "width": 3, "ranges": [{"a": "999", "b": "999"}, {"a": "001", "b": "998"}]}, {"name": "TRIBALSUBNS", "vtype": "STRING", "position": 36, "desc": "American Indian Tribal Subdivision (National Standard)", "column": 36, "width": 8, "ranges": [{"a": "00000001", "b": "99999998"}, {"a": "99999999", "b": "99999999"}]}, {"name": "TTRACTCE", "vtype": "STRING", "position": 37, "desc": "American Indian Tribal Tract", "column": 37, "width": 6, "ranges": [{"a": "T00100", "b": "T98999"}, {"a": "999999", "b": "999999"}]}, {"name": "TBLKGRPCE", "vtype": "STRING", "position": 38, "desc": "American Indian Tribal Block Group", "column": 38, "width": 1, "ranges": [{"a": "K", "b": "K"}, {"a": "9", "b": "9"}, {"a": "J", "b": "J"}, {"a": "A", "b": "H"}]}, {"name": "ANRCFP", "vtype": "STRING", "position": 39, "desc": "Alaska Native Regional Corporation (FIPS)", "column": 39, "width": 5, "ranges": [{"a": "17140", "b": "17140"}, {"a": "00590", "b": "00590"}, {"a": "09040", "b": "09040"}, {"a": "03950", "b": "03950"}, {"a": "14410", "b": "14410"}, {"a": "20010", "b": "20010"}, {"a": "41640", "b": "41640"}, {"a": "01570", "b": "01570"}, {"a": "06370", "b": "06370"}, {"a": "52120", "b": "52120"}, {"a": "67940", "b": "67940"}, {"a": "99999", "b": "99999"}, {"a": "09800", "b": "09800"}]}, {"name": "ANRCNS", "vtype": "STRING", "position": 40, "desc": "Alaska Native Regional Corporation (National Standard)", "column": 40, "width": 8, "ranges": [{"a": "00000001", "b": "99999998"}, {"a": "99999999", "b": "99999999"}]}, {"name": "UACE", "vtype": "STRING", "position": 41, "desc": "Urban Area", "column": 41, "width": 5, "ranges": [{"a": "00001", "b": "98999"}, {"a": "!!!!!", "b": "!!!!!"}, {"a": "99999", "b": "99999"}]}, {"name": "UATYP", "vtype": "STRING", "position": 42, "desc": "Urban Area Type", "column": 42, "width": 1, "ranges": [{"a": "U", "b": "U"}, {"a": "!", "b": "!"}, {"a": "9", "b": "9"}, {"a": "C", "b": "C"}]}, {"name": "UR", "vtype": "STRING", "position": 43, "desc": "Urban/Rural", "column": 43, "width": 1, "ranges": [{"a": "U", "b": "U"}, {"a": "R", "b": "R"}, {"a": "!", "b": "!"}]}, {"name": "CD116FP", "vtype": "STRING", "position": 44, "desc": "Congressional District (Decennial)", "column": 44, "width": 2, "ranges": [{"a": "00", "b": "53"}, {"a": "ZZ", "b": "ZZ"}, {"a": "98", "b": "98"}, {"a": "99", "b": "99"}]}, {"name": "CDCURFP", "vtype": "STRING", "position": 45, "desc": "Congressional District (Current)", "column": 45, "width": 2, "ranges": []}, {"name": "VTDST", "vtype": "STRING", "position": 46, "desc": "Voting District", "column": 46, "width": 6, "ranges": [{"a": "      ", "b": "zzzzzz"}, {"a": "ZZZZZZ", "b": "ZZZZZZ"}]}, {"name": "SLDUST", "vtype": "STRING", "position": 47, "desc": "State Legislative District (Upper Chamber)", "column": 47, "width": 3, "ranges": [{"a": "   ", "b": "zzz"}, {"a": "999", "b": "999"}, {"a": "ZZZ", "b": "ZZZ"}]}, {"name": "SLDLST", "vtype": "STRING", "position": 48, "desc": "State Legislative District (Lower Chamber)", "column": 48, "width": 3, "ranges": [{"a": "   ", "b": "zzz"}, {"a": "999", "b": "999"}, {"a": "ZZZ", "b": "ZZZ"}]}, {"name": "ZCTA5CE", "vtype": "STRING", "position": 49, "desc": "ZIP Code Tabulation Area (5-Digit)", "column": 49, "width": 5, "ranges": [{"a": "!!!!!", "b": "!!!!!"}, {"a": "00601", "b": "99929"}, {"a": "00000", "b": "00000"}, {"a": "99999", "b": "99999"}]}, {"name": "SDELMLEA", "vtype": "STRING", "position": 50, "desc": "School District (Elementary)", "column": 50, "width": 5, "ranges": [{"a": "00001", "b": "99996"}, {"a": "99999", "b": "99999"}]}, {"name": "SDSECLEA", "vtype": "STRING", "position": 51, "desc": "School District (Secondary)", "column": 51, "width": 5, "ranges": [{"a": "00001", "b": "99996"}, {"a": "99999", "b": "99999"}]}, {"name": "SDUNILEA", "vtype": "STRING", "position": 52, "desc": "School District (Unified)", "column": 52, "width": 5, "ranges": [{"a": "00001", "b": "99998"}, {"a": "99999", "b": "99999"}]}, {"name": "UGACE", "vtype": "STRING", "position": 53, "desc": "Urban Growth Area", "column": 53, "width": 5, "ranges": [{"a": "99999", "b": "99999"}, {"a": "00001", "b": "89999"}]}, {"name": "PUMA", "vtype": "STRING", "position": 54, "desc": "Public Use Microdata Area", "column": 54, "width": 5, "ranges": [{"a": "00001", "b": "99998"}, {"a": "!!!!!", "b": "!!!!!"}, {"a": "99999", "b": "99999"}]}, {"name": "LWBLKTYP", "vtype": "STRING", "position": 55, "desc": "Block Type", "column": 55, "width": 1, "ranges": [{"a": "W", "b": "W"}, {"a": "L", "b": "L"}, {"a": "B", "b": "B"}]}, {"name": "INTPTLAT", "vtype": "STRING", "position": 56, "desc": "Internal Point (Latitude)", "column": 56, "width": 11, "ranges": [{"a": "-15.0000000", "b": "+72.0000000"}]}, {"name": "INTPTLON", "vtype": "STRING", "position": 57, "desc": "Internal Point (Longitude)", "column": 57, "width": 12, "ranges": [{"a": "-180.000000", "b": "-64.0000000"}, {"a": "+131.0000000", "b": "+179.9999999"}]}, {"name": "AREALAND", "vtype": "NUMBER", "position": 58, "desc": "Area (Land)", "column": 58, "width": 14, "ranges": [{"a": "00000000000000", "b": "99999999999999"}]}, {"name": "AREAWATER", "vtype": "NUMBER", "position": 59, "desc": "Area (Water)", "column": 59, "width": 14, "ranges": [{"a": "00000000000000", "b": "99999999999999"}]}, {"name": "AREAWATERINLD", "vtype": "NUMBER", "position": 60, "desc": "Area (Water-Inland)", "column": 60, "width": 14, "ranges": [{"a": "00000000000000", "b": "99999999999999"}]}, {"name": "AREAWATERCSTL", "vtype": "NUMBER", "position": 61, "desc": "Area (Water-Coastal)", "column": 61, "width": 14, "ranges": [{"a": "00000000000000", "b": "99999999999999"}]}, {"name": "AREAWATERGRLK", "vtype": "NUMBER", "position": 62, "desc": "Area (Water-Great Lakes)", "column": 62, "width": 14, "ranges": [{"a": "00000000000000", "b": "99999999999999"}]}, {"name": "AREAWATERTSEA", "vtype": "NUMBER", "position": 63, "desc": "Area (Water-Territorial Sea)", "column": 63, "width": 14, "ranges": [{"a": "00000000000000", "b": "99999999999999"}]}, {"name": "CSAFP", "vtype": "STRING", "position": 64, "desc": "Combined Statistical Area", "column": 64, "width": 3, "ranges": [{"a": "100", "b": "599"}, {"a": "999", "b": "999"}]}, {"name": "CBSAFP", "vtype": "STRING", "position": 65, "desc": "Metropolitan and Micropolitan Statistical Area", "column": 65, "width": 5, "ranges": [{"a": "10000", "b": "49999"}, {"a": "99999", "b": "99999"}]}, {"name": "METDIVFP", "vtype": "STRING", "position": 66, "desc": "Metropolitan Division", "column": 66, "width": 5, "ranges": [{"a": "10004", "b": "49994"}, {"a": "99999", "b": "99999"}]}, {"name": "PCICBSA", "vtype": "STRING", "position": 67, "desc": "CBSA Principal City Indicator", "column": 67, "width": 1, "ranges": [{"a": "9", "b": "9"}, {"a": "Y", "b": "Y"}, {"a": "N", "b": "N"}]}, {"name": "CNECTAFP", "vtype": "STRING", "position": 68, "desc": "New England City and Town Combined Statistical Area", "column": 68, "width": 3, "ranges": [{"a": "700", "b": "799"}, {"a": "999", "b": "999"}]}, {"name": "NECTAFP", "vtype": "STRING", "position": 69, "desc": "New England City and Town Area", "column": 69, "width": 5, "ranges": [{"a": "70000", "b": "79999"}, {"a": "99999", "b": "99999"}]}, {"name": "NECTADIVFP", "vtype": "STRING", "position": 70, "desc": "New England City and Town Area Division", "column": 70, "width": 5, "ranges": [{"a": "70004", "b": "79994"}, {"a": "99999", "b": "99999"}]}, {"name": "PCINECTA", "vtype": "STRING", "position": 71, "desc": "NECTA Principal City Indicator", "column": 71, "width": 1, "ranges": [{"a": "9", "b": "9"}, {"a": "Y", "b": "Y"}, {"a": "N", "b": "N"}]}, {"name": "ACT", "vtype": "STRING", "position": 72, "desc": "Address Stringistic Type", "column": 72, "width": 2, "ranges": [{"a": "P3", "b": "P3"}, {"a": "P1", "b": "P1"}, {"a": "D1", "b": "D1"}, {"a": "MC", "b": "MC"}, {"a": "C2", "b": "C2"}, {"a": "R1", "b": "R1"}, {"a": "B3", "b": "B3"}, {"a": "N1", "b": "N1"}, {"a": "C3", "b": "C3"}, {"a": "P2", "b": "P2"}, {"a": "MA", "b": "MA"}, {"a": "D2", "b": "D2"}, {"a": "M3", "b": "M3"}, {"a": "B1", "b": "B1"}, {"a": "ME", "b": "ME"}, {"a": "MB", "b": "MB"}, {"a": "N3", "b": "N3"}, {"a": "R2", "b": "R2"}, {"a": "B2", "b": "B2"}, {"a": "D3", "b": "D3"}, {"a": "MF", "b": "MF"}, {"a": "N2", "b": "N2"}, {"a": "M1", "b": "M1"}, {"a": "MG", "b": "MG"}, {"a": "Z0", "b": "Z0"}, {"a": "MD", "b": "MD"}, {"a": "C1", "b": "C1"}, {"a": "R3", "b": "R3"}]}, {"name": "MEMI", "vtype": "STRING", "position": 73, "desc": "CBSA Metropolitan/Micropolitan Status Indicator", "column": 73, "width": 1, "ranges": [{"a": "2", "b": "2"}, {"a": "9", "b": "9"}, {"a": "1", "b": "1"}]}, {"name": "NMEMI", "vtype": "STRING", "position": 74, "desc": "NECTA Metropolitan/Micropolitan Status Indicator", "column": 74, "width": 1, "ranges": [{"a": "2", "b": "2"}, {"a": "9", "b": "9"}, {"a": "1", "b": "1"}]}, {"name": "OIDTABBLK", "vtype": "NUMBER", "position": 75, "desc": "Tabulation Block Object ID", "column": 75, "width": 22, "ranges": [{"a": "1", "b": "9999999999999999999999"}]}]}, "L": {"name": "L", "variables": [{"name": "MTFCC", "vtype": "STRING", "position": 0, "desc": "MAF/TIGER Feature Class Code", "column": 0, "width": 5, "ranges": [{"a": "S", "b": "S"}]}, {"name": "VINTAGE", "vtype": "STRING", "position": 1, "desc": "Vintage", "column": 1, "width": 2, "ranges": []}, {"name": "STATEFP", "vtype": "STRING", "position": 2, "desc": "State or Equivalent Feature (FIPS)", "column": 2, "width": 2, "ranges": [{"a": "S", "b": "S"}]}, {"name": "COUNTYFP", "vtype": "STRING", "position": 3, "desc": "County or Equivalent Feature (FIPS)", "column": 3, "width": 3, "ranges": []}, {"name": "GEOCE", "vtype": "STRING", "position": 4, "desc": "Census Code", "column": 4, "width": 8, "ranges": []}, {"name": "GEOFP", "vtype": "STRING", "position": 5, "desc": "FIPS Code", "column": 5, "width": 5, "ranges": []}, {"name": "GEONS", "vtype": "STRING", "position": 6, "desc": "National Standard Code", "column": 6, "width": 8, "ranges": []}, {"name": "PARENT", "vtype": "STRING", "position": 7, "desc": "Parent Code", "column": 7, "width": 8, "ranges": []}, {"name": "PARENT2", "vtype": "STRING", "position": 8, "desc": "Parent Code 2", "column": 8, "width": 8, "ranges": []}, {"name": "NAME", "vtype": "STRING", "position": 9, "desc": "Area Name (without LSADC)", "column": 9, "width": 100, "ranges": []}, {"name": "NAMELSAD", "vtype": "STRING", "position": 10, "desc": "Area Name and Legal/Statistical Area Description Code", "column": 10, "width": 100, "ranges": []}, {"name": "FUNCSTAT", "vtype": "STRING", "position": 11, "desc": "Functional Status", "column": 11, "width": 1, "ranges": []}, {"name": "LSADC", "vtype": "STRING", "position": 12, "desc": "Legal/Statistical Area Description Code", "column": 12, "width": 2, "ranges": []}, {"name": "PARTFLAG", "vtype": "STRING", "position": 13, "desc": "Part Flag (State)", "column": 13, "width": 1, "ranges": []}, {"name": "AIANNHFSR", "vtype": "STRING", "position": 14, "desc": "AIANNHA Federal/State Recognition Flag", "column": 14, "width": 1, "ranges": []}, {"name": "AIANNHTYP", "vtype": "STRING", "position": 15, "desc": "AIANNHA  Entity Type", "column": 15, "width": 1, "ranges": []}, {"name": "CLASSFP", "vtype": "STRING", "position": 16, "desc": "FIPS 55 Class Code", "column": 16, "width": 2, "ranges": []}, {"name": "STATEUSPS", "vtype": "STRING", "position": 17, "desc": "State/US Abbreviation", "column": 17, "width": 2, "ranges": [{"a": "S", "b": "S"}]}, {"name": "MEMI", "vtype": "STRING", "position": 18, "desc": "Metropolitan/Micropolitan Status Indicator", "column": 18, "width": 1, "ranges": []}, {"name": "PCICBSA", "vtype": "STRING", "position": 19, "desc": "CBSA Principal City Indicator", "column": 19, "width": 1, "ranges": [{"a": "S", "b": "S"}]}, {"name": "PCINECTA", "vtype": "STRING", "position": 20, "desc": "NECTA Principal City Indicator", "column": 20, "width": 1, "ranges": [{"a": "S", "b": "S"}]}, {"name": "CPI", "vtype": "STRING", "position": 21, "desc": "Central Place Indicator", "column": 21, "width": 1, "ranges": []}, {"name": "CDSESSN", "vtype": "STRING", "position": 22, "desc": "Congressional District Session Code", "column": 22, "width": 3, "ranges": []}, {"name": "LSY", "vtype": "STRING", "position": 23, "desc": "Legislative Session Year", "column": 23, "width": 4, "ranges": []}, {"name": "VTDI", "vtype": "STRING", "position": 24, "desc": "Voting District Indicator", "column": 24, "width": 1, "ranges": []}, {"name": "UR", "vtype": "STRING", "position": 25, "desc": "Urban/Rural Indicator", "column": 25, "width": 1, "ranges": []}, {"name": "UATYPE", "vtype": "STRING", "position": 26, "desc": "Urban Area Type", "column": 26, "width": 1, "ranges": []}, {"name": "GCUNI", "vtype": "STRING", "position": 27, "desc": "Geographic Change User Note", "column": 27, "width": 1, "ranges": []}, {"name": "CENTLAT", "vtype": "STRING", "position": 28, "desc": "Centroid (Latitude)", "column": 28, "width": 11, "ranges": [{"a": "-15.0000000", "b": "+72.0000000"}]}, {"name": "CENTLON", "vtype": "STRING", "position": 29, "desc": "Centroid (Longitude)", "column": 29, "width": 12, "ranges": [{"a": "-180.000000", "b": "-64.0000000"}, {"a": "+131.0000000", "b": "+179.9999999"}]}, {"name": "INTPTLAT", "vtype": "STRING", "position": 30, "desc": "Internal Point Latitude", "column": 30, "width": 11, "ranges": [{"a": "-15.0000000", "b": "+72.0000000"}]}, {"name": "INTPTLON", "vtype": "STRING", "position": 31, "desc": "Internal Point Longitude", "column": 31, "width": 12, "ranges": [{"a": "-180.000000", "b": "-64.0000000"}, {"a": "+131.0000000", "b": "+179.9999999"}]}, {"name": "AREALAND", "vtype": "NUMBER", "position": 32, "desc": "Current Land Area", "column": 32, "width": 14, "ranges": [{"a": "00000000000000", "b": "99999999999999"}]}, {"name": "AREAWATER", "vtype": "NUMBER", "position": 33, "desc": "Current Water Area", "column": 33, "width": 14, "ranges": [{"a": "00000000000000", "b": "99999999999999"}]}, {"name": "OID", "vtype": "NUMBER", "position": 34, "desc": "Object Identifier", "column": 34, "width": 22, "ranges": [{"a": "0000000000000000000000", "b": "9999999999999999999999"}]}]}, "O": {"name": "O", "variables": [{"name": "MAFID", "vtype": "NUMBER", "position": 0, "desc": "Permanent MAFUNIT ID", "column": null, "width": 8, "ranges": []}, {"name": "ACTION", "vtype": "VARCHAR", "position": 1, "desc": "Action Code", "column": null, "width": 8, "ranges": [{"a": "A", "b": "A"}]}, {"name": "UNITSTAT", "vtype": "VARCHAR", "position": 2, "desc": "Unit Status Code", "column": null, "width": 8, "ranges": [{"a": "01", "b": "01"}]}, {"name": "GQHUFLAG", "vtype": "VARCHAR", "position": 3, "desc": "Group Quarters/HU Flag", "column": null, "width": 8, "ranges": [{"a": "N", "b": "N"}]}, {"name": "REJECT", "vtype": "VARCHAR", "position": 4, "desc": "ADDUP Reject Code Values", "column": null, "width": 8, "ranges": [{"a": "N", "b": "N"}]}, {"name": "MAFSRC", "vtype": "VARCHAR", "position": 5, "desc": "MAF Source Code", "column": null, "width": 8, "ranges": [{"a": "183", "b": "183"}]}]}, "P": {"name": "P", "variables": [{"name": "MAFID", "vtype": "NUMBER", "position": 0, "desc": "Master Address File Identifier", "column": 0, "width": 9, "ranges": []}, {"name": "STATE", "vtype": "VARCHAR", "position": 1, "desc": "State GEO_ID", "column": 1, "width": 11, "ranges": []}, {"name": "COUNTY", "vtype": "VARCHAR", "position": 2, "desc": "County GEO_ID", "column": 2, "width": 14, "ranges": []}, {"name": "TRACT", "vtype": "VARCHAR", "position": 3, "desc": "Census tract GEO_ID", "column": 3, "width": 20, "ranges": []}, {"name": "COUSUB", "vtype": "VARCHAR", "position": 4, "desc": "County subdivision GEO_ID", "column": 4, "width": 19, "ranges": []}, {"name": "PLACE", "vtype": "VARCHAR", "position": 5, "desc": "Place GEO_ID", "column": 5, "width": 16, "ranges": []}, {"name": "CONCITY", "vtype": "VARCHAR", "position": 6, "desc": "Consolidated city GEO_ID", "column": 6, "width": 16, "ranges": []}, {"name": "AIANNH", "vtype": "VARCHAR", "position": 7, "desc": "American Indian/Alaska Native/Native Hawaiian area GEO_ID", "column": 7, "width": 13, "ranges": []}, {"name": "TRIBALCT", "vtype": "VARCHAR", "position": 8, "desc": "Tribal census tract GEO_ID", "column": 8, "width": 19, "ranges": []}, {"name": "CD", "vtype": "VARCHAR", "position": 9, "desc": "Congressional district GEO_ID", "column": 9, "width": 13, "ranges": []}, {"name": "REGION", "vtype": "VARCHAR", "position": 10, "desc": "Region GEO_ID", "column": 10, "width": 10, "ranges": []}, {"name": "ACO", "vtype": "VARCHAR", "position": 11, "desc": "ACO code", "column": 11, "width": 4, "ranges": []}]}}}
